<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
    <title>
      NFFT 3.0.3 API Reference - NFFT: util.c Source File
    </title>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <table>
      <tr>
        <td valign="top">
          <img src="images/logo.png" alt="NFFT Logo">
        </td>
        <td align="left" valign="bottom" width="100%">
          <H1nc>3.0.3 API Reference</H1nc>
        </td>
      </tr>
    </table>  
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000035.html">util</a></div>
<h1>util.c</h1><div class="fragment"><pre class="fragment">00001 
00006 <span class="preprocessor">#include "config.h"</span>
00007 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00008 <span class="preprocessor">#include "cstripack.h"</span>
00009 
00010 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00011 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00012 <span class="preprocessor">#include &lt;math.h&gt;</span>
00013 <span class="preprocessor">#include &lt;sys/time.h&gt;</span>
00014 <span class="preprocessor">#include &lt;sys/resource.h&gt;</span>
00015 <span class="preprocessor">#ifdef HAVE_MALLOC_H</span>
00016 <span class="preprocessor"></span><span class="preprocessor">  #include &lt;malloc.h&gt;</span>
00017 <span class="preprocessor">#endif</span>
00018 <span class="preprocessor"></span>
00019 <span class="comment">/*#include &lt;time.h&gt;*/</span>
00020 
00021 
<a name="l00025"></a><a class="code" href="group__nfftutil.html#ga0">00025</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga0">nfft_second</a>()
00026 {
00027   <span class="keyword">static</span> <span class="keyword">struct </span>rusage temp;
00028   <span class="keywordtype">double</span> foo, foo1;
00029 
00030   getrusage(RUSAGE_SELF,&amp;temp);
00031   foo     = temp.ru_utime.tv_sec;       <span class="comment">/* seconds                           */</span>
00032   foo1    = temp.ru_utime.tv_usec;      <span class="comment">/* uSecs                             */</span>
00033   <span class="keywordflow">return</span>  foo  + (foo1/1000000.0);      <span class="comment">/* milliseconds                      */</span>
00034 }
00035 
00036 <span class="preprocessor">#ifdef HAVE_MALLOC_H</span>
00037 <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="group__nfftutil.html#ga1">nfft_total_used_memory</a>()
00038 {
00039   <span class="keyword">struct </span>mallinfo m;
00040   m=mallinfo();
00041   <span class="keywordflow">return</span> m.hblkhd + m.uordblks;
00042 }
00043 <span class="preprocessor">#else</span>
<a name="l00044"></a><a class="code" href="group__nfftutil.html#ga1">00044</a> <span class="preprocessor"></span><span class="keywordtype">int</span> <a class="code" href="group__nfftutil.html#ga1">nfft_total_used_memory</a>()
00045 {
00046   fprintf(stderr,
00047     <span class="stringliteral">"\nWarning in util/total_used_memory: mallinfo() not available\n"</span>);
00048   <span class="keywordflow">return</span> 0;
00049 }
00050 <span class="preprocessor">#endif</span>
00051 <span class="preprocessor"></span>
<a name="l00052"></a><a class="code" href="group__nfftutil.html#ga3">00052</a> <span class="keywordtype">int</span> <a class="code" href="group__nfftutil.html#ga3">nfft_int_2_pow</a>(<span class="keywordtype">int</span> a)
00053 {
00054   <span class="keywordflow">return</span> (1U&lt;&lt; a);
00055 }
00056 
<a name="l00057"></a><a class="code" href="group__nfftutil.html#ga2">00057</a> <span class="keywordtype">int</span> <a class="code" href="group__nfftutil.html#ga2">nfft_ld</a>(<span class="keywordtype">int</span> m)
00058 {
00059   <span class="keywordtype">int</span> l=0;
00060   <span class="keywordtype">int</span> mm=m;
00061 
00062   <span class="keywordflow">while</span>(mm&gt;0)
00063     {
00064       mm=(mm&gt;&gt;1);
00065       l++;
00066     }
00067   <span class="keywordflow">return</span> (l-1);
00068 }
00069 
<a name="l00072"></a><a class="code" href="group__nfftutil.html#ga4">00072</a> <span class="keywordtype">int</span> <a class="code" href="group__nfftutil.html#ga4">nfft_next_power_of_2</a>(<span class="keywordtype">int</span> N)
00073 {
00074   <span class="keywordtype">int</span> n,i,logn;
00075   <span class="keywordtype">int</span> N_is_not_power_of_2=0;
00076 
00077   <span class="keywordflow">if</span> (N == 0)
00078   {
00079     <span class="keywordflow">return</span> 1;
00080   }
00081   <span class="keywordflow">else</span>
00082   {
00083     n=N;
00084     logn=0;
00085     <span class="keywordflow">while</span> (n != 1)
00086     {
00087       <span class="keywordflow">if</span> (n%2 == 1)
00088       {
00089           N_is_not_power_of_2=1;
00090       }
00091       n = n/2;
00092       logn++;
00093     }
00094 
00095     <span class="keywordflow">if</span> (!N_is_not_power_of_2)
00096     {
00097       logn--;
00098     }
00099 
00100     <span class="keywordflow">for</span> (i = 0; i &lt;= logn; i++)
00101     {
00102       n = n*2;
00103     }
00104 
00105     <span class="keywordflow">return</span> n;
00106   }
00107 }
00108 
<a name="l00111"></a><a class="code" href="group__nfftutil.html#ga5">00111</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga5">nfft_next_power_of_2_exp</a>(<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> *N2, <span class="keywordtype">int</span> *t)
00112 {
00113   <span class="keywordtype">int</span> n,i,logn;
00114   <span class="keywordtype">int</span> N_is_not_power_of_2=0;
00115 
00116   <span class="keywordflow">if</span> (N == 0)
00117   {
00118     *N2 = 1;
00119     *t = 0;
00120   }
00121   <span class="keywordflow">else</span>
00122   {
00123     n=N;
00124     logn=0;
00125     <span class="keywordflow">while</span> (n != 1)
00126     {
00127       <span class="keywordflow">if</span> (n%2 == 1)
00128       {
00129           N_is_not_power_of_2=1;
00130       }
00131       n = n/2;
00132       logn++;
00133     }
00134 
00135     <span class="keywordflow">if</span> (!N_is_not_power_of_2)
00136     {
00137       logn--;
00138     }
00139 
00140     <span class="keywordflow">for</span> (i = 0; i &lt;= logn; i++)
00141     {
00142       n = n*2;
00143     }
00144 
00145     *N2 = n;
00146     *t = logn+1;
00147   }
00148 }
00149 
<a name="l00152"></a><a class="code" href="group__nfftutil.html#ga10">00152</a> <span class="keywordtype">int</span> <a class="code" href="group__nfftutil.html#ga10">nfft_prod_int</a>(<span class="keywordtype">int</span> *vec, <span class="keywordtype">int</span> d)
00153 {
00154   <span class="keywordtype">int</span> t, prod;
00155 
00156   prod=1;
00157   <span class="keywordflow">for</span>(t=0; t&lt;d; t++)
00158     prod *= vec[t];
00159 
00160   <span class="keywordflow">return</span> prod;
00161 }
00162 
<a name="l00165"></a><a class="code" href="group__nfftutil.html#ga11">00165</a> <span class="keywordtype">int</span> <a class="code" href="group__nfftutil.html#ga11">nfct_prod_int</a>(<span class="keywordtype">int</span> *vec, <span class="keywordtype">int</span> d)
00166 {
00167   <span class="keywordflow">return</span> <a class="code" href="group__nfftutil.html#ga10">nfft_prod_int</a>(vec, d);
00168 }
00169 
<a name="l00172"></a><a class="code" href="group__nfftutil.html#ga12">00172</a> <span class="keywordtype">int</span> <a class="code" href="group__nfftutil.html#ga12">nfst_prod_minus_a_int</a>(<span class="keywordtype">int</span> *vec, <span class="keywordtype">int</span> a, <span class="keywordtype">int</span> d)
00173 {
00174   <span class="keywordtype">int</span> t, prod;
00175 
00176   prod=1;
00177   <span class="keywordflow">for</span>(t=0; t&lt;d; t++)
00178     prod *= vec[t]-a;
00179 
00180   <span class="keywordflow">return</span> prod;
00181 }
00182 
00183 
<a name="l00186"></a><a class="code" href="group__nfftutil.html#ga13">00186</a> <span class="keywordtype">int</span> <a class="code" href="group__nfftutil.html#ga13">nfft_plain_loop</a>(<span class="keywordtype">int</span> *idx,<span class="keywordtype">int</span> *N,<span class="keywordtype">int</span> d)
00187 {
00188   <span class="keywordtype">int</span> t,sum;
00189 
00190   sum=idx[0];
00191   <span class="keywordflow">for</span>(t=1; t&lt;d; t++)
00192     sum=sum*N[t]+idx[t];
00193 
00194   <span class="keywordflow">return</span> sum;
00195 }
00196 
<a name="l00199"></a><a class="code" href="group__nfftutil.html#ga14">00199</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga14">nfft_prod_real</a>(<span class="keywordtype">double</span> *vec,<span class="keywordtype">int</span> d)
00200 {
00201   <span class="keywordtype">int</span> t;
00202   <span class="keywordtype">double</span> prod;
00203 
00204   prod=1.0;
00205   <span class="keywordflow">for</span>(t=0; t&lt;d; t++)
00206     prod*=vec[t];
00207 
00208   <span class="keywordflow">return</span> prod;
00209 }
00210 
<a name="l00211"></a><a class="code" href="group__nfftutil.html#ga6">00211</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga6">nfft_sinc</a>(<span class="keywordtype">double</span> x)
00212 {
00213   <span class="keywordflow">if</span> (fabs(x) &lt; 1e-20)
00214     <span class="keywordflow">return</span>(1.0);
00215   <span class="keywordflow">else</span>
00216     <span class="keywordflow">return</span>((double)(sin(x)/x));
00217 } <span class="comment">/* sinc */</span>
00218 
00219 <span class="keywordtype">void</span> bspline_help(<span class="keywordtype">int</span> k, <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> *scratch, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> ug, <span class="keywordtype">int</span> og,
00220       <span class="keywordtype">int</span> r)
00221 {
00222   <span class="keywordtype">int</span> i;                                
00223   <span class="keywordtype">int</span> index;                            
00224   <span class="keywordtype">double</span> a;                             
00226   <span class="comment">/* computation of one column */</span>
00227   <span class="keywordflow">for</span>(i=og+r-k+1, index=og; index&gt;=ug; i--, index--)
00228     {
00229       a = ((double)(x - i)) / ((double)(k - j));
00230       scratch[index] = (1 - a) * scratch[index-1] + a * scratch[index];
00231     }
00232 } <span class="comment">/* bspline_help */</span>
00233 
<a name="l00237"></a><a class="code" href="group__nfftutil.html#ga8">00237</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga8">nfft_bspline</a>(<span class="keywordtype">int</span> k, <span class="keywordtype">double</span> x, <span class="keywordtype">double</span> *scratch)
00238 {
00239   <span class="keywordtype">double</span> result_value;                  
00240   <span class="keywordtype">int</span> r;                                
00241   <span class="keywordtype">int</span> g1,g2;                            
00242   <span class="keywordtype">int</span> j,index,ug,og;                    
00243   <span class="keywordtype">double</span> a;                             
00245   result_value=0.0;
00246   <span class="keywordflow">if</span>(0&lt;x &amp;&amp; x&lt;k)
00247     {
00248       <span class="comment">/* using symmetry around k/2 */</span>
00249       <span class="keywordflow">if</span>((k-x)&lt;x) x=k-x;
00250 
00251       r=(int)(ceil(x)-1.0);
00252 
00253       <span class="keywordflow">for</span>(index=0; index&lt;k; index++)
00254   scratch[index]=0.0;
00255 
00256       scratch[k-r-1]=1.0;
00257 
00258       <span class="comment">/* bounds of the algorithm */</span>
00259       g1 = r;
00260       g2 = k - 1 - r;
00261       ug = g2;
00262 
00263       <span class="comment">/* g1&lt;=g2 holds */</span>
00264 
00265       <span class="keywordflow">for</span>(j=1, og=g2+1; j&lt;=g1; j++, og++)
00266   {
00267     a = (x - r + k - 1 - og)/(k - j);
00268     scratch[og] = (1 - a) * scratch[og-1];
00269     bspline_help(k,x,scratch,j,ug+1,og-1,r);
00270     a = (x - r + k - 1 - ug)/(k - j);
00271     scratch[ug] = a * scratch[ug];
00272   }
00273       <span class="keywordflow">for</span>(og-- ; j&lt;=g2; j++)
00274   {
00275     bspline_help(k,x,scratch,j,ug+1,og,r);
00276     a = (x - r + k - 1 - ug)/(k - j);
00277     scratch[ug] = a * scratch[ug];
00278   }
00279       <span class="keywordflow">for</span>( ; j&lt;k; j++)
00280   {
00281     ug++;
00282     bspline_help(k,x,scratch,j,ug,og,r);
00283   }
00284       result_value = scratch[k-1];
00285     }
00286   <span class="keywordflow">return</span>(result_value);
00287 } <span class="comment">/* bspline */</span>
00288 
00289 <span class="comment">/*              mconf.h</span>
00290 <span class="comment"> *</span>
00291 <span class="comment"> *  Common include file for math routines</span>
00292 <span class="comment"> *</span>
00293 <span class="comment"> *</span>
00294 <span class="comment"> *</span>
00295 <span class="comment"> * SYNOPSIS:</span>
00296 <span class="comment"> *</span>
00297 <span class="comment"> * #include "mconf.h"</span>
00298 <span class="comment"> *</span>
00299 <span class="comment"> *</span>
00300 <span class="comment"> *</span>
00301 <span class="comment"> * DESCRIPTION:</span>
00302 <span class="comment"> *</span>
00303 <span class="comment"> * This file contains definitions for error codes that are</span>
00304 <span class="comment"> * passed to the common error handling routine mtherr()</span>
00305 <span class="comment"> * (which see).</span>
00306 <span class="comment"> *</span>
00307 <span class="comment"> * The file also includes a conditional assembly definition</span>
00308 <span class="comment"> * for the type of computer arithmetic (IEEE, DEC, Motorola</span>
00309 <span class="comment"> * IEEE, or UNKnown).</span>
00310 <span class="comment"> *</span>
00311 <span class="comment"> * For Digital Equipment PDP-11 and VAX computers, certain</span>
00312 <span class="comment"> * IBM systems, and others that use numbers with a 56-bit</span>
00313 <span class="comment"> * significand, the symbol DEC should be defined.  In this</span>
00314 <span class="comment"> * mode, most floating point constants are given as arrays</span>
00315 <span class="comment"> * of octal integers to eliminate decimal to binary conversion</span>
00316 <span class="comment"> * errors that might be introduced by the compiler.</span>
00317 <span class="comment"> *</span>
00318 <span class="comment"> * For little-endian computers, such as IBM PC, that follow the</span>
00319 <span class="comment"> * IEEE Standard for Binary Floating Point Arithmetic (ANSI/IEEE</span>
00320 <span class="comment"> * Std 754-1985), the symbol IBMPC should be defined.  These</span>
00321 <span class="comment"> * numbers have 53-bit significands.  In this mode, constants</span>
00322 <span class="comment"> * are provided as arrays of hexadecimal 16 bit integers.</span>
00323 <span class="comment"> *</span>
00324 <span class="comment"> * Big-endian IEEE format is denoted MIEEE.  On some RISC</span>
00325 <span class="comment"> * systems such as Sun SPARC, double precision constants</span>
00326 <span class="comment"> * must be stored on 8-byte address boundaries.  Since integer</span>
00327 <span class="comment"> * arrays may be aligned differently, the MIEEE configuration</span>
00328 <span class="comment"> * may fail on such machines.</span>
00329 <span class="comment"> *</span>
00330 <span class="comment"> * To accommodate other types of computer arithmetic, all</span>
00331 <span class="comment"> * constants are also provided in a normal decimal radix</span>
00332 <span class="comment"> * which one can hope are correctly converted to a suitable</span>
00333 <span class="comment"> * format by the available C language compiler.  To invoke</span>
00334 <span class="comment"> * this mode, define the symbol UNK.</span>
00335 <span class="comment"> *</span>
00336 <span class="comment"> * An important difference among these modes is a predefined</span>
00337 <span class="comment"> * set of machine arithmetic constants for each.  The numbers</span>
00338 <span class="comment"> * MACHEP (the machine roundoff error), MAXNUM (largest number</span>
00339 <span class="comment"> * represented), and several other parameters are preset by</span>
00340 <span class="comment"> * the configuration symbol.  Check the file const.c to</span>
00341 <span class="comment"> * ensure that these values are correct for your computer.</span>
00342 <span class="comment"> *</span>
00343 <span class="comment"> * Configurations NANS, INFINITIES, MINUSZERO, and DENORMAL</span>
00344 <span class="comment"> * may fail on many systems.  Verify that they are supposed</span>
00345 <span class="comment"> * to work on your computer.</span>
00346 <span class="comment"> */</span>
00347 <span class="comment">/*</span>
00348 <span class="comment">Cephes Math Library Release 2.3:  June, 1995</span>
00349 <span class="comment">Copyright 1984, 1987, 1989, 1995 by Stephen L. Moshier</span>
00350 <span class="comment">*/</span>
00351 
00352 <span class="comment">/* Define if the `long double' type works.  */</span>
00353 <span class="preprocessor">#define HAVE_LONG_DOUBLE 1</span>
00354 <span class="preprocessor"></span>
00355 <span class="comment">/* Define as the return type of signal handlers (int or void).  */</span>
00356 <span class="preprocessor">#define RETSIGTYPE void</span>
00357 <span class="preprocessor"></span>
00358 <span class="comment">/* Define if you have the ANSI C header files.  */</span>
00359 <span class="preprocessor">#define STDC_HEADERS 1</span>
00360 <span class="preprocessor"></span>
00361 <span class="comment">/* Define if your processor stores words with the most significant</span>
00362 <span class="comment">   byte first (like Motorola and SPARC, unlike Intel and VAX).  */</span>
00363 <span class="comment">/* #undef WORDS_BIGENDIAN */</span>
00364 
00365 <span class="comment">/* Define if floating point words are bigendian.  */</span>
00366 <span class="comment">/* #undef FLOAT_WORDS_BIGENDIAN */</span>
00367 
00368 <span class="comment">/* The number of bytes in a int.  */</span>
00369 <span class="preprocessor">#define SIZEOF_INT 4</span>
00370 <span class="preprocessor"></span>
00371 <span class="comment">/* Define if you have the &lt;string.h&gt; header file.  */</span>
00372 <span class="preprocessor">#define HAVE_STRING_H 1</span>
00373 <span class="preprocessor"></span>
00374 <span class="comment">/* Name of package */</span>
00375 <span class="comment">//#define PACKAGE "cephes"</span>
00376 
00377 <span class="comment">/* Version number of package */</span>
00378 <span class="comment">//#define VERSION "2.7"</span>
00379 
00380 <span class="comment">/* Constant definitions for math error conditions</span>
00381 <span class="comment"> */</span>
00382 
00383 <span class="preprocessor">#define DOMAIN    1  </span><span class="comment">/* argument domain error */</span>
00384 <span class="preprocessor">#define SING    2  </span><span class="comment">/* argument singularity */</span>
00385 <span class="preprocessor">#define OVERFLOW  3  </span><span class="comment">/* overflow range error */</span>
00386 <span class="preprocessor">#define UNDERFLOW  4  </span><span class="comment">/* underflow range error */</span>
00387 <span class="preprocessor">#define TLOSS    5  </span><span class="comment">/* total loss of precision */</span>
00388 <span class="preprocessor">#define PLOSS    6  </span><span class="comment">/* partial loss of precision */</span>
00389 
00390 <span class="preprocessor">#define EDOM    33</span>
00391 <span class="preprocessor"></span><span class="preprocessor">#define ERANGE    34</span>
00392 <span class="preprocessor"></span>
00393 <span class="comment">/* Type of computer arithmetic */</span>
00394 
00395 <span class="comment">/* PDP-11, Pro350, VAX:</span>
00396 <span class="comment"> */</span>
00397 <span class="comment">/* #define DEC 1 */</span>
00398 
00399 <span class="comment">/* Intel IEEE, low order words come first:</span>
00400 <span class="comment"> */</span>
00401 <span class="comment">/* #define IBMPC 1 */</span>
00402 
00403 <span class="comment">/* Motorola IEEE, high order words come first</span>
00404 <span class="comment"> * (Sun 680x0 workstation):</span>
00405 <span class="comment"> */</span>
00406 <span class="comment">/* #define MIEEE 1 */</span>
00407 
00408 <span class="comment">/* UNKnown arithmetic, invokes coefficients given in</span>
00409 <span class="comment"> * normal decimal format.  Beware of range boundary</span>
00410 <span class="comment"> * problems (MACHEP, MAXLOG, etc. in const.c) and</span>
00411 <span class="comment"> * roundoff problems in pow.c:</span>
00412 <span class="comment"> * (Sun SPARCstation)</span>
00413 <span class="comment"> */</span>
00414 <span class="preprocessor">#define UNK 1</span>
00415 <span class="preprocessor"></span>
00416 <span class="comment">/* If you define UNK, then be sure to set BIGENDIAN properly. */</span>
00417 <span class="preprocessor">#ifdef FLOAT_WORDS_BIGENDIAN</span>
00418 <span class="preprocessor"></span><span class="preprocessor">#define BIGENDIAN 1</span>
00419 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00420 <span class="preprocessor"></span><span class="preprocessor">#define BIGENDIAN 0</span>
00421 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00422 <span class="preprocessor"></span><span class="comment">/* Define this `volatile' if your compiler thinks</span>
00423 <span class="comment"> * that floating point arithmetic obeys the associative</span>
00424 <span class="comment"> * and distributive laws.  It will defeat some optimizations</span>
00425 <span class="comment"> * (but probably not enough of them).</span>
00426 <span class="comment"> *</span>
00427 <span class="comment"> * #define VOLATILE volatile</span>
00428 <span class="comment"> */</span>
00429 <span class="preprocessor">#define VOLATILE</span>
00430 <span class="preprocessor"></span>
00431 <span class="comment">/* For 12-byte long doubles on an i386, pad a 16-bit short 0</span>
00432 <span class="comment"> * to the end of real constants initialized by integer arrays.</span>
00433 <span class="comment"> *</span>
00434 <span class="comment"> * #define XPD 0,</span>
00435 <span class="comment"> *</span>
00436 <span class="comment"> * Otherwise, the type is 10 bytes long and XPD should be</span>
00437 <span class="comment"> * defined blank (e.g., Microsoft C).</span>
00438 <span class="comment"> *</span>
00439 <span class="comment"> * #define XPD</span>
00440 <span class="comment"> */</span>
00441 <span class="preprocessor">#define XPD 0,</span>
00442 <span class="preprocessor"></span>
00443 <span class="comment">/* Define to support tiny denormal numbers, else undefine. */</span>
00444 <span class="preprocessor">#define DENORMAL 1</span>
00445 <span class="preprocessor"></span>
00446 <span class="comment">/* Define to ask for infinity support, else undefine. */</span>
00447 <span class="preprocessor">#define INFINITIES 1</span>
00448 <span class="preprocessor"></span>
00449 <span class="comment">/* Define to ask for support of numbers that are Not-a-Number,</span>
00450 <span class="comment">   else undefine.  This may automatically define INFINITIES in some files. */</span>
00451 <span class="preprocessor">#define NANS 1</span>
00452 <span class="preprocessor"></span>
00453 <span class="comment">/* Define to distinguish between -0.0 and +0.0.  */</span>
00454 <span class="preprocessor">#define MINUSZERO 1</span>
00455 <span class="preprocessor"></span>
00456 <span class="comment">/* Define 1 for ANSI C atan2() function</span>
00457 <span class="comment">   See atan.c and clog.c. */</span>
00458 <span class="preprocessor">#define ANSIC 1</span>
00459 <span class="preprocessor"></span>
00460 <span class="comment">/*              chbevl.c</span>
00461 <span class="comment"> *</span>
00462 <span class="comment"> *  Evaluate Chebyshev series</span>
00463 <span class="comment"> *</span>
00464 <span class="comment"> *</span>
00465 <span class="comment"> *</span>
00466 <span class="comment"> * SYNOPSIS:</span>
00467 <span class="comment"> *</span>
00468 <span class="comment"> * int N;</span>
00469 <span class="comment"> * double x, y, coef[N], chebevl();</span>
00470 <span class="comment"> *</span>
00471 <span class="comment"> * y = chbevl( x, coef, N );</span>
00472 <span class="comment"> *</span>
00473 <span class="comment"> *</span>
00474 <span class="comment"> *</span>
00475 <span class="comment"> * DESCRIPTION:</span>
00476 <span class="comment"> *</span>
00477 <span class="comment"> * Evaluates the series</span>
00478 <span class="comment"> *</span>
00479 <span class="comment"> *        N-1</span>
00480 <span class="comment"> *         - '</span>
00481 <span class="comment"> *  y  =   &gt;   coef[i] T (x/2)</span>
00482 <span class="comment"> *         -            i</span>
00483 <span class="comment"> *        i=0</span>
00484 <span class="comment"> *</span>
00485 <span class="comment"> * of Chebyshev polynomials Ti at argument x/2.</span>
00486 <span class="comment"> *</span>
00487 <span class="comment"> * Coefficients are stored in reverse order, i.e. the zero</span>
00488 <span class="comment"> * order term is last in the array.  Note N is the number of</span>
00489 <span class="comment"> * coefficients, not the order.</span>
00490 <span class="comment"> *</span>
00491 <span class="comment"> * If coefficients are for the interval a to b, x must</span>
00492 <span class="comment"> * have been transformed to x -&gt; 2(2x - b - a)/(b-a) before</span>
00493 <span class="comment"> * entering the routine.  This maps x from (a, b) to (-1, 1),</span>
00494 <span class="comment"> * over which the Chebyshev polynomials are defined.</span>
00495 <span class="comment"> *</span>
00496 <span class="comment"> * If the coefficients are for the inverted interval, in</span>
00497 <span class="comment"> * which (a, b) is mapped to (1/b, 1/a), the transformation</span>
00498 <span class="comment"> * required is x -&gt; 2(2ab/x - b - a)/(b-a).  If b is infinity,</span>
00499 <span class="comment"> * this becomes x -&gt; 4a/x - 1.</span>
00500 <span class="comment"> *</span>
00501 <span class="comment"> *</span>
00502 <span class="comment"> *</span>
00503 <span class="comment"> * SPEED:</span>
00504 <span class="comment"> *</span>
00505 <span class="comment"> * Taking advantage of the recurrence properties of the</span>
00506 <span class="comment"> * Chebyshev polynomials, the routine requires one more</span>
00507 <span class="comment"> * addition per loop than evaluating a nested polynomial of</span>
00508 <span class="comment"> * the same degree.</span>
00509 <span class="comment"> *</span>
00510 <span class="comment"> */</span>
00511 
00512 <span class="comment">/*              chbevl.c  */</span>
00513 
00514 <span class="comment">/*</span>
00515 <span class="comment">Cephes Math Library Release 2.0:  April, 1987</span>
00516 <span class="comment">Copyright 1985, 1987 by Stephen L. Moshier</span>
00517 <span class="comment">Direct inquiries to 30 Frost Street, Cambridge, MA 02140</span>
00518 <span class="comment">*/</span>
00519 
00520 <span class="keywordtype">double</span> chbevl(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> array[], <span class="keywordtype">int</span> n)
00521 {
00522   <span class="keywordtype">double</span> b0, b1, b2, *p;
00523   <span class="keywordtype">int</span> i;
00524 
00525   p = array;
00526   b0 = *p++;
00527   b1 = 0.0;
00528   i = n - 1;
00529 
00530   <span class="keywordflow">do</span>
00531     {
00532       b2 = b1;
00533       b1 = b0;
00534       b0 = x * b1  -  b2  + *p++;
00535     }
00536   <span class="keywordflow">while</span>( --i );
00537 
00538   <span class="keywordflow">return</span>( 0.5*(b0-b2) );
00539 }
00540 
00541 <span class="comment">/*              i0.c</span>
00542 <span class="comment"> *</span>
00543 <span class="comment"> *  Modified Bessel function of order zero</span>
00544 <span class="comment"> *</span>
00545 <span class="comment"> *</span>
00546 <span class="comment"> *</span>
00547 <span class="comment"> * SYNOPSIS:</span>
00548 <span class="comment"> *</span>
00549 <span class="comment"> * double x, y, i0();</span>
00550 <span class="comment"> *</span>
00551 <span class="comment"> * y = i0( x );</span>
00552 <span class="comment"> *</span>
00553 <span class="comment"> *</span>
00554 <span class="comment"> *</span>
00555 <span class="comment"> * DESCRIPTION:</span>
00556 <span class="comment"> *</span>
00557 <span class="comment"> * Returns modified Bessel function of order zero of the</span>
00558 <span class="comment"> * argument.</span>
00559 <span class="comment"> *</span>
00560 <span class="comment"> * The function is defined as i0(x) = j0( ix ).</span>
00561 <span class="comment"> *</span>
00562 <span class="comment"> * The range is partitioned into the two intervals [0,8] and</span>
00563 <span class="comment"> * (8, infinity).  Chebyshev polynomial expansions are employed</span>
00564 <span class="comment"> * in each interval.</span>
00565 <span class="comment"> *</span>
00566 <span class="comment"> *</span>
00567 <span class="comment"> *</span>
00568 <span class="comment"> * ACCURACY:</span>
00569 <span class="comment"> *</span>
00570 <span class="comment"> *                      Relative error:</span>
00571 <span class="comment"> * arithmetic   domain     # trials      peak         rms</span>
00572 <span class="comment"> *    DEC       0,30         6000       8.2e-17     1.9e-17</span>
00573 <span class="comment"> *    IEEE      0,30        30000       5.8e-16     1.4e-16</span>
00574 <span class="comment"> *</span>
00575 <span class="comment"> */</span>
00576 
00577 <span class="comment">/*</span>
00578 <span class="comment">Cephes Math Library Release 2.8:  June, 2000</span>
00579 <span class="comment">Copyright 1984, 1987, 2000 by Stephen L. Moshier</span>
00580 <span class="comment">*/</span>
00581 
00582 <span class="comment">/* Chebyshev coefficients for exp(-x) I0(x)</span>
00583 <span class="comment"> * in the interval [0,8].</span>
00584 <span class="comment"> *</span>
00585 <span class="comment"> * lim(x-&gt;0){ exp(-x) I0(x) } = 1.</span>
00586 <span class="comment"> */</span>
00587 
00588 <span class="preprocessor">#ifdef UNK</span>
00589 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">double</span> A[] =
00590 {
00591 -4.41534164647933937950E-18,
00592  3.33079451882223809783E-17,
00593 -2.43127984654795469359E-16,
00594  1.71539128555513303061E-15,
00595 -1.16853328779934516808E-14,
00596  7.67618549860493561688E-14,
00597 -4.85644678311192946090E-13,
00598  2.95505266312963983461E-12,
00599 -1.72682629144155570723E-11,
00600  9.67580903537323691224E-11,
00601 -5.18979560163526290666E-10,
00602  2.65982372468238665035E-9,
00603 -1.30002500998624804212E-8,
00604  6.04699502254191894932E-8,
00605 -2.67079385394061173391E-7,
00606  1.11738753912010371815E-6,
00607 -4.41673835845875056359E-6,
00608  1.64484480707288970893E-5,
00609 -5.75419501008210370398E-5,
00610  1.88502885095841655729E-4,
00611 -5.76375574538582365885E-4,
00612  1.63947561694133579842E-3,
00613 -4.32430999505057594430E-3,
00614  1.05464603945949983183E-2,
00615 -2.37374148058994688156E-2,
00616  4.93052842396707084878E-2,
00617 -9.49010970480476444210E-2,
00618  1.71620901522208775349E-1,
00619 -3.04682672343198398683E-1,
00620  6.76795274409476084995E-1
00621 };
00622 <span class="preprocessor">#endif</span>
00623 <span class="preprocessor"></span>
00624 <span class="preprocessor">#ifdef DEC</span>
00625 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> A[] = {
00626 0121642,0162671,0004646,0103567,
00627 0022431,0115424,0135755,0026104,
00628 0123214,0023533,0110365,0156635,
00629 0023767,0033304,0117662,0172716,
00630 0124522,0100426,0012277,0157531,
00631 0025254,0155062,0054461,0030465,
00632 0126010,0131143,0013560,0153604,
00633 0026517,0170577,0006336,0114437,
00634 0127227,0162253,0152243,0052734,
00635 0027724,0142766,0061641,0160200,
00636 0130416,0123760,0116564,0125262,
00637 0031066,0144035,0021246,0054641,
00638 0131537,0053664,0060131,0102530,
00639 0032201,0155664,0165153,0020652,
00640 0132617,0061434,0074423,0176145,
00641 0033225,0174444,0136147,0122542,
00642 0133624,0031576,0056453,0020470,
00643 0034211,0175305,0172321,0041314,
00644 0134561,0054462,0147040,0165315,
00645 0035105,0124333,0120203,0162532,
00646 0135427,0013750,0174257,0055221,
00647 0035726,0161654,0050220,0100162,
00648 0136215,0131361,0000325,0041110,
00649 0036454,0145417,0117357,0017352,
00650 0136702,0072367,0104415,0133574,
00651 0037111,0172126,0072505,0014544,
00652 0137302,0055601,0120550,0033523,
00653 0037457,0136543,0136544,0043002,
00654 0137633,0177536,0001276,0066150,
00655 0040055,0041164,0100655,0010521
00656 };
00657 <span class="preprocessor">#endif</span>
00658 <span class="preprocessor"></span>
00659 <span class="preprocessor">#ifdef IBMPC</span>
00660 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> A[] = {
00661 0xd0ef,0x2134,0x5cb7,0xbc54,
00662 0xa589,0x977d,0x3362,0x3c83,
00663 0xbbb4,0x721e,0x84eb,0xbcb1,
00664 0x5eba,0x93f6,0xe6d8,0x3cde,
00665 0xfbeb,0xc297,0x5022,0xbd0a,
00666 0x2627,0x4b26,0x9b46,0x3d35,
00667 0x1af0,0x62ee,0x164c,0xbd61,
00668 0xd324,0xe19b,0xfe2f,0x3d89,
00669 0x6abc,0x7a94,0xfc95,0xbdb2,
00670 0x3c10,0xcc74,0x98be,0x3dda,
00671 0x9556,0x13ae,0xd4fe,0xbe01,
00672 0xcb34,0xa454,0xd903,0x3e26,
00673 0x30ab,0x8c0b,0xeaf6,0xbe4b,
00674 0x6435,0x9d4d,0x3b76,0x3e70,
00675 0x7f8d,0x8f22,0xec63,0xbe91,
00676 0xf4ac,0x978c,0xbf24,0x3eb2,
00677 0x6427,0xcba5,0x866f,0xbed2,
00678 0x2859,0xbe9a,0x3f58,0x3ef1,
00679 0x1d5a,0x59c4,0x2b26,0xbf0e,
00680 0x7cab,0x7410,0xb51b,0x3f28,
00681 0xeb52,0x1f15,0xe2fd,0xbf42,
00682 0x100e,0x8a12,0xdc75,0x3f5a,
00683 0xa849,0x201a,0xb65e,0xbf71,
00684 0xe3dd,0xf3dd,0x9961,0x3f85,
00685 0xb6f0,0xf121,0x4e9e,0xbf98,
00686 0xa32d,0xcea8,0x3e8a,0x3fa9,
00687 0x06ea,0x342d,0x4b70,0xbfb8,
00688 0x88c0,0x77ac,0xf7ac,0x3fc5,
00689 0xcd8d,0xc057,0x7feb,0xbfd3,
00690 0xa22a,0x9035,0xa84e,0x3fe5,
00691 };
00692 <span class="preprocessor">#endif</span>
00693 <span class="preprocessor"></span>
00694 <span class="preprocessor">#ifdef MIEEE</span>
00695 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> A[] = {
00696 0xbc54,0x5cb7,0x2134,0xd0ef,
00697 0x3c83,0x3362,0x977d,0xa589,
00698 0xbcb1,0x84eb,0x721e,0xbbb4,
00699 0x3cde,0xe6d8,0x93f6,0x5eba,
00700 0xbd0a,0x5022,0xc297,0xfbeb,
00701 0x3d35,0x9b46,0x4b26,0x2627,
00702 0xbd61,0x164c,0x62ee,0x1af0,
00703 0x3d89,0xfe2f,0xe19b,0xd324,
00704 0xbdb2,0xfc95,0x7a94,0x6abc,
00705 0x3dda,0x98be,0xcc74,0x3c10,
00706 0xbe01,0xd4fe,0x13ae,0x9556,
00707 0x3e26,0xd903,0xa454,0xcb34,
00708 0xbe4b,0xeaf6,0x8c0b,0x30ab,
00709 0x3e70,0x3b76,0x9d4d,0x6435,
00710 0xbe91,0xec63,0x8f22,0x7f8d,
00711 0x3eb2,0xbf24,0x978c,0xf4ac,
00712 0xbed2,0x866f,0xcba5,0x6427,
00713 0x3ef1,0x3f58,0xbe9a,0x2859,
00714 0xbf0e,0x2b26,0x59c4,0x1d5a,
00715 0x3f28,0xb51b,0x7410,0x7cab,
00716 0xbf42,0xe2fd,0x1f15,0xeb52,
00717 0x3f5a,0xdc75,0x8a12,0x100e,
00718 0xbf71,0xb65e,0x201a,0xa849,
00719 0x3f85,0x9961,0xf3dd,0xe3dd,
00720 0xbf98,0x4e9e,0xf121,0xb6f0,
00721 0x3fa9,0x3e8a,0xcea8,0xa32d,
00722 0xbfb8,0x4b70,0x342d,0x06ea,
00723 0x3fc5,0xf7ac,0x77ac,0x88c0,
00724 0xbfd3,0x7feb,0xc057,0xcd8d,
00725 0x3fe5,0xa84e,0x9035,0xa22a
00726 };
00727 <span class="preprocessor">#endif</span>
00728 <span class="preprocessor"></span>
00729 
00730 <span class="comment">/* Chebyshev coefficients for exp(-x) sqrt(x) I0(x)</span>
00731 <span class="comment"> * in the inverted interval [8,infinity].</span>
00732 <span class="comment"> *</span>
00733 <span class="comment"> * lim(x-&gt;inf){ exp(-x) sqrt(x) I0(x) } = 1/sqrt(2pi).</span>
00734 <span class="comment"> */</span>
00735 
00736 <span class="preprocessor">#ifdef UNK</span>
00737 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">double</span> B[] =
00738 {
00739 -7.23318048787475395456E-18,
00740 -4.83050448594418207126E-18,
00741  4.46562142029675999901E-17,
00742  3.46122286769746109310E-17,
00743 -2.82762398051658348494E-16,
00744 -3.42548561967721913462E-16,
00745  1.77256013305652638360E-15,
00746  3.81168066935262242075E-15,
00747 -9.55484669882830764870E-15,
00748 -4.15056934728722208663E-14,
00749  1.54008621752140982691E-14,
00750  3.85277838274214270114E-13,
00751  7.18012445138366623367E-13,
00752 -1.79417853150680611778E-12,
00753 -1.32158118404477131188E-11,
00754 -3.14991652796324136454E-11,
00755  1.18891471078464383424E-11,
00756  4.94060238822496958910E-10,
00757  3.39623202570838634515E-9,
00758  2.26666899049817806459E-8,
00759  2.04891858946906374183E-7,
00760  2.89137052083475648297E-6,
00761  6.88975834691682398426E-5,
00762  3.36911647825569408990E-3,
00763  8.04490411014108831608E-1
00764 };
00765 <span class="preprocessor">#endif</span>
00766 <span class="preprocessor"></span>
00767 <span class="preprocessor">#ifdef DEC</span>
00768 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> B[] = {
00769 0122005,0066672,0123124,0054311,
00770 0121662,0033323,0030214,0104602,
00771 0022515,0170300,0113314,0020413,
00772 0022437,0117350,0035402,0007146,
00773 0123243,0000135,0057220,0177435,
00774 0123305,0073476,0144106,0170702,
00775 0023777,0071755,0017527,0154373,
00776 0024211,0052214,0102247,0033270,
00777 0124454,0017763,0171453,0012322,
00778 0125072,0166316,0075505,0154616,
00779 0024612,0133770,0065376,0025045,
00780 0025730,0162143,0056036,0001632,
00781 0026112,0015077,0150464,0063542,
00782 0126374,0101030,0014274,0065457,
00783 0127150,0077271,0125763,0157617,
00784 0127412,0104350,0040713,0120445,
00785 0027121,0023765,0057500,0001165,
00786 0030407,0147146,0003643,0075644,
00787 0031151,0061445,0044422,0156065,
00788 0031702,0132224,0003266,0125551,
00789 0032534,0000076,0147153,0005555,
00790 0033502,0004536,0004016,0026055,
00791 0034620,0076433,0142314,0171215,
00792 0036134,0146145,0013454,0101104,
00793 0040115,0171425,0062500,0047133
00794 };
00795 <span class="preprocessor">#endif</span>
00796 <span class="preprocessor"></span>
00797 <span class="preprocessor">#ifdef IBMPC</span>
00798 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> B[] = {
00799 0x8b19,0x54ca,0xadb7,0xbc60,
00800 0x9130,0x6611,0x46da,0xbc56,
00801 0x8421,0x12d9,0xbe18,0x3c89,
00802 0x41cd,0x0760,0xf3dd,0x3c83,
00803 0x1fe4,0xabd2,0x600b,0xbcb4,
00804 0xde38,0xd908,0xaee7,0xbcb8,
00805 0xfb1f,0xa3ea,0xee7d,0x3cdf,
00806 0xe6d7,0x9094,0x2a91,0x3cf1,
00807 0x629a,0x7e65,0x83fe,0xbd05,
00808 0xbb32,0xcf68,0x5d99,0xbd27,
00809 0xc545,0x0d5f,0x56ff,0x3d11,
00810 0xc073,0x6b83,0x1c8c,0x3d5b,
00811 0x8cec,0xfa26,0x4347,0x3d69,
00812 0x8d66,0x0317,0x9043,0xbd7f,
00813 0x7bf2,0x357e,0x0fd7,0xbdad,
00814 0x7425,0x0839,0x511d,0xbdc1,
00815 0x004f,0xabe8,0x24fe,0x3daa,
00816 0x6f75,0xc0f4,0xf9cc,0x3e00,
00817 0x5b87,0xa922,0x2c64,0x3e2d,
00818 0xd56d,0x80d6,0x5692,0x3e58,
00819 0x616e,0xd9cd,0x8007,0x3e8b,
00820 0xc586,0xc101,0x412b,0x3ec8,
00821 0x9e52,0x7899,0x0fa3,0x3f12,
00822 0x9049,0xa2e5,0x998c,0x3f6b,
00823 0x09cb,0xaca8,0xbe62,0x3fe9
00824 };
00825 <span class="preprocessor">#endif</span>
00826 <span class="preprocessor"></span>
00827 <span class="preprocessor">#ifdef MIEEE</span>
00828 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> B[] = {
00829 0xbc60,0xadb7,0x54ca,0x8b19,
00830 0xbc56,0x46da,0x6611,0x9130,
00831 0x3c89,0xbe18,0x12d9,0x8421,
00832 0x3c83,0xf3dd,0x0760,0x41cd,
00833 0xbcb4,0x600b,0xabd2,0x1fe4,
00834 0xbcb8,0xaee7,0xd908,0xde38,
00835 0x3cdf,0xee7d,0xa3ea,0xfb1f,
00836 0x3cf1,0x2a91,0x9094,0xe6d7,
00837 0xbd05,0x83fe,0x7e65,0x629a,
00838 0xbd27,0x5d99,0xcf68,0xbb32,
00839 0x3d11,0x56ff,0x0d5f,0xc545,
00840 0x3d5b,0x1c8c,0x6b83,0xc073,
00841 0x3d69,0x4347,0xfa26,0x8cec,
00842 0xbd7f,0x9043,0x0317,0x8d66,
00843 0xbdad,0x0fd7,0x357e,0x7bf2,
00844 0xbdc1,0x511d,0x0839,0x7425,
00845 0x3daa,0x24fe,0xabe8,0x004f,
00846 0x3e00,0xf9cc,0xc0f4,0x6f75,
00847 0x3e2d,0x2c64,0xa922,0x5b87,
00848 0x3e58,0x5692,0x80d6,0xd56d,
00849 0x3e8b,0x8007,0xd9cd,0x616e,
00850 0x3ec8,0x412b,0xc101,0xc586,
00851 0x3f12,0x0fa3,0x7899,0x9e52,
00852 0x3f6b,0x998c,0xa2e5,0x9049,
00853 0x3fe9,0xbe62,0xaca8,0x09cb
00854 };
00855 <span class="preprocessor">#endif</span>
00856 <span class="preprocessor"></span>
<a name="l00861"></a><a class="code" href="group__nfftutil.html#ga9">00861</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga9">nfft_i0</a>(<span class="keywordtype">double</span> x)
00862 {
00863   <span class="keywordtype">double</span> y;
00864 
00865   <span class="keywordflow">if</span>( x &lt; 0 )
00866     x = -x;
00867   <span class="keywordflow">if</span>( x &lt;= 8.0 )
00868     {
00869       y = (x/2.0) - 2.0;
00870       <span class="keywordflow">return</span>( exp(x) * chbevl( y, A, 30 ) );
00871     }
00872 
00873   <span class="keywordflow">return</span>(  exp(x) * chbevl( 32.0/x - 2.0, B, 25 ) / sqrt(x) );
00874 }
00875 
<a name="l00878"></a><a class="code" href="group__nfftutil.html#ga15">00878</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga15">nfft_dot_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">int</span> n)
00879 {
00880   <span class="keywordtype">int</span> k;
00881   <span class="keywordtype">double</span> dot;
00882 
00883   <span class="keywordflow">for</span>(k=0,dot=0; k&lt;n; k++)
00884     dot+=conj(x[k])*x[k];
00885 
00886   <span class="keywordflow">return</span> dot;
00887 }
00888 
<a name="l00891"></a><a class="code" href="group__nfftutil.html#ga16">00891</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga16">nfft_dot_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">int</span> n)
00892 {
00893   <span class="keywordtype">int</span> k;
00894   <span class="keywordtype">double</span> dot;
00895 
00896   <span class="keywordflow">for</span>(k=0,dot=0; k&lt;n; k++)
00897     dot+=x[k]*x[k];
00898 
00899   <span class="keywordflow">return</span> dot;
00900 }
00901 
00902 
<a name="l00905"></a><a class="code" href="group__nfftutil.html#ga17">00905</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga17">nfft_dot_w_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> *w, <span class="keywordtype">int</span> n)
00906 {
00907   <span class="keywordtype">int</span> k;
00908   <span class="keywordtype">double</span> dot;
00909 
00910   <span class="keywordflow">for</span>(k=0,dot=0.0; k&lt;n; k++)
00911     dot+=w[k]*conj(x[k])*x[k];
00912 
00913   <span class="keywordflow">return</span> dot;
00914 }
00915 
<a name="l00918"></a><a class="code" href="group__nfftutil.html#ga18">00918</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga18">nfft_dot_w_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *w, <span class="keywordtype">int</span> n)
00919 {
00920   <span class="keywordtype">int</span> k;
00921   <span class="keywordtype">double</span> dot;
00922 
00923   <span class="keywordflow">for</span>(k=0,dot=0.0; k&lt;n; k++)
00924     dot+=w[k]*x[k]*x[k];
00925 
00926   <span class="keywordflow">return</span> dot;
00927 }
00928 
00929 
<a name="l00933"></a><a class="code" href="group__nfftutil.html#ga19">00933</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga19">nfft_dot_w_w2_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> *w, <span class="keywordtype">double</span> *w2, <span class="keywordtype">int</span> n)
00934 {
00935   <span class="keywordtype">int</span> k;
00936   <span class="keywordtype">double</span> dot;
00937 
00938   <span class="keywordflow">for</span>(k=0,dot=0.0; k&lt;n; k++)
00939     dot+=w[k]*w2[k]*w2[k]*conj(x[k])*x[k];
00940 
00941   <span class="keywordflow">return</span> dot;
00942 }
00943 
<a name="l00947"></a><a class="code" href="group__nfftutil.html#ga20">00947</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga20">nfft_dot_w2_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> *w2, <span class="keywordtype">int</span> n)
00948 {
00949   <span class="keywordtype">int</span> k;
00950   <span class="keywordtype">double</span> dot;
00951 
00952   <span class="keywordflow">for</span>(k=0,dot=0.0; k&lt;n; k++)
00953     dot+=w2[k]*w2[k]*conj(x[k])*x[k];
00954 
00955   <span class="keywordflow">return</span> dot;
00956 }
00957 
<a name="l00960"></a><a class="code" href="group__nfftutil.html#ga21">00960</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga21">nfft_cp_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n)
00961 {
00962   <span class="keywordtype">int</span> k;
00963 
00964   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
00965     x[k]=y[k];
00966 }
00967 
<a name="l00970"></a><a class="code" href="group__nfftutil.html#ga22">00970</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga22">nfft_cp_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n)
00971 {
00972   <span class="keywordtype">int</span> k;
00973 
00974   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
00975     x[k]=y[k];
00976 }
00977 
<a name="l00980"></a><a class="code" href="group__nfftutil.html#ga23">00980</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga23">nfft_cp_a_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n)
00981 {
00982   <span class="keywordtype">int</span> k;
00983 
00984   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
00985     x[k]=a*y[k];
00986 }
00987 
00990 <span class="keywordtype">void</span> nfft_cp_a_double(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n)
00991 {
00992   <span class="keywordtype">int</span> k;
00993 
00994   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
00995     x[k]=a*y[k];
00996 }
00997 
00998 
<a name="l01001"></a><a class="code" href="group__nfftutil.html#ga24">01001</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga24">nfft_cp_w_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> *w, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n)
01002 {
01003   <span class="keywordtype">int</span> k;
01004 
01005   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
01006     x[k]=w[k]*y[k];
01007 }
01008 
<a name="l01011"></a><a class="code" href="group__nfftutil.html#ga25">01011</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga25">nfft_cp_w_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *w, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n)
01012 {
01013   <span class="keywordtype">int</span> k;
01014 
01015   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
01016     x[k]=w[k]*y[k];
01017 }
01018 
01019 
01020 
<a name="l01023"></a><a class="code" href="group__nfftutil.html#ga26">01023</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga26">nfft_upd_axpy_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n)
01024 {
01025   <span class="keywordtype">int</span> k;
01026 
01027   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
01028     x[k]=a*x[k]+y[k];
01029 }
01030 
<a name="l01033"></a><a class="code" href="group__nfftutil.html#ga27">01033</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga27">nfft_upd_axpy_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n)
01034 {
01035   <span class="keywordtype">int</span> k;
01036 
01037   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
01038     x[k]=a*x[k]+y[k];
01039 }
01040 
01041 
<a name="l01044"></a><a class="code" href="group__nfftutil.html#ga28">01044</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga28">nfft_upd_xpay_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n)
01045 {
01046   <span class="keywordtype">int</span> k;
01047 
01048   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
01049     x[k]+=a*y[k];
01050 }
01051 
<a name="l01054"></a><a class="code" href="group__nfftutil.html#ga29">01054</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga29">nfft_upd_xpay_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n)
01055 {
01056   <span class="keywordtype">int</span> k;
01057 
01058   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
01059     x[k]+=a*y[k];
01060 }
01061 
01062 
01063 
<a name="l01066"></a><a class="code" href="group__nfftutil.html#ga30">01066</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga30">nfft_upd_axpby_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">double</span> b, <span class="keywordtype">int</span> n)
01067 {
01068   <span class="keywordtype">int</span> k;
01069 
01070   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
01071     x[k]=a*x[k]+b*y[k];
01072 }
01073 
<a name="l01076"></a><a class="code" href="group__nfftutil.html#ga31">01076</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga31">nfft_upd_axpby_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> *y, <span class="keywordtype">double</span> b, <span class="keywordtype">int</span> n)
01077 {
01078   <span class="keywordtype">int</span> k;
01079 
01080   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
01081     x[k]=a*x[k]+b*y[k];
01082 }
01083 
01084 
<a name="l01087"></a><a class="code" href="group__nfftutil.html#ga32">01087</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga32">nfft_upd_xpawy_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> *w, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n)
01088 {
01089   <span class="keywordtype">int</span> k;
01090 
01091   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
01092     x[k]+=a*w[k]*y[k];
01093 }
01094 
<a name="l01097"></a><a class="code" href="group__nfftutil.html#ga33">01097</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga33">nfft_upd_xpawy_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> *w, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n)
01098 {
01099   <span class="keywordtype">int</span> k;
01100 
01101   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
01102     x[k]+=a*w[k]*y[k];
01103 }
01104 
01105 
01106 
<a name="l01109"></a><a class="code" href="group__nfftutil.html#ga34">01109</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga34">nfft_upd_axpwy_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> *w, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n)
01110 {
01111   <span class="keywordtype">int</span> k;
01112 
01113   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
01114     x[k]=a*x[k]+w[k]*y[k];
01115 }
01116 
<a name="l01119"></a><a class="code" href="group__nfftutil.html#ga35">01119</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga35">nfft_upd_axpwy_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> a, <span class="keywordtype">double</span> *w, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n)
01120 {
01121   <span class="keywordtype">int</span> k;
01122 
01123   <span class="keywordflow">for</span>(k=0;k&lt;n;k++)
01124     x[k]=a*x[k]+w[k]*y[k];
01125 }
01126 
01127 
<a name="l01128"></a><a class="code" href="group__nfftutil.html#ga36">01128</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga36">nfft_fftshift_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">int</span> d, <span class="keywordtype">int</span>* N)
01129 {
01130   <span class="keywordtype">int</span> d_pre, d_act, d_post;
01131   <span class="keywordtype">int</span> N_pre, N_act, N_post;
01132   <span class="keywordtype">int</span> k_pre, k_act, k_post;
01133   <span class="keywordtype">int</span> k,k_swap;
01134 
01135   <span class="keywordtype">double</span> complex x_swap;
01136 
01137   <span class="keywordflow">for</span>(d_act=0;d_act&lt;d;d_act++)
01138     {
01139       <span class="keywordflow">for</span>(d_pre=0, N_pre=1;d_pre&lt;d_act;d_pre++)
01140   N_pre*=N[d_pre];
01141 
01142       N_act=N[d_act];
01143 
01144       <span class="keywordflow">for</span>(d_post=d_act+1, N_post=1;d_post&lt;d;d_post++)
01145   N_post*=N[d_post];
01146 
01147       <span class="keywordflow">for</span>(k_pre=0;k_pre&lt;N_pre;k_pre++)
01148   <span class="keywordflow">for</span>(k_act=0;k_act&lt;N_act/2;k_act++)
01149     <span class="keywordflow">for</span>(k_post=0;k_post&lt;N_post;k_post++)
01150       {
01151         k=(k_pre*N_act+k_act)*N_post+k_post;
01152         k_swap=(k_pre*N_act+k_act+N_act/2)*N_post+k_post;
01153 
01154         x_swap=x[k];
01155         x[k]=x[k_swap];
01156         x[k_swap]=x_swap;
01157       }
01158     }
01159 }
01160 
01161 <span class="keywordtype">double</span> l_1_complex(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n)
01162 {
01163   <span class="keywordtype">int</span> k;
01164   <span class="keywordtype">double</span> l1;
01165 
01166   <span class="keywordflow">if</span>(y==NULL)
01167     <span class="keywordflow">for</span>(k=0,l1=0; k&lt;n; k++)
01168       l1+=cabs(x[k]);
01169   <span class="keywordflow">else</span>
01170     <span class="keywordflow">for</span>(k=0,l1=0; k&lt;n; k++)
01171       l1+=cabs(x[k]-y[k]);
01172 
01173   <span class="keywordflow">return</span> l1;
01174 }
01175 
01176 <span class="keywordtype">double</span> l_1_double(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n)
01177 {
01178   <span class="keywordtype">int</span> k;
01179   <span class="keywordtype">double</span> l1;
01180 
01181   <span class="keywordflow">if</span>(y==NULL)
01182     <span class="keywordflow">for</span>(k=0,l1=0; k&lt;n; k++)
01183       l1+=fabs(x[k]);
01184   <span class="keywordflow">else</span>
01185     <span class="keywordflow">for</span>(k=0,l1=0; k&lt;n; k++)
01186       l1+=fabs(x[k]-y[k]);
01187 
01188   <span class="keywordflow">return</span> l1;
01189 }
01190 
01191 
01192 
01193 
01194 <span class="keywordtype">double</span> l_2_complex(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n)
01195 {
01196   <span class="keywordtype">int</span> k;
01197   <span class="keywordtype">double</span> l22;
01198 
01199   <span class="keywordflow">if</span>(y==NULL)
01200     <span class="keywordflow">for</span>(k=0,l22=0; k&lt;n; k++)
01201       l22+=conj(x[k])*x[k];
01202   <span class="keywordflow">else</span>
01203     <span class="keywordflow">for</span>(k=0,l22=0; k&lt;n; k++)
01204       l22+=conj(x[k]-y[k])*(x[k]-y[k]);
01205 
01206   <span class="keywordflow">return</span> sqrt(l22);
01207 }
01208 
01209 <span class="keywordtype">double</span> l_2_double(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n)
01210 {
01211   <span class="keywordtype">int</span> k;
01212   <span class="keywordtype">double</span> l22;
01213 
01214   <span class="keywordflow">if</span>(y==NULL)
01215     <span class="keywordflow">for</span>(k=0,l22=0; k&lt;n; k++)
01216       l22+=x[k]*x[k];
01217   <span class="keywordflow">else</span>
01218     <span class="keywordflow">for</span>(k=0,l22=0; k&lt;n; k++)
01219       l22+=(x[k]-y[k])*(x[k]-y[k]);
01220 
01221   <span class="keywordflow">return</span> sqrt(l22);
01222 }
01223 
01224 
01225 
01226 
01227 <span class="keywordtype">double</span> l_infty_complex(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n)
01228 {
01229   <span class="keywordtype">int</span> k;
01230   <span class="keywordtype">double</span> linfty;
01231 
01232   <span class="keywordflow">if</span>(y==NULL)
01233     <span class="keywordflow">for</span>(k=0,linfty=0; k&lt;n; k++)
01234       linfty=((linfty&lt;cabs(x[k]))?cabs(x[k]):linfty);
01235   <span class="keywordflow">else</span>
01236     <span class="keywordflow">for</span>(k=0,linfty=0; k&lt;n; k++)
01237       linfty=((linfty&lt;cabs(x[k]-y[k]))?cabs(x[k]-y[k]):linfty);
01238 
01239   <span class="keywordflow">return</span> linfty;
01240 }
01241 
01242 
01243 <span class="keywordtype">double</span> l_infty_double(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n)
01244 {
01245   <span class="keywordtype">int</span> k;
01246   <span class="keywordtype">double</span> linfty;
01247 
01248   <span class="keywordflow">if</span>(y==NULL)
01249     <span class="keywordflow">for</span>(k=0,linfty=0; k&lt;n; k++)
01250       linfty=((linfty&lt;fabs(x[k]))?fabs(x[k]):linfty);
01251   <span class="keywordflow">else</span>
01252     <span class="keywordflow">for</span>(k=0,linfty=0; k&lt;n; k++)
01253       linfty=((linfty&lt;fabs(x[k]-y[k]))?fabs(x[k]-y[k]):linfty);
01254 
01255   <span class="keywordflow">return</span> linfty;
01256 }
01257 
01258 
01259 
01260 
01261 
<a name="l01264"></a><a class="code" href="group__nfftutil.html#ga37">01264</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga37">nfft_error_l_infty_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n)
01265 {
01266   <span class="keywordflow">return</span> (l_infty_complex(x, y, n)/l_infty_complex(x, NULL, n));
01267 }
01268 
<a name="l01271"></a><a class="code" href="group__nfftutil.html#ga38">01271</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga38">nfft_error_l_infty_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n)
01272 {
01273   <span class="keywordflow">return</span> (l_infty_double(x, y, n)/l_infty_double(x, NULL, n));
01274 }
01275 
01276 
01277 
<a name="l01280"></a><a class="code" href="group__nfftutil.html#ga39">01280</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga39">nfft_error_l_infty_1_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n,
01281              <span class="keywordtype">double</span> complex *z, <span class="keywordtype">int</span> m)
01282 {
01283   <span class="keywordflow">return</span> (l_infty_complex(x, y, n)/l_1_complex(z, NULL, m));
01284 }
01285 
<a name="l01288"></a><a class="code" href="group__nfftutil.html#ga40">01288</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga40">nfft_error_l_infty_1_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n,
01289                               <span class="keywordtype">double</span> *z, <span class="keywordtype">int</span> m)
01290 {
01291   <span class="keywordflow">return</span> (l_infty_double(x, y, n)/l_1_double(z, NULL, m));
01292 }
01293 
01294 
01295 
<a name="l01298"></a><a class="code" href="group__nfftutil.html#ga41">01298</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga41">nfft_error_l_2_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> complex *y, <span class="keywordtype">int</span> n)
01299 {
01300   <span class="keywordflow">return</span> (l_2_complex(x, y, n)/l_2_complex(x, NULL, n));
01301 }
01302 
<a name="l01305"></a><a class="code" href="group__nfftutil.html#ga42">01305</a> <span class="keywordtype">double</span>  <a class="code" href="group__nfftutil.html#ga42">nfft_error_l_2_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> n)
01306 {
01307   <span class="keywordflow">return</span> (l_2_double(x, y, n)/l_2_double(x, NULL, n));
01308 }
01309 
01310 
01311 
<a name="l01314"></a><a class="code" href="group__nfftutil.html#ga43">01314</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga43">nfft_vpr_int</a>(<span class="keywordtype">int</span> *x, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *text)
01315 {
01316   <span class="keywordtype">int</span> k;
01317 
01318   <span class="keywordflow">if</span>(text!=NULL)
01319   {
01320       printf (<span class="stringliteral">"\n %s, adr=%p\n"</span>, text, (<span class="keywordtype">void</span>*)x);
01321       <span class="keywordflow">for</span> (k=0; k&lt;n; k++)
01322       {
01323     <span class="keywordflow">if</span> (k%8==0)
01324         printf(<span class="stringliteral">"%6d.\t"</span>, k);
01325     printf(<span class="stringliteral">"%d,"</span>, x[k]);
01326     <span class="keywordflow">if</span> (k%8==7)
01327         printf(<span class="stringliteral">"\n"</span>);
01328       }
01329       <span class="keywordflow">if</span> (n%8!=0)
01330         printf(<span class="stringliteral">"\n"</span>);
01331   }
01332   <span class="keywordflow">else</span>
01333       <span class="keywordflow">for</span> (k=0; k&lt;n; k++)
01334     printf(<span class="stringliteral">"%d,\n"</span>, x[k]);
01335   fflush(stdout);
01336 }
01337 
<a name="l01340"></a><a class="code" href="group__nfftutil.html#ga44">01340</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga44">nfft_vpr_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *text)
01341 {
01342   <span class="keywordtype">int</span> k;
01343 
01344   <span class="keywordflow">if</span>(x==NULL)
01345     {
01346       printf(<span class="stringliteral">"null pointer\n"</span>);
01347       fflush(stdout);
01348       exit(-1);
01349     }
01350 
01351   <span class="keywordflow">if</span>(text!=NULL)
01352   {
01353       printf (<span class="stringliteral">"\n %s, adr=%p\n"</span>, text, (<span class="keywordtype">void</span>*)x);
01354       <span class="keywordflow">for</span> (k=0; k&lt;n; k++)
01355       {
01356     <span class="keywordflow">if</span> (k%8==0)
01357         printf(<span class="stringliteral">"%6d.\t"</span>, k);
01358     printf(<span class="stringliteral">"%+.1E,"</span>, x[k]);
01359     <span class="keywordflow">if</span> (k%8==7)
01360         printf(<span class="stringliteral">"\n"</span>);
01361       }
01362       <span class="keywordflow">if</span> (n%8!=0)
01363         printf(<span class="stringliteral">"\n"</span>);
01364   }
01365   <span class="keywordflow">else</span>
01366       <span class="keywordflow">for</span> (k=0; k&lt;n; k++)
01367     printf(<span class="stringliteral">"%+E,\n"</span>, x[k]);
01368   fflush(stdout);
01369 }
01370 
<a name="l01373"></a><a class="code" href="group__nfftutil.html#ga45">01373</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga45">nfft_vpr_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">int</span> n, <span class="keywordtype">char</span> *text)
01374 {
01375   <span class="keywordtype">int</span> k;
01376 
01377   <span class="keywordflow">if</span>(text!=NULL)
01378   {
01379       printf (<span class="stringliteral">"\n %s, adr=%p\n"</span>, text, (<span class="keywordtype">void</span>*)x);
01380       <span class="keywordflow">for</span> (k=0; k&lt;n; k++)
01381       {
01382     <span class="keywordflow">if</span> (k%4==0)
01383         printf(<span class="stringliteral">"%6d.\t"</span>, k);
01384     printf(<span class="stringliteral">"%+.1E%+.1Ei,"</span>, creal(x[k]), cimag(x[k]));
01385     <span class="keywordflow">if</span> (k%4==3)
01386         printf(<span class="stringliteral">"\n"</span>);
01387       }
01388       <span class="keywordflow">if</span> (n%4!=0)
01389         printf(<span class="stringliteral">"\n"</span>);
01390   }
01391   <span class="keywordflow">else</span>
01392       <span class="keywordflow">for</span> (k=0; k&lt;n; k++)
01393     printf(<span class="stringliteral">"%+E%+Ei,\n"</span>, creal(x[k]), cimag(x[k]));
01394   fflush(stdout);
01395 }
01396 
<a name="l01397"></a><a class="code" href="group__nfftutil.html#ga46">01397</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga46">nfft_vrand_unit_complex</a>(<span class="keywordtype">double</span> complex *x, <span class="keywordtype">int</span> n)
01398 {
01399   <span class="keywordtype">int</span> k;
01400 
01401   <span class="keywordflow">for</span> (k=0; k&lt;n; k++)
01402     x[k] = ((double)rand())/RAND_MAX + I*((double)rand())/RAND_MAX;
01403 }
01404 
<a name="l01405"></a><a class="code" href="group__nfftutil.html#ga47">01405</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga47">nfft_vrand_shifted_unit_double</a>(<span class="keywordtype">double</span> *x, <span class="keywordtype">int</span> n)
01406 {
01407   <span class="keywordtype">int</span> k;
01408 
01409   <span class="keywordflow">for</span> (k=0; k&lt;n; k++)
01410     x[k] = ((double)rand())/RAND_MAX - 0.5;
01411 }
01412 
<a name="l01415"></a><a class="code" href="group__nfftutil.html#ga48">01415</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga48">nfft_voronoi_weights_1d</a>(<span class="keywordtype">double</span> *w, <span class="keywordtype">double</span> *x, <span class="keywordtype">int</span> M)
01416 {
01417   <span class="keywordtype">int</span> j;
01418 
01419   w[0]=(x[1]-x[0])/2;
01420   <span class="keywordflow">for</span>(j=1;j&lt;M-1;j++)
01421     w[j]=(x[j+1]-x[j-1])/2;
01422   w[M-1]=(x[M-1]-x[M-2])/2;
01423 }
01424 
<a name="l01425"></a><a class="code" href="group__nfftutil.html#ga49">01425</a> <span class="keywordtype">void</span> <a class="code" href="group__nfftutil.html#ga49">nfft_voronoi_weights_S2</a>(<span class="keywordtype">double</span> *w, <span class="keywordtype">double</span> *xi, <span class="keywordtype">int</span> M)
01426 {
01427   <span class="keywordtype">double</span> *x;
01428   <span class="keywordtype">double</span> *y;
01429   <span class="keywordtype">double</span> *z;
01430   <span class="keywordtype">long</span> <span class="keywordtype">int</span> j;
01431   <span class="keywordtype">long</span> <span class="keywordtype">int</span> k;
01432   <span class="keywordtype">long</span> <span class="keywordtype">int</span> el;
01433   <span class="keywordtype">long</span> <span class="keywordtype">int</span> Mlocal = M;
01434   <span class="keywordtype">long</span> <span class="keywordtype">int</span> lnew;
01435   <span class="keywordtype">long</span> <span class="keywordtype">int</span> ier;
01436   <span class="keywordtype">long</span> <span class="keywordtype">int</span> *list;
01437   <span class="keywordtype">long</span> <span class="keywordtype">int</span> *lptr;
01438   <span class="keywordtype">long</span> <span class="keywordtype">int</span> *lend;
01439   <span class="keywordtype">long</span> <span class="keywordtype">int</span> *near;
01440   <span class="keywordtype">long</span> <span class="keywordtype">int</span> *next;
01441   <span class="keywordtype">double</span>  *dist;
01442   <span class="keywordtype">long</span> <span class="keywordtype">int</span> *ltri;
01443   <span class="keywordtype">long</span> <span class="keywordtype">int</span> *listc;
01444   <span class="keywordtype">long</span> <span class="keywordtype">int</span> nb;
01445   <span class="keywordtype">double</span> *xc;
01446   <span class="keywordtype">double</span> *yc;
01447   <span class="keywordtype">double</span> *zc;
01448   <span class="keywordtype">double</span> *rc;
01449   <span class="keywordtype">double</span> *vr;
01450   <span class="keywordtype">long</span> <span class="keywordtype">int</span> lp;
01451   <span class="keywordtype">long</span> <span class="keywordtype">int</span> lpl;
01452   <span class="keywordtype">long</span> <span class="keywordtype">int</span> kv;
01453   <span class="keywordtype">double</span> a;
01454 
01455   <span class="comment">/* Allocate memory for auxilliary arrays. */</span>
01456   x = (<span class="keywordtype">double</span>*) malloc(M * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
01457   y = (<span class="keywordtype">double</span>*) malloc(M * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
01458   z = (<span class="keywordtype">double</span>*) malloc(M * <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
01459 
01460   list = (<span class="keywordtype">long</span> <span class="keywordtype">int</span>*) malloc((6*M-12+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">int</span>));
01461   lptr = (<span class="keywordtype">long</span> <span class="keywordtype">int</span>*) malloc((6*M-12+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">int</span>));
01462   lend = (<span class="keywordtype">long</span> <span class="keywordtype">int</span>*) malloc((M+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">int</span>));
01463   near = (<span class="keywordtype">long</span> <span class="keywordtype">int</span>*) malloc((M+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">int</span>));
01464   next = (<span class="keywordtype">long</span> <span class="keywordtype">int</span>*) malloc((M+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">int</span>));
01465   dist = (<span class="keywordtype">double</span>*) malloc((M+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
01466   ltri = (<span class="keywordtype">long</span> <span class="keywordtype">int</span>*) malloc((6*M+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">int</span>));
01467   listc = (<span class="keywordtype">long</span> <span class="keywordtype">int</span>*) malloc((6*M-12+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">int</span>));
01468   xc = (<span class="keywordtype">double</span>*) malloc((2*M-4+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
01469   yc = (<span class="keywordtype">double</span>*) malloc((2*M-4+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
01470   zc = (<span class="keywordtype">double</span>*) malloc((2*M-4+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
01471   rc = (<span class="keywordtype">double</span>*) malloc((2*M-4+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
01472   vr = (<span class="keywordtype">double</span>*) malloc(3*(2*M-4+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
01473 
01474   <span class="comment">/* Convert from spherical Coordinates in [0,1/2]x[-1/2,1/2) to Cartesian</span>
01475 <span class="comment">   * coordinates. */</span>
01476   <span class="keywordflow">for</span> (k = 0; k &lt; M; k++)
01477   {
01478     x[k] = sin(2.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*k+1])*cos(2.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*k]);
01479     y[k] = sin(2.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*k+1])*sin(2.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*k]);
01480     z[k] = cos(2.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*k+1]);
01481   }
01482 
01483   <span class="comment">/* Generate Delaunay triangulation. */</span>
01484   trmesh_(&amp;Mlocal, x, y, z, list, lptr, lend, &amp;lnew, near, next, dist, &amp;ier);
01485 
01486   <span class="comment">/* Check error flag. */</span>
01487   <span class="keywordflow">if</span> (ier == 0)
01488   {
01489     <span class="comment">/* Get Voronoi vertices. */</span>
01490     crlist_(&amp;Mlocal, &amp;Mlocal, x, y, z, list, lend, lptr, &amp;lnew, ltri, listc, &amp;nb, xc,
01491       yc, zc, rc, &amp;ier);
01492 
01493     <span class="keywordflow">if</span> (ier == 0)
01494     {
01495       <span class="comment">/* Calcuate sizes of Voronoi regions. */</span>
01496       <span class="keywordflow">for</span> (k = 0; k &lt; M; k++)
01497       {
01498         <span class="comment">/* Get last neighbour index. */</span>
01499         lpl = lend[k];
01500         lp = lpl;
01501 
01502         j = 0;
01503         vr[3*j] = x[k];
01504         vr[3*j+1] = y[k];
01505         vr[3*j+2] = z[k];
01506 
01507         <span class="keywordflow">do</span>
01508         {
01509           j++;
01510           <span class="comment">/* Get next neighbour. */</span>
01511           lp = lptr[lp-1];
01512           kv = listc[lp-1];
01513           vr[3*j] = xc[kv-1];
01514           vr[3*j+1] = yc[kv-1];
01515           vr[3*j+2] = zc[kv-1];
01516           <span class="comment">/* fprintf(stderr, "lp = %ld\t", lp); */</span>
01517         } <span class="keywordflow">while</span> (lp != lpl);
01518 
01519         a = 0;
01520         <span class="keywordflow">for</span> (el = 0; el &lt; j; el++)
01521         {
01522           a += areas_(vr, &amp;vr[3*(el+1)],&amp;vr[3*(((el+1)%j)+1)]);
01523         }
01524 
01525         w[k] = a;
01526       }
01527     }
01528   }
01529 
01530   <span class="comment">/* Deallocate memory. */</span>
01531   free(x);
01532   free(y);
01533   free(z);
01534 
01535   free(list);
01536   free(lptr);
01537   free(lend);
01538   free(near);
01539   free(next);
01540   free(dist);
01541   free(ltri);
01542   free(listc);
01543   free(xc);
01544   free(yc);
01545   free(zc);
01546   free(rc);
01547   free(vr);
01548 }
01549 
<a name="l01553"></a><a class="code" href="group__nfftutil.html#ga50">01553</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga50">nfft_modified_fejer</a>(<span class="keywordtype">int</span> N,<span class="keywordtype">int</span> kk)
01554 {
01555   <span class="keywordtype">double</span> result;
01556 
01557   result=2.0/((double)N*N)*(1-fabs(2.0*kk+1)/((double)N));
01558 
01559   <span class="keywordflow">return</span> result;
01560 }
01561 
<a name="l01564"></a><a class="code" href="group__nfftutil.html#ga51">01564</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga51">nfft_modified_jackson2</a>(<span class="keywordtype">int</span> N,<span class="keywordtype">int</span> kk)
01565 {
01566   <span class="keywordtype">int</span> kj;
01567   <span class="keywordtype">double</span> result;
01568   <span class="keywordtype">double</span> n=(N/2+1)/2;
01569   <span class="keywordtype">double</span> k;
01570 
01571   <span class="keywordflow">for</span>(result=0,kj=kk;kj&lt;=kk+1;kj++)
01572     {
01573       k=fabs(kj);
01574       <span class="keywordflow">if</span>(k/n&lt;1)
01575   result+= 1 - (3.0*k + 6.0*n*pow(k,2) - 3.0*pow(k,3))
01576     / (2.0*n*(2.0*pow(n,2)+1.0));
01577       <span class="keywordflow">else</span>
01578   result+= (2*n-k)*(pow(2*n-k,2)-1) / (2.0*n*(2.0*pow(n,2)+1.0));
01579     }
01580 
01581   <span class="keywordflow">return</span> result;
01582 }
01583 
<a name="l01586"></a><a class="code" href="group__nfftutil.html#ga52">01586</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga52">nfft_modified_jackson4</a>(<span class="keywordtype">int</span> N,<span class="keywordtype">int</span> kk)
01587 {
01588   <span class="keywordtype">int</span> kj;
01589   <span class="keywordtype">double</span> result;
01590   <span class="keywordtype">double</span> n=(N/2+3)/4;
01591   <span class="keywordtype">double</span> k;
01592   <span class="keywordtype">double</span> normalisation=(2416*pow(n,7)+1120*pow(n,5)+784*pow(n,3)+720*n);
01593 
01594   <span class="keywordflow">for</span>(result=0,kj=kk;kj&lt;=kk+1;kj++)
01595     {
01596       k=fabs(kj);
01597 
01598       <span class="keywordflow">if</span>(k/n&lt;1)
01599   result+= 1 - (1260*k + (1680*pow(n,5)+2240*pow(n,3)+2940*n)*pow(k,2) -
01600           1715*pow(k,3) - (560*pow(n,3)+1400*n)*pow(k,4) + 490*
01601           pow(k,5) + 140*n*pow(k,6) - 35*pow(k,7)) / normalisation;
01602 
01603       <span class="keywordflow">if</span>((1&lt;=k/n)&amp;&amp;(k/n&lt;2))
01604     result+= ((2472*pow(n,7)+336*pow(n,5)+3528*pow(n,3)-1296*n) -
01605       (392*pow(n,6)-3920*pow(n,4)+8232*pow(n,2)-756)*k -
01606       (504*pow(n,5)+10080*pow(n,3)-5292*n)*pow(k,2) -
01607       (1960*pow(n,4)-7840*pow(n,2)+1029)*pow(k,3) +
01608       (2520*pow(n,3)-2520*n)*pow(k,4) - (1176*pow(n,2)-294)*pow(k,5)
01609       + 252*n*pow(k,6) - 21*pow(k,7)) / normalisation;
01610 
01611       <span class="keywordflow">if</span>((2&lt;=k/n)&amp;&amp;(k/n&lt;3))
01612    result+= (-(1112*pow(n,7)-12880*pow(n,5)+7448*pow(n,3)-720*n) +
01613       (12152*pow(n,6)-27440*pow(n,4)+8232*pow(n,2)-252)*k -
01614       (19320*pow(n,5)-21280*pow(n,3)+2940*n)*pow(k,2) +
01615       (13720*pow(n,4)-7840*pow(n,2)+343)*pow(k,3) -
01616       (5320*pow(n,3)-1400*n)*pow(k,4) + (1176*pow(n,2)-98)*pow(k,5)
01617       - 140*n*pow(k,6) + 7*pow(k,7)) / normalisation;
01618 
01619       <span class="keywordflow">if</span>((3&lt;=k/n)&amp;&amp;(k/n&lt;4))
01620   result+= ((4*n-k)*(pow(4*n-k,2)-1)*(pow(4*n-k,2)-4)*(pow(4*n-k,2)-9)) /
01621     normalisation;
01622     }
01623 
01624   <span class="keywordflow">return</span> result;
01625 }
01626 
<a name="l01629"></a><a class="code" href="group__nfftutil.html#ga53">01629</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga53">nfft_modified_sobolev</a>(<span class="keywordtype">double</span> mu,<span class="keywordtype">int</span> kk)
01630 {
01631   <span class="keywordtype">double</span> result;
01632   <span class="keywordtype">int</span> kj,k;
01633 
01634   <span class="keywordflow">for</span>(result=0,kj=kk;kj&lt;=kk+1;kj++)
01635     {
01636       k=fabs(kj);
01637       <span class="keywordflow">if</span>(k==0)
01638   result+=1;
01639       <span class="keywordflow">else</span>
01640   result+=pow(k,-2*mu);
01641     }
01642 
01643   <span class="keywordflow">return</span> result;
01644 }
01645 
<a name="l01648"></a><a class="code" href="group__nfftutil.html#ga54">01648</a> <span class="keywordtype">double</span> <a class="code" href="group__nfftutil.html#ga54">nfft_modified_multiquadric</a>(<span class="keywordtype">double</span> mu,<span class="keywordtype">double</span> c,<span class="keywordtype">int</span> kk)
01649 {
01650   <span class="keywordtype">double</span> result;
01651   <span class="keywordtype">int</span> kj,k;
01652 
01653   <span class="keywordflow">for</span>(result=0,kj=kk;kj&lt;=kk+1;kj++)
01654     {
01655       k=fabs(kj);
01656       result+=pow(k*k+c*c,-mu);
01657     }
01658 
01659   <span class="keywordflow">return</span> result;
01660 }
</pre></div>    <hr size="1"/>
    Generated on 5 Feb 2007 by Doxygen 1.4.1
  </body>
</html>
