<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
    <title>
      NFFT 3.0.3 API Reference - NFFT: fastsumS2.c Source File
    </title>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <table>
      <tr>
        <td valign="top">
          <img src="images/logo.png" alt="NFFT Logo">
        </td>
        <td align="left" valign="bottom" width="100%">
          <H1nc>3.0.3 API Reference</H1nc>
        </td>
      </tr>
    </table>  
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000006.html">applications</a>&nbsp;/&nbsp;<a class="el" href="dir_000011.html">fastsumS2</a></div>
<h1>fastsumS2.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/* $Id: fastsumS2.c 1144 2006-10-26 13:08:56Z keiner $</span>
00002 <span class="comment"> *</span>
00003 <span class="comment"> * fastsumS2 - Fast summation of radial functions on the sphere</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Copyright (C) 2005 Jens Keiner</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * This program is free software; you can redistribute it and/or modify</span>
00008 <span class="comment"> * it under the terms of the GNU General Public License as published by</span>
00009 <span class="comment"> * the Free Software Foundation; either version 2, or (at your option)</span>
00010 <span class="comment"> * any later version.</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> * This program is distributed in the hope that it will be useful,</span>
00013 <span class="comment"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
00014 <span class="comment"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
00015 <span class="comment"> * GNU General Public License for more details.</span>
00016 <span class="comment"> *</span>
00017 <span class="comment"> * You should have received a copy of the GNU General Public License</span>
00018 <span class="comment"> * along with this program; if not, write to the Free Software Foundation,</span>
00019 <span class="comment"> * Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</span>
00020 <span class="comment"> */</span>
00021 
00028 <span class="comment">/* Include standard C headers. */</span>
00029 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00030 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00031 <span class="preprocessor">#include &lt;math.h&gt;</span>
00032 
00033 <span class="comment">/* Include NFFT3 library header. */</span>
00034 <span class="preprocessor">#include "<a class="code" href="nfft3_8h.html">nfft3.h</a>"</span>
00035 
00036 <span class="comment">/* Include NFFT 3 utilities headers. */</span>
00037 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00038 
00039 <span class="comment">/* Include GSL header for spherical Bessel functions. */</span>
00040 <span class="preprocessor">#include "../3rdparty/gsl/specfunc/gsl_sf_bessel.h"</span>
00041 
<a name="l00043"></a><a class="code" href="group__applications__fastsumS2__test.html#ga6">00043</a> <span class="preprocessor">#define SYMBOL_ABEL_POISSON(k,h) (pow(h,k))</span>
00044 <span class="preprocessor"></span>
<a name="l00046"></a><a class="code" href="group__applications__fastsumS2__test.html#ga7">00046</a> <span class="preprocessor">#define SYMBOL_SINGULARITY(k,h) ((2.0/(2*k+1))*pow(h,k))</span>
00047 <span class="preprocessor"></span>
00048 <span class="comment">/* Flags for the different kernel functions */</span>
00049 
<a name="l00051"></a><a class="code" href="group__applications__fastsumS2__test.html#ga8">00051</a> <span class="preprocessor">#define KT_ABEL_POISSON (0)</span>
00052 <span class="preprocessor"></span>
<a name="l00053"></a><a class="code" href="group__applications__fastsumS2__test.html#ga9">00053</a> <span class="preprocessor">#define KT_SINGULARITY  (1)</span>
00054 <span class="preprocessor"></span>
<a name="l00055"></a><a class="code" href="group__applications__fastsumS2__test.html#ga10">00055</a> <span class="preprocessor">#define KT_LOC_SUPP     (2)</span>
00056 <span class="preprocessor"></span>
<a name="l00057"></a><a class="code" href="group__applications__fastsumS2__test.html#ga11">00057</a> <span class="preprocessor">#define KT_GAUSSIAN     (3)</span>
00058 <span class="preprocessor"></span>
<a name="l00060"></a><a class="code" href="group__applications__fastsumS2__test.html#ga12">00060</a> <span class="keyword">enum</span> <a class="code" href="group__applications__fastsumS2__test.html#ga12">pvalue</a> {NO = 0, YES = 1, BOTH = 2};
00061 
<a name="l00076"></a><a class="code" href="group__applications__fastsumS2__test.html#ga0">00076</a> <span class="keywordtype">double</span> <a class="code" href="group__applications__fastsumS2__test.html#ga0">innerProduct</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> phi1, <span class="keyword">const</span> <span class="keywordtype">double</span> theta1, <span class="keyword">const</span> <span class="keywordtype">double</span> phi2,
00077   <span class="keyword">const</span> <span class="keywordtype">double</span> theta2)
00078 {
00079   <span class="keywordflow">return</span> cos(theta1)*cos(theta2) + sin(theta1)*sin(theta2)*cos(phi1-phi2);
00080 }
00081 
<a name="l00093"></a><a class="code" href="group__applications__fastsumS2__test.html#ga1">00093</a> <span class="keywordtype">double</span> <a class="code" href="group__applications__fastsumS2__test.html#ga1">poissonKernel</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> h)
00094 {
00095   <span class="keywordflow">return</span> (1.0/(4*<a class="code" href="group__nfftutil.html#ga57">PI</a>))*(1-h*h)/pow(sqrt(1-2*h*x+h*h),3);
00096 }
00097 
<a name="l00109"></a><a class="code" href="group__applications__fastsumS2__test.html#ga2">00109</a> <span class="keywordtype">double</span> <a class="code" href="group__applications__fastsumS2__test.html#ga2">singularityKernel</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> h)
00110 {
00111   <span class="keywordflow">return</span> (1.0/(2*<a class="code" href="group__nfftutil.html#ga57">PI</a>))/sqrt(1-2*h*x+h*h);
00112 }
00113 
<a name="l00127"></a><a class="code" href="group__applications__fastsumS2__test.html#ga3">00127</a> <span class="keywordtype">double</span> <a class="code" href="group__applications__fastsumS2__test.html#ga3">locallySupportedKernel</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> h,
00128   <span class="keyword">const</span> <span class="keywordtype">double</span> lambda)
00129 {
00130   <span class="keywordflow">return</span> (x&lt;=h)?(0.0):(pow((x-h),lambda));
00131 }
00132 
<a name="l00145"></a><a class="code" href="group__applications__fastsumS2__test.html#ga4">00145</a> <span class="keywordtype">double</span> <a class="code" href="group__applications__fastsumS2__test.html#ga4">gaussianKernel</a>(<span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">double</span> sigma)
00146 {
00147    <span class="keywordflow">return</span> exp(2.0*sigma*(x-1));
00148 }
00149 
<a name="l00160"></a><a class="code" href="group__applications__fastsumS2__test.html#ga5">00160</a> <span class="keywordtype">int</span> <a class="code" href="flags_8c.html#a6">main</a> (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
00161 {
00162   <span class="keywordtype">double</span> **p;                  <span class="comment">/* The array containing the parameter sets     *</span>
00163 <span class="comment">                                * for the kernel functions                    */</span>
00164   <span class="keywordtype">int</span> *m;                      <span class="comment">/* The array containing the cut-off degrees M  */</span>
00165   <span class="keywordtype">int</span> **ld;                    <span class="comment">/* The array containing the numbers of source  *</span>
00166 <span class="comment">                                * and target nodes, L and D                   */</span>
00167   <span class="keywordtype">int</span> ip;                      <span class="comment">/* Index variable for p                        */</span>
00168   <span class="keywordtype">int</span> im;                      <span class="comment">/* Index variable for m                        */</span>
00169   <span class="keywordtype">int</span> ild;                     <span class="comment">/* Index variable for l                        */</span>
00170   <span class="keywordtype">int</span> ipp;                     <span class="comment">/* Index for kernel parameters                 */</span>
00171   <span class="keywordtype">int</span> ip_max;                  <span class="comment">/* The maximum index for p                     */</span>
00172   <span class="keywordtype">int</span> im_max;                  <span class="comment">/* The maximum index for m                     */</span>
00173   <span class="keywordtype">int</span> ild_max;                 <span class="comment">/* The maximum index for l                     */</span>
00174   <span class="keywordtype">int</span> ipp_max;                 <span class="comment">/* The maximum index for ip                    */</span>
00175   <span class="keywordtype">int</span> tc_max;                  <span class="comment">/* The number of testcases                     */</span>
00176   <span class="keywordtype">int</span> m_max;                   <span class="comment">/* The maximum cut-off degree M for the        *</span>
00177 <span class="comment">                                * current dataset                             */</span>
00178   <span class="keywordtype">int</span> l_max;                   <span class="comment">/* The maximum number of source nodes L for    *</span>
00179 <span class="comment">                                * the current dataset                         */</span>
00180   <span class="keywordtype">int</span> d_max;                   <span class="comment">/* The maximum number of target nodes D for    *</span>
00181 <span class="comment">                                * the current dataset                         */</span>
00182   <span class="keywordtype">long</span> ld_max_prec;            <span class="comment">/* The maximum number of source and target     *</span>
00183 <span class="comment">                                * nodes for precomputation multiplied         */</span>
00184   <span class="keywordtype">long</span> l_max_prec;             <span class="comment">/* The maximum number of source nodes for      *</span>
00185 <span class="comment">                                * precomputation                              */</span>
00186   <span class="keywordtype">int</span> tc;                      <span class="comment">/* Index variable for testcases                */</span>
00187   <span class="keywordtype">int</span> kt;                      <span class="comment">/* The kernel function                         */</span>
00188   <span class="keywordtype">int</span> cutoff;                  <span class="comment">/* The current NFFT cut-off parameter          */</span>
00189   <span class="keywordtype">double</span> threshold;            <span class="comment">/* The current NFSFT threshold parameter       */</span>
00190   <span class="keywordtype">double</span> t_d;                  <span class="comment">/* Time for direct algorithm in seconds        */</span>
00191   <span class="keywordtype">double</span> t_dp;                 <span class="comment">/* Time for direct algorithm with              *</span>
00192 <span class="comment">                                  precomputation in seconds                   */</span>
00193   <span class="keywordtype">double</span> t_fd;                 <span class="comment">/* Time for fast direct algorithm in seconds   */</span>
00194   <span class="keywordtype">double</span> t_f;                  <span class="comment">/* Time for fast algorithm in seconds          */</span>
00195   <span class="keywordtype">double</span> temp;                 <span class="comment">/*                                             */</span>
00196   <span class="keywordtype">double</span> err_f;                <span class="comment">/* Error E_infty for fast algorithm            */</span>
00197   <span class="keywordtype">double</span> err_fd;               <span class="comment">/* Error E_\infty for fast direct algorithm    */</span>
00198   <span class="keywordtype">double</span> t;                    <span class="comment">/*                                             */</span>
00199   <span class="keywordtype">int</span> precompute = NO;         <span class="comment">/*                                             */</span>
00200   complex <span class="keywordtype">double</span> *ptr;         <span class="comment">/*                                             */</span>
00201   <span class="keywordtype">double</span>* steed;               <span class="comment">/*                                             */</span>
00202   <span class="keywordtype">double</span>* steed2;              <span class="comment">/*                                             */</span>
00203   complex <span class="keywordtype">double</span> *b;           <span class="comment">/* The weights (b_l)_{l=0}^{L-1}               */</span>
00204   complex <span class="keywordtype">double</span> *f_hat;       <span class="comment">/* The spherical Fourier coefficients          */</span>
00205   complex <span class="keywordtype">double</span> *a;           <span class="comment">/* The Fourier-Legendre coefficients           */</span>
00206   <span class="keywordtype">double</span> *xi;                  <span class="comment">/* Target nodes                                */</span>
00207   <span class="keywordtype">double</span> *eta;                 <span class="comment">/* Source nodes                                */</span>
00208   complex <span class="keywordtype">double</span> *f_m;         <span class="comment">/* Approximate function values                 */</span>
00209   complex <span class="keywordtype">double</span> *f;           <span class="comment">/* Exact function values                       */</span>
00210   complex <span class="keywordtype">double</span> *prec = NULL; <span class="comment">/*                                             */</span>
00211   <a class="code" href="structnfsft__plan.html">nfsft_plan</a> plan;             <span class="comment">/* NFSFT plan                                  */</span>
00212   <a class="code" href="structnfsft__plan.html">nfsft_plan</a> plan_adjoint;     <span class="comment">/* adjoint NFSFT plan                          */</span>
00213   <span class="keywordtype">int</span> i;                       <span class="comment">/*                                             */</span>
00214   <span class="keywordtype">int</span> k;                       <span class="comment">/*                                             */</span>
00215   <span class="keywordtype">int</span> n;                       <span class="comment">/*                                             */</span>
00216   <span class="keywordtype">int</span> d;                       <span class="comment">/*                                             */</span>
00217   <span class="keywordtype">int</span> l;                       <span class="comment">/*                                             */</span>
00218   <span class="keywordtype">int</span> use_nfsft;               <span class="comment">/*                                             */</span>
00219   <span class="keywordtype">int</span> use_nfft;                <span class="comment">/*                                             */</span>
00220   <span class="keywordtype">int</span> use_fpt;                 <span class="comment">/*                                             */</span>
00221   <span class="keywordtype">int</span> rinc;                    <span class="comment">/*                                             */</span>
00222   <span class="keywordtype">double</span> constant;             <span class="comment">/*                                             */</span>
00223 
00224   <span class="comment">/* Read the number of testcases. */</span>
00225   fscanf(stdin,<span class="stringliteral">"testcases=%d\n"</span>,&amp;tc_max);
00226   fprintf(stdout,<span class="stringliteral">"%d\n"</span>,tc_max);
00227 
00228   <span class="comment">/* Process each testcase. */</span>
00229   <span class="keywordflow">for</span> (tc = 0; tc &lt; tc_max; tc++)
00230   {
00231     <span class="comment">/* Check if the fast transform shall be used. */</span>
00232     fscanf(stdin,<span class="stringliteral">"nfsft=%d\n"</span>,&amp;use_nfsft);
00233     fprintf(stdout,<span class="stringliteral">"%d\n"</span>,use_nfsft);
00234     <span class="keywordflow">if</span> (use_nfsft != NO)
00235     {
00236       <span class="comment">/* Check if the NFFT shall be used. */</span>
00237       fscanf(stdin,<span class="stringliteral">"nfft=%d\n"</span>,&amp;use_nfft);
00238       fprintf(stdout,<span class="stringliteral">"%d\n"</span>,use_nfft);
00239       <span class="keywordflow">if</span> (use_nfft != NO)
00240       {
00241         <span class="comment">/* Read the cut-off parameter. */</span>
00242         fscanf(stdin,<span class="stringliteral">"cutoff=%d\n"</span>,&amp;cutoff);
00243         fprintf(stdout,<span class="stringliteral">"%d\n"</span>,cutoff);
00244       }
00245       <span class="keywordflow">else</span>
00246       {
00247         <span class="comment">/* TODO remove this */</span>
00248         <span class="comment">/* Initialize unused variable with dummy value. */</span>
00249         cutoff = 1;
00250       }
00251       <span class="comment">/* Check if the fast polynomial transform shall be used. */</span>
00252       fscanf(stdin,<span class="stringliteral">"fpt=%d\n"</span>,&amp;use_fpt);
00253       fprintf(stdout,<span class="stringliteral">"%d\n"</span>,use_fpt);
00254       <span class="comment">/* Read the NFSFT threshold parameter. */</span>
00255       fscanf(stdin,<span class="stringliteral">"threshold=%lf\n"</span>,&amp;threshold);
00256       fprintf(stdout,<span class="stringliteral">"%lf\n"</span>,threshold);
00257     }
00258     <span class="keywordflow">else</span>
00259     {
00260       <span class="comment">/* TODO remove this */</span>
00261       <span class="comment">/* Set dummy values. */</span>
00262       cutoff = 3;
00263       threshold = 1000000000000.0;
00264     }
00265 
00266     <span class="comment">/* Initialize bandwidth bound. */</span>
00267     m_max = 0;
00268     <span class="comment">/* Initialize source nodes bound. */</span>
00269     l_max = 0;
00270     <span class="comment">/* Initialize target nodes bound. */</span>
00271     d_max = 0;
00272     <span class="comment">/* Initialize source nodes bound for precomputation. */</span>
00273     l_max_prec = 0;
00274     <span class="comment">/* Initialize source and target nodes bound for precomputation. */</span>
00275     ld_max_prec = 0;
00276 
00277     <span class="comment">/* Read the kernel type. This is one of KT_ABEL_POISSON, KT_SINGULARITY,</span>
00278 <span class="comment">     * KT_LOC_SUPP and KT_GAUSSIAN. */</span>
00279     fscanf(stdin,<span class="stringliteral">"kernel=%d\n"</span>,&amp;kt);
00280     fprintf(stdout,<span class="stringliteral">"%d\n"</span>,kt);
00281 
00282     <span class="comment">/* Read the number of parameter sets. */</span>
00283     fscanf(stdin,<span class="stringliteral">"parameter_sets=%d\n"</span>,&amp;ip_max);
00284     fprintf(stdout,<span class="stringliteral">"%d\n"</span>,ip_max);
00285 
00286     <span class="comment">/* Allocate memory for pointers to parameter sets. */</span>
00287     p = (<span class="keywordtype">double</span>**) malloc(ip_max*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
00288 
00289     <span class="comment">/* We now read in the parameter sets. */</span>
00290 
00291     <span class="comment">/* Read number of parameters. */</span>
00292     fscanf(stdin,<span class="stringliteral">"parameters=%d\n"</span>,&amp;ipp_max);
00293     fprintf(stdout,<span class="stringliteral">"%d\n"</span>,ipp_max);
00294 
00295     <span class="keywordflow">for</span> (ip = 0; ip &lt; ip_max; ip++)
00296     {
00297       <span class="comment">/* Allocate memory for the parameters. */</span>
00298       p[ip] = (<span class="keywordtype">double</span>*) malloc(ipp_max*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00299 
00300       <span class="comment">/* Read the parameters. */</span>
00301       <span class="keywordflow">for</span> (ipp = 0; ipp &lt; ipp_max; ipp++)
00302       {
00303         <span class="comment">/* Read the next parameter. */</span>
00304         fscanf(stdin,<span class="stringliteral">"%lf\n"</span>,&amp;p[ip][ipp]);
00305         fprintf(stdout,<span class="stringliteral">"%lf\n"</span>,p[ip][ipp]);
00306       }
00307     }
00308 
00309     <span class="comment">/* Read the number of cut-off degrees. */</span>
00310     fscanf(stdin,<span class="stringliteral">"bandwidths=%d\n"</span>,&amp;im_max);
00311     fprintf(stdout,<span class="stringliteral">"%d\n"</span>,im_max);
00312     m = (<span class="keywordtype">int</span>*) malloc(im_max*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00313 
00314     <span class="comment">/* Read the cut-off degrees. */</span>
00315     <span class="keywordflow">for</span> (im = 0; im &lt; im_max; im++)
00316     {
00317       <span class="comment">/* Read cut-off degree. */</span>
00318       fscanf(stdin,<span class="stringliteral">"%d\n"</span>,&amp;m[im]);
00319       fprintf(stdout,<span class="stringliteral">"%d\n"</span>,m[im]);
00320       m_max = <a class="code" href="group__nfftutil.html#ga58">NFFT_MAX</a>(m_max,m[im]);
00321     }
00322 
00323     <span class="comment">/* Read number of node specifications. */</span>
00324     fscanf(stdin,<span class="stringliteral">"node_sets=%d\n"</span>,&amp;ild_max);
00325     fprintf(stdout,<span class="stringliteral">"%d\n"</span>,ild_max);
00326     ld = (<span class="keywordtype">int</span>**) malloc(ild_max*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>*));
00327 
00328     <span class="comment">/* Read the run specification. */</span>
00329     <span class="keywordflow">for</span> (ild = 0; ild &lt; ild_max; ild++)
00330     {
00331       <span class="comment">/* Allocate memory for the run parameters. */</span>
00332       ld[ild] = (<span class="keywordtype">int</span>*) malloc(5*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00333 
00334       <span class="comment">/* Read number of source nodes. */</span>
00335       fscanf(stdin,<span class="stringliteral">"L=%d "</span>,&amp;ld[ild][0]);
00336       fprintf(stdout,<span class="stringliteral">"%d\n"</span>,ld[ild][0]);
00337       l_max = <a class="code" href="group__nfftutil.html#ga58">NFFT_MAX</a>(l_max,ld[ild][0]);
00338 
00339       <span class="comment">/* Read number of target nodes. */</span>
00340       fscanf(stdin,<span class="stringliteral">"D=%d "</span>,&amp;ld[ild][1]);
00341       fprintf(stdout,<span class="stringliteral">"%d\n"</span>,ld[ild][1]);
00342       d_max = <a class="code" href="group__nfftutil.html#ga58">NFFT_MAX</a>(d_max,ld[ild][1]);
00343 
00344       <span class="comment">/* Determine whether direct and fast algorithm shall be compared. */</span>
00345       fscanf(stdin,<span class="stringliteral">"compare=%d "</span>,&amp;ld[ild][2]);
00346       fprintf(stdout,<span class="stringliteral">"%d\n"</span>,ld[ild][2]);
00347 
00348       <span class="comment">/* Check if precomputation for the direct algorithm is used. */</span>
00349       <span class="keywordflow">if</span> (ld[ild][2] == YES)
00350       {
00351         <span class="comment">/* Read whether the precomputed version shall also be used. */</span>
00352         fscanf(stdin,<span class="stringliteral">"precomputed=%d\n"</span>,&amp;ld[ild][3]);
00353         fprintf(stdout,<span class="stringliteral">"%d\n"</span>,ld[ild][3]);
00354 
00355         <span class="comment">/* Read the number of repetitions over which measurements are</span>
00356 <span class="comment">         * averaged. */</span>
00357         fscanf(stdin,<span class="stringliteral">"repetitions=%d\n"</span>,&amp;ld[ild][4]);
00358         fprintf(stdout,<span class="stringliteral">"%d\n"</span>,ld[ild][4]);
00359 
00360         <span class="comment">/* Update ld_max_prec and l_max_prec. */</span>
00361         <span class="keywordflow">if</span> (ld[ild][3] == YES)
00362         {
00363           <span class="comment">/* Update ld_max_prec. */</span>
00364           ld_max_prec = <a class="code" href="group__nfftutil.html#ga58">NFFT_MAX</a>(ld_max_prec,ld[ild][0]*ld[ild][1]);
00365           <span class="comment">/* Update l_max_prec. */</span>
00366           l_max_prec = <a class="code" href="group__nfftutil.html#ga58">NFFT_MAX</a>(l_max_prec,ld[ild][0]);
00367           <span class="comment">/* Turn on the precomputation for the direct algorithm. */</span>
00368           precompute = YES;
00369         }
00370       }
00371       <span class="keywordflow">else</span>
00372       {
00373         <span class="comment">/* Set default value for the number of repetitions. */</span>
00374         ld[ild][4] = 1;
00375       }
00376     }
00377 
00378     <span class="comment">/* Allocate memory for data structures. */</span>
00379     b = (complex <span class="keywordtype">double</span>*) malloc(l_max*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
00380     eta = (<span class="keywordtype">double</span>*) malloc(2*l_max*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00381     f_hat = (complex <span class="keywordtype">double</span>*) malloc(<a class="code" href="group__nfsft.html#ga41">NFSFT_F_HAT_SIZE</a>(m_max)*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
00382     a = (complex <span class="keywordtype">double</span>*) malloc((m_max+1)*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
00383     xi = (<span class="keywordtype">double</span>*) malloc(2*d_max*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00384     f_m = (complex <span class="keywordtype">double</span>*) malloc(d_max*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
00385     f = (complex <span class="keywordtype">double</span>*) malloc(d_max*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
00386 
00387     <span class="comment">/* Allocate memory for precomputed data. */</span>
00388     <span class="keywordflow">if</span> (precompute == YES)
00389     {
00390       prec = (complex <span class="keywordtype">double</span>*) malloc(ld_max_prec*<span class="keyword">sizeof</span>(complex <span class="keywordtype">double</span>));
00391     }
00392 
00393     <span class="comment">/* Generate random source nodes and weights. */</span>
00394     <span class="keywordflow">for</span> (l = 0; l &lt; l_max; l++)
00395     {
00396       b[l] = (((double)rand())/RAND_MAX) - 0.5;
00397       eta[2*l] = (((double)rand())/RAND_MAX) - 0.5;
00398       eta[2*l+1] = acos(2.0*(((<span class="keywordtype">double</span>)rand())/RAND_MAX) - 1.0)/(2.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>);
00399     }
00400 
00401     <span class="comment">/* Generate random target nodes. */</span>
00402     <span class="keywordflow">for</span> (d = 0; d &lt; d_max; d++)
00403     {
00404       xi[2*d] = (((double)rand())/RAND_MAX) - 0.5;
00405       xi[2*d+1] = acos(2.0*(((<span class="keywordtype">double</span>)rand())/RAND_MAX) - 1.0)/(2.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>);
00406     }
00407 
00408     <span class="comment">/* Do precomputation. */</span>
00409     <a class="code" href="group__nfsft.html#ga4">nfsft_precompute</a>(m_max,threshold,
00410       ((use_nfsft==NO)?(<a class="code" href="group__nfsft.html#ga38">NFSFT_NO_FAST_ALGORITHM</a>):(0U<span class="comment">/*NFSFT_NO_DIRECT_ALGORITHM*/</span>)), 0U);
00411 
00412     <span class="comment">/* Process all parameter sets. */</span>
00413     <span class="keywordflow">for</span> (ip = 0; ip &lt; ip_max; ip++)
00414     {
00415       <span class="comment">/* Compute kernel coeffcients up to the maximum cut-off degree m_max. */</span>
00416       <span class="keywordflow">switch</span> (kt)
00417       {
00418         <span class="keywordflow">case</span> <a class="code" href="group__applications__fastsumS2__test.html#ga8">KT_ABEL_POISSON</a>:
00419           <span class="comment">/* Compute Fourier-Legendre coefficients for the Poisson kernel. */</span>
00420           <span class="keywordflow">for</span> (k = 0; k &lt;= m_max; k++)
00421           {
00422             a[k] = <a class="code" href="group__applications__fastsumS2__test.html#ga6">SYMBOL_ABEL_POISSON</a>(k,p[ip][0]);
00423           }
00424           <span class="keywordflow">break</span>;
00425 
00426         <span class="keywordflow">case</span> <a class="code" href="group__applications__fastsumS2__test.html#ga9">KT_SINGULARITY</a>:
00427           <span class="comment">/* Compute Fourier-Legendre coefficients for the singularity</span>
00428 <span class="comment">           * kernel. */</span>
00429           <span class="keywordflow">for</span> (k = 0; k &lt;= m_max; k++)
00430           {
00431             a[k] = <a class="code" href="group__applications__fastsumS2__test.html#ga7">SYMBOL_SINGULARITY</a>(k,p[ip][0]);
00432           }
00433           <span class="keywordflow">break</span>;
00434 
00435         <span class="keywordflow">case</span> <a class="code" href="group__applications__fastsumS2__test.html#ga10">KT_LOC_SUPP</a>:
00436           <span class="comment">/* Compute Fourier-Legendre coefficients for the locally supported</span>
00437 <span class="comment">           * kernel. */</span>
00438           <span class="keywordflow">for</span> (k = 0; k &lt;= m_max; k++)
00439           {
00440             <span class="comment">/* First case k = 0 for initialization of three-term recurrence. */</span>
00441             <span class="keywordflow">if</span> (k == 0)
00442             {
00443               a[k] = 1.0;
00444             }
00445             <span class="comment">/* Second case k = 1 for initialization of three-term recurrence. */</span>
00446             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (k == 1)
00447             {
00448               a[k] = ((p[ip][1]+1+p[ip][0])/(p[ip][1]+2.0))*a[k-1];
00449             }
00450             <span class="comment">/* Apply three-term recurrence. */</span>
00451             <span class="keywordflow">else</span>
00452             {
00453               a[k] = (1.0/(k+p[ip][1]+1))*((2*k-1)*p[ip][0]*a[k-1] -
00454                 (k-p[ip][1]-2)*a[k-2]);
00455             }
00456           }
00457           <span class="keywordflow">break</span>;
00458 
00459           <span class="keywordflow">case</span> <a class="code" href="group__applications__fastsumS2__test.html#ga11">KT_GAUSSIAN</a>:
00460             <span class="comment">/* Compute Fourier-Legendre coefficients for the locally supported</span>
00461 <span class="comment">             * kernel. */</span>
00462             steed = (<span class="keywordtype">double</span>*) malloc((m_max+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00463             steed2 = (<span class="keywordtype">double</span>*) malloc((m_max+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00464             gsl_sf_bessel_il_scaled_array(m_max,2.0*p[ip][0],steed);
00465             <span class="keywordflow">for</span> (k = 0; k &lt;= m_max; k++)
00466             {
00467               steed[k] = 4.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>;
00468               a[k] = steed[k];
00469             }
00470             <span class="keywordflow">for</span> (k = 0; k &lt;= m_max; k++)
00471             {
00472               steed[k] *= 4.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>;
00473               a[k] = steed[k];
00474             }
00475 
00476             free(steed);
00477             <span class="keywordflow">break</span>;
00478       }
00479 
00480       <span class="comment">/* Normalize Fourier-Legendre coefficients. */</span>
00481       <span class="keywordflow">for</span> (k = 0; k &lt;= m_max; k++)
00482       {
00483         a[k] *= (2*k+1)/(4*<a class="code" href="group__nfftutil.html#ga57">PI</a>);
00484       }
00485 
00486       <span class="comment">/* Process all node sets. */</span>
00487       <span class="keywordflow">for</span> (ild = 0; ild &lt; ild_max; ild++)
00488       {
00489         <span class="comment">/* Check if the fast algorithm shall be used. */</span>
00490         <span class="keywordflow">if</span> (ld[ild][2] != NO)
00491         {
00492           <span class="comment">/* Check if the direct algorithm with precomputation should be</span>
00493 <span class="comment">           * tested. */</span>
00494           <span class="keywordflow">if</span> (ld[ild][3] != NO)
00495           {
00496             <span class="comment">/* Get pointer to start of data. */</span>
00497             ptr = prec;
00498             <span class="comment">/* Calculate increment from one row to the next. */</span>
00499             rinc = l_max_prec-ld[ild][0];
00500 
00501             <span class="comment">/* Process al target nodes. */</span>
00502             <span class="keywordflow">for</span> (d = 0; d &lt; ld[ild][1]; d++)
00503             {
00504               <span class="comment">/* Process all source nodes. */</span>
00505               <span class="keywordflow">for</span> (l = 0; l &lt; ld[ild][0]; l++)
00506               {
00507                 <span class="comment">/* Compute inner product between current source and target</span>
00508 <span class="comment">                 * node. */</span>
00509                 temp = <a class="code" href="group__applications__fastsumS2__test.html#ga0">innerProduct</a>(2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*eta[2*l],2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*eta[2*l+1],
00510                   2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*d],2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*d+1]);
00511 
00512                 <span class="comment">/* Switch by the kernel type. */</span>
00513                 <span class="keywordflow">switch</span> (kt)
00514                 {
00515                   <span class="keywordflow">case</span> <a class="code" href="group__applications__fastsumS2__test.html#ga8">KT_ABEL_POISSON</a>:
00516                     <span class="comment">/* Evaluate the Poisson kernel for the current value. */</span>
00517                     *ptr++ = <a class="code" href="group__applications__fastsumS2__test.html#ga1">poissonKernel</a>(temp,p[ip][0]);
00518                    <span class="keywordflow">break</span>;
00519 
00520                   <span class="keywordflow">case</span> <a class="code" href="group__applications__fastsumS2__test.html#ga9">KT_SINGULARITY</a>:
00521                     <span class="comment">/* Evaluate the singularity kernel for the current</span>
00522 <span class="comment">                     * value. */</span>
00523                     *ptr++ = <a class="code" href="group__applications__fastsumS2__test.html#ga2">singularityKernel</a>(temp,p[ip][0]);
00524                     <span class="keywordflow">break</span>;
00525 
00526                   <span class="keywordflow">case</span> <a class="code" href="group__applications__fastsumS2__test.html#ga10">KT_LOC_SUPP</a>:
00527                      <span class="comment">/* Evaluate the localized kernel for the current</span>
00528 <span class="comment">                      * value. */</span>
00529                     *ptr++ = <a class="code" href="group__applications__fastsumS2__test.html#ga3">locallySupportedKernel</a>(temp,p[ip][0],p[ip][1]);
00530                     <span class="keywordflow">break</span>;
00531 
00532                     <span class="keywordflow">case</span> <a class="code" href="group__applications__fastsumS2__test.html#ga11">KT_GAUSSIAN</a>:
00533                        <span class="comment">/* Evaluate the spherical Gaussian kernel for the current</span>
00534 <span class="comment">                        * value. */</span>
00535                       *ptr++ = <a class="code" href="group__applications__fastsumS2__test.html#ga4">gaussianKernel</a>(temp,p[ip][0]);
00536                        <span class="keywordflow">break</span>;
00537                 }
00538               }
00539               <span class="comment">/* Increment pointer for next row. */</span>
00540               ptr += rinc;
00541             }
00542 
00543             <span class="comment">/* Initialize cumulative time variable. */</span>
00544             t_dp = 0.0;
00545 
00546             <span class="comment">/* Initialize time measurement. */</span>
00547             t = <a class="code" href="group__nfftutil.html#ga0">nfft_second</a>();
00548 
00549             <span class="comment">/* Cycle through all runs. */</span>
00550             <span class="keywordflow">for</span> (i = 0; i &lt; ld[ild][4]; i++)
00551             {
00552 
00553               <span class="comment">/* Reset pointer to start of precomputed data. */</span>
00554               ptr = prec;
00555               <span class="comment">/* Calculate increment from one row to the next. */</span>
00556               rinc = l_max_prec-ld[ild][0];
00557 
00558               <span class="comment">/* Check if the localized kernel is used. */</span>
00559               <span class="keywordflow">if</span> (kt == <a class="code" href="group__applications__fastsumS2__test.html#ga10">KT_LOC_SUPP</a>)
00560               {
00561                 <span class="comment">/* Perform final summation */</span>
00562 
00563                 <span class="comment">/* Calculate the multiplicative constant. */</span>
00564                 constant = ((p[ip][1]+1)/(2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*pow(1-p[ip][0],p[ip][1]+1)));
00565 
00566                 <span class="comment">/* Process all target nodes. */</span>
00567                 <span class="keywordflow">for</span> (d = 0; d &lt; ld[ild][1]; d++)
00568                 {
00569                   <span class="comment">/* Initialize function value. */</span>
00570                   f[d] = 0.0;
00571 
00572                   <span class="comment">/* Process all source nodes. */</span>
00573                   <span class="keywordflow">for</span> (l = 0; l &lt; ld[ild][0]; l++)
00574                   {
00575                     f[d] += b[l]*(*ptr++);
00576                   }
00577 
00578                   <span class="comment">/* Multiply with the constant. */</span>
00579                   f[d] *= constant;
00580 
00581                   <span class="comment">/* Proceed to next row. */</span>
00582                   ptr += rinc;
00583                 }
00584               }
00585               <span class="keywordflow">else</span>
00586               {
00587                 <span class="comment">/* Process all target nodes. */</span>
00588                 <span class="keywordflow">for</span> (d = 0; d &lt; ld[ild][1]; d++)
00589                 {
00590                   <span class="comment">/* Initialize function value. */</span>
00591                   f[d] = 0.0;
00592 
00593                   <span class="comment">/* Process all source nodes. */</span>
00594                   <span class="keywordflow">for</span> (l = 0; l &lt; ld[ild][0]; l++)
00595                   {
00596                     f[d] += b[l]*(*ptr++);
00597                   }
00598 
00599                   <span class="comment">/* Proceed to next row. */</span>
00600                   ptr += rinc;
00601                 }
00602               }
00603             }
00604 
00605             <span class="comment">/* Calculate the time needed. */</span>
00606             t_dp = <a class="code" href="group__nfftutil.html#ga0">nfft_second</a>() - t;
00607 
00608             <span class="comment">/* Calculate average time needed. */</span>
00609             t_dp = t_dp/((double)ld[ild][4]);
00610           }
00611           <span class="keywordflow">else</span>
00612           {
00613             <span class="comment">/* Initialize cumulative time variable with dummy value. */</span>
00614             t_dp = -1.0;
00615           }
00616 
00617           <span class="comment">/* Initialize cumulative time variable. */</span>
00618           t_d = 0.0;
00619 
00620           <span class="comment">/* Initialize time measurement. */</span>
00621           t = <a class="code" href="group__nfftutil.html#ga0">nfft_second</a>();
00622 
00623           <span class="comment">/* Cycle through all runs. */</span>
00624           <span class="keywordflow">for</span> (i = 0; i &lt; ld[ild][4]; i++)
00625           {
00626             <span class="comment">/* Switch by the kernel type. */</span>
00627             <span class="keywordflow">switch</span> (kt)
00628             {
00629               <span class="keywordflow">case</span> <a class="code" href="group__applications__fastsumS2__test.html#ga8">KT_ABEL_POISSON</a>:
00630 
00631                 <span class="comment">/* Process all target nodes. */</span>
00632                 <span class="keywordflow">for</span> (d = 0; d &lt; ld[ild][1]; d++)
00633                 {
00634                   <span class="comment">/* Initialize function value. */</span>
00635                   f[d] = 0.0;
00636 
00637                   <span class="comment">/* Process all source nodes. */</span>
00638                   <span class="keywordflow">for</span> (l = 0; l &lt; ld[ild][0]; l++)
00639                   {
00640                     <span class="comment">/* Compute the inner product for the current source and</span>
00641 <span class="comment">                     * target nodes. */</span>
00642                     temp = <a class="code" href="group__applications__fastsumS2__test.html#ga0">innerProduct</a>(2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*eta[2*l],2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*eta[2*l+1],
00643                       2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*d],2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*d+1]);
00644 
00645                     <span class="comment">/* Evaluate the Poisson kernel for the current value and add</span>
00646 <span class="comment">                     * to the result. */</span>
00647                     f[d] += b[l]*<a class="code" href="group__applications__fastsumS2__test.html#ga1">poissonKernel</a>(temp,p[ip][0]);
00648                   }
00649                 }
00650                 <span class="keywordflow">break</span>;
00651 
00652               <span class="keywordflow">case</span> <a class="code" href="group__applications__fastsumS2__test.html#ga9">KT_SINGULARITY</a>:
00653                 <span class="comment">/* Process all target nodes. */</span>
00654                 <span class="keywordflow">for</span> (d = 0; d &lt; ld[ild][1]; d++)
00655                 {
00656                   <span class="comment">/* Initialize function value. */</span>
00657                   f[d] = 0.0;
00658 
00659                   <span class="comment">/* Process all source nodes. */</span>
00660                   <span class="keywordflow">for</span> (l = 0; l &lt; ld[ild][0]; l++)
00661                   {
00662                     <span class="comment">/* Compute the inner product for the current source and</span>
00663 <span class="comment">                     * target nodes. */</span>
00664                     temp = <a class="code" href="group__applications__fastsumS2__test.html#ga0">innerProduct</a>(2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*eta[2*l],2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*eta[2*l+1],
00665                       2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*d],2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*d+1]);
00666 
00667                     <span class="comment">/* Evaluate the Poisson kernel for the current value and add</span>
00668 <span class="comment">                     * to the result. */</span>
00669                     f[d] += b[l]*<a class="code" href="group__applications__fastsumS2__test.html#ga2">singularityKernel</a>(temp,p[ip][0]);
00670                   }
00671                 }
00672                 <span class="keywordflow">break</span>;
00673 
00674               <span class="keywordflow">case</span> <a class="code" href="group__applications__fastsumS2__test.html#ga10">KT_LOC_SUPP</a>:
00675                 <span class="comment">/* Calculate the multiplicative constant. */</span>
00676                 constant = ((p[ip][1]+1)/(2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*pow(1-p[ip][0],p[ip][1]+1)));
00677 
00678                 <span class="comment">/* Process all target nodes. */</span>
00679                 <span class="keywordflow">for</span> (d = 0; d &lt; ld[ild][1]; d++)
00680                 {
00681                   <span class="comment">/* Initialize function value. */</span>
00682                   f[d] = 0.0;
00683 
00684                   <span class="comment">/* Process all source nodes. */</span>
00685                   <span class="keywordflow">for</span> (l = 0; l &lt; ld[ild][0]; l++)
00686                   {
00687                     <span class="comment">/* Compute the inner product for the current source and</span>
00688 <span class="comment">                     * target nodes. */</span>
00689                     temp = <a class="code" href="group__applications__fastsumS2__test.html#ga0">innerProduct</a>(2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*eta[2*l],2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*eta[2*l+1],
00690                       2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*d],2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*d+1]);
00691 
00692                     <span class="comment">/* Evaluate the Poisson kernel for the current value and add</span>
00693 <span class="comment">                     * to the result. */</span>
00694                     f[d] += b[l]*<a class="code" href="group__applications__fastsumS2__test.html#ga3">locallySupportedKernel</a>(temp,p[ip][0],p[ip][1]);
00695                   }
00696 
00697                   <span class="comment">/* Multiply result with constant. */</span>
00698                   f[d] *= constant;
00699                 }
00700                 <span class="keywordflow">break</span>;
00701 
00702                 <span class="keywordflow">case</span> <a class="code" href="group__applications__fastsumS2__test.html#ga11">KT_GAUSSIAN</a>:
00703                   <span class="comment">/* Process all target nodes. */</span>
00704                   <span class="keywordflow">for</span> (d = 0; d &lt; ld[ild][1]; d++)
00705                   {
00706                     <span class="comment">/* Initialize function value. */</span>
00707                     f[d] = 0.0;
00708 
00709                     <span class="comment">/* Process all source nodes. */</span>
00710                     <span class="keywordflow">for</span> (l = 0; l &lt; ld[ild][0]; l++)
00711                     {
00712                       <span class="comment">/* Compute the inner product for the current source and</span>
00713 <span class="comment">                       * target nodes. */</span>
00714                       temp = <a class="code" href="group__applications__fastsumS2__test.html#ga0">innerProduct</a>(2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*eta[2*l],2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*eta[2*l+1],
00715                         2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*d],2*<a class="code" href="group__nfftutil.html#ga57">PI</a>*xi[2*d+1]);
00716                       <span class="comment">/* Evaluate the Poisson kernel for the current value and add</span>
00717 <span class="comment">                       * to the result. */</span>
00718                       f[d] += b[l]*<a class="code" href="group__applications__fastsumS2__test.html#ga4">gaussianKernel</a>(temp,p[ip][0]);
00719                     }
00720                   }
00721                   <span class="keywordflow">break</span>;
00722             }
00723           }
00724 
00725           <span class="comment">/* Calculate and add the time needed. */</span>
00726           t_d = <a class="code" href="group__nfftutil.html#ga0">nfft_second</a>() - t;
00727           <span class="comment">/* Calculate average time needed. */</span>
00728           t_d = t_d/((double)ld[ild][4]);
00729         }
00730         <span class="keywordflow">else</span>
00731         {
00732           <span class="comment">/* Initialize cumulative time variable with dummy value. */</span>
00733           t_d = -1.0;
00734           t_dp = -1.0;
00735         }
00736 
00737         <span class="comment">/* Initialize error and cumulative time variables for the fast</span>
00738 <span class="comment">         * algorithm. */</span>
00739         err_fd = -1.0;
00740         err_f = -1.0;
00741         t_fd = -1.0;
00742         t_f = -1.0;
00743 
00744         <span class="comment">/* Process all cut-off bandwidths. */</span>
00745         <span class="keywordflow">for</span> (im = 0; im &lt; im_max; im++)
00746         {
00747           <span class="comment">/* Init transform plans. */</span>
00748           <a class="code" href="group__nfsft.html#ga3">nfsft_init_guru</a>(&amp;plan_adjoint, m[im],ld[ild][0],
00749             ((use_nfft!=0)?(0U):(<a class="code" href="group__nfsft.html#ga26">NFSFT_USE_NDFT</a>)) |
00750             ((use_fpt!=0)?(0U):(<a class="code" href="group__nfsft.html#ga27">NFSFT_USE_DPT</a>)),
00751             <a class="code" href="group__nfft.html#ga16">PRE_PHI_HUT</a> | <a class="code" href="group__nfft.html#ga20">PRE_PSI</a> | <a class="code" href="group__nfft.html#ga26">FFTW_INIT</a> |
00752             <a class="code" href="group__nfft.html#ga25">FFT_OUT_OF_PLACE</a>, cutoff);
00753           <a class="code" href="group__nfsft.html#ga3">nfsft_init_guru</a>(&amp;plan,m[im],ld[ild][1],
00754             ((use_nfft!=0)?(0U):(<a class="code" href="group__nfsft.html#ga26">NFSFT_USE_NDFT</a>)) |
00755             ((use_fpt!=0)?(0U):(<a class="code" href="group__nfsft.html#ga27">NFSFT_USE_DPT</a>)),
00756             <a class="code" href="group__nfft.html#ga16">PRE_PHI_HUT</a> | <a class="code" href="group__nfft.html#ga20">PRE_PSI</a> | <a class="code" href="group__nfft.html#ga26">FFTW_INIT</a> |
00757             <a class="code" href="group__nfft.html#ga25">FFT_OUT_OF_PLACE</a>,
00758              cutoff);
00759           plan_adjoint.<a class="code" href="structnfsft__plan.html#o2">f_hat</a> = f_hat;
00760           plan_adjoint.<a class="code" href="structnfsft__plan.html#o5">x</a> = eta;
00761           plan_adjoint.<a class="code" href="structnfsft__plan.html#o3">f</a> = b;
00762           plan.<a class="code" href="structnfsft__plan.html#o2">f_hat</a> = f_hat;
00763           plan.<a class="code" href="structnfsft__plan.html#o5">x</a> = xi;
00764           plan.<a class="code" href="structnfsft__plan.html#o3">f</a> = f_m;
00765           nfsft_precompute_x(&amp;plan_adjoint);
00766           nfsft_precompute_x(&amp;plan);
00767 
00768           <span class="comment">/* Check if direct algorithm shall also be tested. */</span>
00769           <span class="keywordflow">if</span> (use_nfsft == BOTH)
00770           {
00771             <span class="comment">/* Initialize cumulative time variable. */</span>
00772             t_fd = 0.0;
00773 
00774             <span class="comment">/* Initialize time measurement. */</span>
00775             t = <a class="code" href="group__nfftutil.html#ga0">nfft_second</a>();
00776 
00777             <span class="comment">/* Cycle through all runs. */</span>
00778             <span class="keywordflow">for</span> (i = 0; i &lt; ld[ild][4]; i++)
00779             {
00780 
00781               <span class="comment">/* Execute adjoint direct NDSFT transformation. */</span>
00782               <a class="code" href="group__nfsft.html#ga7">ndsft_adjoint</a>(&amp;plan_adjoint);
00783 
00784               <span class="comment">/* Multiplication with the Fourier-Legendre coefficients. */</span>
00785               <span class="keywordflow">for</span> (k = 0; k &lt;= m[im]; k++)
00786               {
00787                 <span class="keywordflow">for</span> (n = -k; n &lt;= k; n++)
00788                 {
00789                   f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(k,n,&amp;plan_adjoint)] *= a[k];
00790                 }
00791               }
00792 
00793               <span class="comment">/* Execute direct NDSFT transformation. */</span>
00794               <a class="code" href="group__nfsft.html#ga6">ndsft_trafo</a>(&amp;plan);
00795 
00796             }
00797 
00798             <span class="comment">/* Calculate and add the time needed. */</span>
00799             t_fd = <a class="code" href="group__nfftutil.html#ga0">nfft_second</a>() - t;
00800 
00801             <span class="comment">/* Calculate average time needed. */</span>
00802             t_fd = t_fd/((double)ld[ild][4]);
00803 
00804             <span class="comment">/* Check if error E_infty should be computed. */</span>
00805             <span class="keywordflow">if</span> (ld[ild][2] != NO)
00806             {
00807               <span class="comment">/* Compute the error E_infinity. */</span>
00808               err_fd = <a class="code" href="group__nfftutil.html#ga39">nfft_error_l_infty_1_complex</a>(f, f_m, ld[ild][1], b,
00809                 ld[ild][0]);
00810             }
00811           }
00812 
00813           <span class="comment">/* Check if the fast NFSFT algorithm shall also be tested. */</span>
00814           <span class="keywordflow">if</span> (use_nfsft != NO)
00815           {
00816             <span class="comment">/* Initialize cumulative time variable for the NFSFT algorithm. */</span>
00817             t_f = 0.0;
00818           }
00819           <span class="keywordflow">else</span>
00820           {
00821             <span class="comment">/* Initialize cumulative time variable for the direct NDSFT</span>
00822 <span class="comment">             * algorithm. */</span>
00823             t_fd = 0.0;
00824           }
00825 
00826           <span class="comment">/* Initialize time measurement. */</span>
00827           t = <a class="code" href="group__nfftutil.html#ga0">nfft_second</a>();
00828 
00829           <span class="comment">/* Cycle through all runs. */</span>
00830           <span class="keywordflow">for</span> (i = 0; i &lt; ld[ild][4]; i++)
00831           {
00832             <span class="comment">/* Check if the fast NFSFT algorithm shall also be tested. */</span>
00833             <span class="keywordflow">if</span> (use_nfsft != NO)
00834             {
00835               <span class="comment">/* Execute the adjoint NFSFT transformation. */</span>
00836               <a class="code" href="group__nfsft.html#ga9">nfsft_adjoint</a>(&amp;plan_adjoint);
00837             }
00838             <span class="keywordflow">else</span>
00839             {
00840               <span class="comment">/* Execute the adjoint direct NDSFT transformation. */</span>
00841               <a class="code" href="group__nfsft.html#ga7">ndsft_adjoint</a>(&amp;plan_adjoint);
00842             }
00843 
00844             <span class="comment">/* Multiplication with the Fourier-Legendre coefficients. */</span>
00845             <span class="keywordflow">for</span> (k = 0; k &lt;= m[im]; k++)
00846             {
00847               <span class="keywordflow">for</span> (n = -k; n &lt;= k; n++)
00848               {
00849                 f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(k,n,&amp;plan_adjoint)] *= a[k];
00850                }
00851              }
00852 
00853             <span class="comment">/* Check if the fast NFSFT algorithm shall also be tested. */</span>
00854             <span class="keywordflow">if</span> (use_nfsft != NO)
00855             {
00856               <span class="comment">/* Execute the NFSFT transformation. */</span>
00857               <a class="code" href="group__nfsft.html#ga8">nfsft_trafo</a>(&amp;plan);
00858             }
00859             <span class="keywordflow">else</span>
00860             {
00861               <span class="comment">/* Execute the NDSFT transformation. */</span>
00862               <a class="code" href="group__nfsft.html#ga6">ndsft_trafo</a>(&amp;plan);
00863             }
00864 
00865             <span class="comment">/*for (d = 0; d &lt; ld[ild][1]; d++)</span>
00866 <span class="comment">            {</span>
00867 <span class="comment">              fprintf(stderr,"f_ref[%d] = %le + I*%le, f[%d] = %le + I*%le\n",</span>
00868 <span class="comment">                d,creal(f[d]),cimag(f[d]),d,creal(f_m[d]),cimag(f_m[d]));</span>
00869 <span class="comment">            }*/</span>
00870           }
00871 
00872           <span class="comment">/* Check if the fast NFSFT algorithm has been used. */</span>
00873           <span class="keywordflow">if</span> (use_nfsft != NO)
00874           {
00875             <span class="comment">/* Calculate and add the time needed. */</span>
00876             t_f = <a class="code" href="group__nfftutil.html#ga0">nfft_second</a>() - t;
00877           }
00878           <span class="keywordflow">else</span>
00879           {
00880             <span class="comment">/* Calculate and add the time needed. */</span>
00881             t_fd = <a class="code" href="group__nfftutil.html#ga0">nfft_second</a>() - t;
00882           }
00883 
00884           <span class="comment">/* Check if the fast NFSFT algorithm has been used. */</span>
00885           <span class="keywordflow">if</span> (use_nfsft != NO)
00886           {
00887             <span class="comment">/* Calculate average time needed. */</span>
00888             t_f = t_f/((double)ld[ild][4]);
00889           }
00890           <span class="keywordflow">else</span>
00891           {
00892             <span class="comment">/* Calculate average time needed. */</span>
00893             t_fd = t_fd/((double)ld[ild][4]);
00894           }
00895 
00896           <span class="comment">/* Check if error E_infty should be computed. */</span>
00897           <span class="keywordflow">if</span> (ld[ild][2] != NO)
00898           {
00899             <span class="comment">/* Check if the fast NFSFT algorithm has been used. */</span>
00900             <span class="keywordflow">if</span> (use_nfsft != NO)
00901             {
00902               <span class="comment">/* Compute the error E_infinity. */</span>
00903               err_f = <a class="code" href="group__nfftutil.html#ga39">nfft_error_l_infty_1_complex</a>(f, f_m, ld[ild][1], b,
00904                 ld[ild][0]);
00905             }
00906             <span class="keywordflow">else</span>
00907             {
00908               <span class="comment">/* Compute the error E_infinity. */</span>
00909               err_fd = <a class="code" href="group__nfftutil.html#ga39">nfft_error_l_infty_1_complex</a>(f, f_m, ld[ild][1], b,
00910                 ld[ild][0]);
00911             }
00912           }
00913 
00914           <span class="comment">/* Print out the error measurements. */</span>
00915           fprintf(stdout,<span class="stringliteral">"%e\n%e\n%e\n%e\n%e\n%e\n\n"</span>,t_d,t_dp,t_fd,t_f,err_fd,
00916             err_f);
00917           <span class="comment">/*fprintf(stderr,"%d: %e\t%e\t%e\t%e\t%e\t%e\n",m[im],t_d,t_dp,t_fd,t_f,</span>
00918 <span class="comment">            err_fd,err_f);*/</span>
00919 
00920           <span class="comment">/* Finalize the NFSFT plans */</span>
00921           <a class="code" href="group__nfsft.html#ga10">nfsft_finalize</a>(&amp;plan_adjoint);
00922           <a class="code" href="group__nfsft.html#ga10">nfsft_finalize</a>(&amp;plan);
00923         } <span class="comment">/* for (im = 0; im &lt; im_max; im++) - Process all cut-off</span>
00924 <span class="comment">           * bandwidths.*/</span>
00925       } <span class="comment">/* for (ild = 0; ild &lt; ild_max; ild++) - Process all node sets. */</span>
00926     } <span class="comment">/* for (ip = 0; ip &lt; ip_max; ip++) - Process all parameter sets. */</span>
00927 
00928     <span class="comment">/* Delete precomputed data. */</span>
00929     <a class="code" href="group__nfsft.html#ga5">nfsft_forget</a>();
00930 
00931     <span class="comment">/* Check if memory for precomputed data of the matrix K has been</span>
00932 <span class="comment">     * allocated. */</span>
00933     <span class="keywordflow">if</span> (precompute == YES)
00934     {
00935       <span class="comment">/* Free memory for precomputed matrix K. */</span>
00936       free(prec);
00937     }
00938     <span class="comment">/* Free data arrays. */</span>
00939     free(f);
00940     free(f_m);
00941     free(xi);
00942     free(eta);
00943     free(a);
00944     free(f_hat);
00945     free(b);
00946 
00947     <span class="comment">/* Free memory for node sets. */</span>
00948     <span class="keywordflow">for</span> (ild = 0; ild &lt; ild_max; ild++)
00949     {
00950       free(ld[ild]);
00951     }
00952     free(ld);
00953 
00954     <span class="comment">/* Free memory for cut-off bandwidths. */</span>
00955     free(m);
00956 
00957     <span class="comment">/* Free memory for parameter sets. */</span>
00958     <span class="keywordflow">for</span> (ip = 0; ip &lt; ip_max; ip++)
00959     {
00960       free(p[ip]);
00961     }
00962     free(p);
00963   } <span class="comment">/* for (tc = 0; tc &lt; tc_max; tc++) - Process each testcase. */</span>
00964 
00965   <span class="comment">/* Return exit code for successful run. */</span>
00966   <span class="keywordflow">return</span> EXIT_SUCCESS;
00967 }
00968 <span class="comment">/* \} */</span>
</pre></div>    <hr size="1"/>
    Generated on 5 Feb 2007 by Doxygen 1.4.1
  </body>
</html>
