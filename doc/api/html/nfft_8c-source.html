<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
    <title>
      NFFT 3.1.3 API Reference - NFFT: nfft.c Source File
    </title>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <table>
      <tr>
        <td valign="top">
          <img src="images/logo.png" alt="NFFT Logo">
        </td>
        <td align="left" valign="bottom" width="100%">
          <H1nc>3.1.3 API Reference</H1nc>
        </td>
      </tr>
    </table>  
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>nfft.c</h1><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment"> * Copyright (c) 2002, 2009 Jens Keiner, Stefan Kunis, Daniel Potts</span>
<a name="l00003"></a>00003 <span class="comment"> *</span>
<a name="l00004"></a>00004 <span class="comment"> * This program is free software; you can redistribute it and/or modify it under</span>
<a name="l00005"></a>00005 <span class="comment"> * the terms of the GNU General Public License as published by the Free Software</span>
<a name="l00006"></a>00006 <span class="comment"> * Foundation; either version 2 of the License, or (at your option) any later</span>
<a name="l00007"></a>00007 <span class="comment"> * version.</span>
<a name="l00008"></a>00008 <span class="comment"> *</span>
<a name="l00009"></a>00009 <span class="comment"> * This program is distributed in the hope that it will be useful, but WITHOUT</span>
<a name="l00010"></a>00010 <span class="comment"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS</span>
<a name="l00011"></a>00011 <span class="comment"> * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more</span>
<a name="l00012"></a>00012 <span class="comment"> * details.</span>
<a name="l00013"></a>00013 <span class="comment"> *</span>
<a name="l00014"></a>00014 <span class="comment"> * You should have received a copy of the GNU General Public License along with</span>
<a name="l00015"></a>00015 <span class="comment"> * this program; if not, write to the Free Software Foundation, Inc., 51</span>
<a name="l00016"></a>00016 <span class="comment"> * Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</span>
<a name="l00017"></a>00017 <span class="comment"> */</span>
<a name="l00018"></a>00018 
<a name="l00019"></a>00019 <span class="comment">/* $Id: nfft.c 3331 2009-09-14 12:54:59Z keiner $ */</span>
<a name="l00020"></a>00020 
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;math.h&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;complex.h&gt;</span>
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="preprocessor">#include "<a class="code" href="nfft3util_8h.html" title="Header file for utility functions used by the nfft3 library.">nfft3util.h</a>"</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include "<a class="code" href="nfft3_8h.html" title="Header file for the nfft3 library.">nfft3.h</a>"</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include "infft.h"</span>
<a name="l00036"></a>00036 
<a name="l00059"></a>00059 <span class="preprocessor">#define MACRO_ndft_init_result_trafo \</span>
<a name="l00060"></a>00060 <span class="preprocessor">  memset(f,0,ths-&gt;M_total*sizeof(double _Complex));</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#define MACRO_ndft_init_result_conjugated MACRO_ndft_init_result_trafo</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#define MACRO_ndft_init_result_adjoint \</span>
<a name="l00063"></a>00063 <span class="preprocessor">  memset(f_hat,0,ths-&gt;N_total*sizeof(double _Complex));</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#define MACRO_ndft_init_result_transposed MACRO_ndft_init_result_adjoint</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span>
<a name="l00066"></a>00066 <span class="preprocessor">#define MACRO_ndft_sign_trafo K2PI*ths-&gt;x[j*ths-&gt;d+t]</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="preprocessor">#define MACRO_ndft_sign_conjugated -K2PI*ths-&gt;x[j*ths-&gt;d+t]</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#define MACRO_ndft_sign_adjoint K2PI*ths-&gt;x[j*ths-&gt;d+t]</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#define MACRO_ndft_sign_transposed -K2PI*ths-&gt;x[j*ths-&gt;d+t]</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span>
<a name="l00071"></a>00071 <span class="preprocessor">#define MACRO_init_k_N_Omega_x(which_one) \</span>
<a name="l00072"></a>00072 <span class="preprocessor">{                                                                             \</span>
<a name="l00073"></a>00073 <span class="preprocessor">  for(t = 0; t &lt; ths-&gt;d; t++)                                                 \</span>
<a name="l00074"></a>00074 <span class="preprocessor">  {                                                                           \</span>
<a name="l00075"></a>00075 <span class="preprocessor">    k[t] = -ths-&gt;N[t]/2;                                                      \</span>
<a name="l00076"></a>00076 <span class="preprocessor">    x[t] = MACRO_ndft_sign_ ## which_one;                                     \</span>
<a name="l00077"></a>00077 <span class="preprocessor">    Omega[t+1] = k[t]*x[t]+Omega[t];                                          \</span>
<a name="l00078"></a>00078 <span class="preprocessor">  }                                                                           \</span>
<a name="l00079"></a>00079 <span class="preprocessor">  omega=Omega[ths-&gt;d];                                                        \</span>
<a name="l00080"></a>00080 <span class="preprocessor">}                                                                             \</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>
<a name="l00082"></a>00082 <span class="preprocessor"></span><span class="preprocessor">#define MACRO_count_k_N_Omega \</span>
<a name="l00083"></a>00083 <span class="preprocessor">{                                                                             \</span>
<a name="l00084"></a>00084 <span class="preprocessor">  for(t = ths-&gt;d-1; (t &gt;= 1) &amp;&amp; (k[t] == ths-&gt;N[t]/2-1); t--)                 \</span>
<a name="l00085"></a>00085 <span class="preprocessor">    k[t]-= ths-&gt;N[t]-1;                                                       \</span>
<a name="l00086"></a>00086 <span class="preprocessor">                                                                              \</span>
<a name="l00087"></a>00087 <span class="preprocessor">  k[t]++;                                                                     \</span>
<a name="l00088"></a>00088 <span class="preprocessor">                                                                              \</span>
<a name="l00089"></a>00089 <span class="preprocessor">  for(t2 = t; t2 &lt; ths-&gt;d; t2++)                                              \</span>
<a name="l00090"></a>00090 <span class="preprocessor">    Omega[t2+1] = k[t2]*x[t2]+Omega[t2];                                      \</span>
<a name="l00091"></a>00091 <span class="preprocessor">                                                                              \</span>
<a name="l00092"></a>00092 <span class="preprocessor">  omega = Omega[ths-&gt;d];                                                      \</span>
<a name="l00093"></a>00093 <span class="preprocessor">}</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span>
<a name="l00095"></a>00095 <span class="preprocessor">#define MACRO_ndft_compute_trafo f[j] += f_hat[k_L]*cexp(-_Complex_I*omega);</span>
<a name="l00096"></a>00096 <span class="preprocessor"></span>
<a name="l00097"></a>00097 <span class="preprocessor">#define MACRO_ndft_compute_conjugated MACRO_ndft_compute_trafo</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span>
<a name="l00099"></a>00099 <span class="preprocessor">#define MACRO_ndft_compute_adjoint f_hat[k_L] += f[j]*cexp(+ _Complex_I*omega);</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>
<a name="l00101"></a>00101 <span class="preprocessor">#define MACRO_ndft_compute_transposed MACRO_ndft_compute_adjoint</span>
<a name="l00102"></a>00102 <span class="preprocessor"></span>
<a name="l00103"></a>00103 <span class="preprocessor">#if defined(HAVE_LIBDISPATCH)</span>
<a name="l00104"></a>00104 <span class="preprocessor"></span><span class="preprocessor">#define FOR(VAR,VAL) \</span>
<a name="l00105"></a>00105 <span class="preprocessor">  dispatch_apply(VAL, dispatch_get_global_queue(0, 0), ^(size_t VAR)</span>
<a name="l00106"></a>00106 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00107"></a>00107 <span class="preprocessor"></span><span class="preprocessor">#define FOR(VAR,VAL) \</span>
<a name="l00108"></a>00108 <span class="preprocessor">  int VAR; \</span>
<a name="l00109"></a>00109 <span class="preprocessor">  for (VAR = 0; VAR &lt; VAL; VAR++)</span>
<a name="l00110"></a>00110 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span>
<a name="l00112"></a>00112 <span class="preprocessor">#if defined(HAVE_LIBDISPATCH)</span>
<a name="l00113"></a>00113 <span class="preprocessor"></span><span class="preprocessor">#define END_FOR );</span>
<a name="l00114"></a>00114 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00115"></a>00115 <span class="preprocessor"></span><span class="preprocessor">#define END_FOR</span>
<a name="l00116"></a>00116 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00117"></a>00117 <span class="preprocessor"></span>
<a name="l00118"></a>00118 <span class="preprocessor">#define MACRO_ndft(which_one)                                                 \</span>
<a name="l00119"></a>00119 <span class="preprocessor">void ndft_ ## which_one (nfft_plan *ths)                                      \</span>
<a name="l00120"></a>00120 <span class="preprocessor">{                                                                             \</span>
<a name="l00121"></a>00121 <span class="preprocessor">  C *f_hat = ths-&gt;f_hat, *f = ths-&gt;f;                                         \</span>
<a name="l00122"></a>00122 <span class="preprocessor">                                                                              \</span>
<a name="l00123"></a>00123 <span class="preprocessor">  MACRO_ndft_init_result_ ## which_one                                        \</span>
<a name="l00124"></a>00124 <span class="preprocessor">                                                                              \</span>
<a name="l00125"></a>00125 <span class="preprocessor">  if(ths-&gt;d == 1) </span><span class="comment">/* treat univariate case extra, for performance */</span>          \
<a name="l00126"></a>00126   {                                                                           \
<a name="l00127"></a>00127     const int t = 0;                                                          \
<a name="l00128"></a>00128     FOR(j,ths-&gt;M_total)                                                       \
<a name="l00129"></a>00129     {                                                                         \
<a name="l00130"></a>00130       int k_L;                                                                \
<a name="l00131"></a>00131       for(k_L = 0; k_L &lt; ths-&gt;N_total; k_L++)                                 \
<a name="l00132"></a>00132       {                                                                       \
<a name="l00133"></a>00133         R omega = (k_L - ths-&gt;N_total/2) * MACRO_ndft_sign_ ## which_one;     \
<a name="l00134"></a>00134         MACRO_ndft_compute_ ## which_one;                                     \
<a name="l00135"></a>00135       }                                                                       \
<a name="l00136"></a>00136     }                                                                         \
<a name="l00137"></a>00137     END_FOR                                                                   \
<a name="l00138"></a>00138   }                                                                           \
<a name="l00139"></a>00139   else <span class="comment">/* multivariate case */</span>                                                \
<a name="l00140"></a>00140   {                                                                           \
<a name="l00141"></a>00141     double _Complex *f_hat_k;                                                 \
<a name="l00142"></a>00142     FOR(j,ths-&gt;M_total)                                                       \
<a name="l00143"></a>00143     {                                                                         \
<a name="l00144"></a>00144       int t, t2, k_L;                                                         \
<a name="l00145"></a>00145       double x[ths-&gt;d];                                                       \
<a name="l00146"></a>00146       int k[ths-&gt;d];                                                          \
<a name="l00147"></a>00147       double omega, Omega[ths-&gt;d+1];                                          \
<a name="l00148"></a>00148       Omega[0] = K(0.0);                                                      \
<a name="l00149"></a>00149       MACRO_init_k_N_Omega_x(which_one);                                      \
<a name="l00150"></a>00150       for(k_L = 0; k_L &lt; ths-&gt;N_total; k_L++)                                 \
<a name="l00151"></a>00151       {                                                                       \
<a name="l00152"></a>00152         MACRO_ndft_compute_ ## which_one;                                     \
<a name="l00153"></a>00153         MACRO_count_k_N_Omega;                                                \
<a name="l00154"></a>00154       } <span class="comment">/* for(k_L) */</span>                                                        \
<a name="l00155"></a>00155     }                                                                         \
<a name="l00156"></a>00156     END_FOR                                                                   \
<a name="l00157"></a>00157   } <span class="comment">/* else */</span>                                                                \
<a name="l00158"></a>00158 } <span class="comment">/* ndft_trafo */</span>
<a name="l00159"></a>00159 
<a name="l00160"></a>00160 
<a name="l00163"></a><a class="code" href="group__nfft.html#g27ef1bcb8dd3a3fc1cdbeee368ec1acf">00163</a> MACRO_ndft(trafo)
<a name="l00164"></a><a class="code" href="group__nfft.html#g03975608fdf8cfd8757f1f52b43ec51b">00164</a> MACRO_ndft(adjoint)
<a name="l00165"></a>00165 
<a name="l00191"></a>00191 static <span class="keywordtype">void</span> nfft_uo(const <a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths,const <span class="keywordtype">int</span> j,<span class="keywordtype">int</span> *up,<span class="keywordtype">int</span> *op,const <span class="keywordtype">int</span> act_dim)
<a name="l00192"></a>00192 {
<a name="l00193"></a>00193   <span class="keywordtype">double</span> xj=ths-&gt;x[j*ths-&gt;d+act_dim];
<a name="l00194"></a>00194   <span class="keywordtype">int</span> c = LRINT(xj * ths-&gt;n[act_dim]);
<a name="l00195"></a>00195 
<a name="l00196"></a>00196   <span class="keywordflow">if</span>(xj &lt; 0)
<a name="l00197"></a>00197     {
<a name="l00198"></a>00198       (*up) = c-1-(ths-&gt;m);
<a name="l00199"></a>00199       (*op) = c  +(ths-&gt;m);
<a name="l00200"></a>00200     }
<a name="l00201"></a>00201   <span class="keywordflow">else</span>
<a name="l00202"></a>00202     {
<a name="l00203"></a>00203       (*up) = c  -(ths-&gt;m);
<a name="l00204"></a>00204       (*op) = c+1+(ths-&gt;m);
<a name="l00205"></a>00205     }
<a name="l00206"></a>00206 }
<a name="l00207"></a>00207 
<a name="l00208"></a>00208 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_uo2(<span class="keywordtype">int</span> *u, <span class="keywordtype">int</span> *o, <span class="keyword">const</span> <span class="keywordtype">double</span> x, <span class="keyword">const</span> <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">int</span> m)
<a name="l00209"></a>00209 {
<a name="l00210"></a>00210   <span class="keywordtype">int</span> c = LRINT(x * n);
<a name="l00211"></a>00211 
<a name="l00212"></a>00212   <span class="keywordflow">if</span>(x &lt; 0)
<a name="l00213"></a>00213     {
<a name="l00214"></a>00214       *u=(c-1-m+n)%n;
<a name="l00215"></a>00215       *o=(c+  m+n)%n;
<a name="l00216"></a>00216     }
<a name="l00217"></a>00217   <span class="keywordflow">else</span>
<a name="l00218"></a>00218     {
<a name="l00219"></a>00219       *u=(c  -m+n)%n;
<a name="l00220"></a>00220       *o=(c+1+m+n)%n;
<a name="l00221"></a>00221     }
<a name="l00222"></a>00222 }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224 
<a name="l00225"></a>00225 <span class="preprocessor">#define MACRO_nfft_D_compute_A {                                              \</span>
<a name="l00226"></a>00226 <span class="preprocessor"> g_hat[k_plain[ths-&gt;d]] = f_hat[ks_plain[ths-&gt;d]] * c_phi_inv_k[ths-&gt;d];      \</span>
<a name="l00227"></a>00227 <span class="preprocessor">}</span>
<a name="l00228"></a>00228 <span class="preprocessor"></span>
<a name="l00229"></a>00229 <span class="preprocessor">#define MACRO_nfft_D_compute_T {                                              \</span>
<a name="l00230"></a>00230 <span class="preprocessor"> f_hat[ks_plain[ths-&gt;d]] = g_hat[k_plain[ths-&gt;d]] * c_phi_inv_k[ths-&gt;d];      \</span>
<a name="l00231"></a>00231 <span class="preprocessor">}</span>
<a name="l00232"></a>00232 <span class="preprocessor"></span>
<a name="l00233"></a>00233 <span class="preprocessor">#define MACRO_nfft_D_init_result_A  memset(g_hat,0,ths-&gt;n_total*              \</span>
<a name="l00234"></a>00234 <span class="preprocessor">             sizeof(double _Complex));</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span><span class="preprocessor">#define MACRO_nfft_D_init_result_T memset(f_hat,0,ths-&gt;N_total*               \</span>
<a name="l00236"></a>00236 <span class="preprocessor">                                           sizeof(double _Complex));</span>
<a name="l00237"></a>00237 <span class="preprocessor"></span>
<a name="l00238"></a>00238 <span class="preprocessor">#define MACRO_with_PRE_PHI_HUT * ths-&gt;c_phi_inv[t2][ks[t2]];</span>
<a name="l00239"></a>00239 <span class="preprocessor"></span><span class="preprocessor">#define MACRO_without_PRE_PHI_HUT / (PHI_HUT(ks[t2]-ths-&gt;N[t2]/2,t2));</span>
<a name="l00240"></a>00240 <span class="preprocessor"></span>
<a name="l00241"></a>00241 <span class="preprocessor">#define MACRO_init_k_ks {                                                     \</span>
<a name="l00242"></a>00242 <span class="preprocessor">  for(t = ths-&gt;d-1; t&gt;=0; t--)                                                \</span>
<a name="l00243"></a>00243 <span class="preprocessor">    {                                                                         \</span>
<a name="l00244"></a>00244 <span class="preprocessor">      kp[t]= 0;                                                               \</span>
<a name="l00245"></a>00245 <span class="preprocessor">      k[t] = 0;                                                               \</span>
<a name="l00246"></a>00246 <span class="preprocessor">      ks[t] = ths-&gt;N[t]/2;                                                    \</span>
<a name="l00247"></a>00247 <span class="preprocessor">    }                                                                         \</span>
<a name="l00248"></a>00248 <span class="preprocessor">  t++;                                                                        \</span>
<a name="l00249"></a>00249 <span class="preprocessor">}</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span>
<a name="l00251"></a>00251 <span class="preprocessor">#define MACRO_update_c_phi_inv_k(which_one) {                                 \</span>
<a name="l00252"></a>00252 <span class="preprocessor">  for(t2=t; t2&lt;ths-&gt;d; t2++)                                                  \</span>
<a name="l00253"></a>00253 <span class="preprocessor">    {                                                                         \</span>
<a name="l00254"></a>00254 <span class="preprocessor">      c_phi_inv_k[t2+1]= c_phi_inv_k[t2] MACRO_ ##which_one;                  \</span>
<a name="l00255"></a>00255 <span class="preprocessor">      ks_plain[t2+1]= ks_plain[t2]*ths-&gt;N[t2]+ks[t2];                         \</span>
<a name="l00256"></a>00256 <span class="preprocessor">      k_plain[t2+1]= k_plain[t2]*ths-&gt;n[t2]+k[t2];                            \</span>
<a name="l00257"></a>00257 <span class="preprocessor">    }                                                                         \</span>
<a name="l00258"></a>00258 <span class="preprocessor">}</span>
<a name="l00259"></a>00259 <span class="preprocessor"></span>
<a name="l00260"></a>00260 <span class="preprocessor">#define MACRO_count_k_ks {                                                    \</span>
<a name="l00261"></a>00261 <span class="preprocessor">  for(t=ths-&gt;d-1; (t&gt;0)&amp;&amp; (kp[t]==ths-&gt;N[t]-1); t--)                          \</span>
<a name="l00262"></a>00262 <span class="preprocessor">    {                                                                         \</span>
<a name="l00263"></a>00263 <span class="preprocessor">      kp[t]= 0;                                                               \</span>
<a name="l00264"></a>00264 <span class="preprocessor">      k[t]= 0;                                                                \</span>
<a name="l00265"></a>00265 <span class="preprocessor">      ks[t]= ths-&gt;N[t]/2;                                                     \</span>
<a name="l00266"></a>00266 <span class="preprocessor">    }                                                                         \</span>
<a name="l00267"></a>00267 <span class="preprocessor">                                                                              \</span>
<a name="l00268"></a>00268 <span class="preprocessor">  kp[t]++; k[t]++; ks[t]++;                                                   \</span>
<a name="l00269"></a>00269 <span class="preprocessor">  if(kp[t]==ths-&gt;N[t]/2)                                                      \</span>
<a name="l00270"></a>00270 <span class="preprocessor">    {                                                                         \</span>
<a name="l00271"></a>00271 <span class="preprocessor">      k[t]= ths-&gt;n[t]-ths-&gt;N[t]/2;                                            \</span>
<a name="l00272"></a>00272 <span class="preprocessor">      ks[t]= 0;                                                               \</span>
<a name="l00273"></a>00273 <span class="preprocessor">    }                                                                         \</span>
<a name="l00274"></a>00274 <span class="preprocessor">}                                                                             \</span>
<a name="l00275"></a>00275 <span class="preprocessor"></span>
<a name="l00276"></a>00276 <span class="preprocessor"></span>
<a name="l00280"></a>00280 <span class="preprocessor">#define MACRO_nfft_D(which_one)                                               \</span>
<a name="l00281"></a>00281 <span class="preprocessor">static inline void nfft_D_ ## which_one (nfft_plan *ths)                      \</span>
<a name="l00282"></a>00282 <span class="preprocessor">{                                                                             \</span>
<a name="l00283"></a>00283 <span class="preprocessor">  int t, t2;                            \</span>
<a name="l00284"></a>00284 <span class="preprocessor">  int k_L;                              \</span>
<a name="l00285"></a>00285 <span class="preprocessor">  int kp[ths-&gt;d];                       \</span>
<a name="l00286"></a>00286 <span class="preprocessor">  int k[ths-&gt;d];                        \</span>
<a name="l00287"></a>00287 <span class="preprocessor">  int ks[ths-&gt;d];                       \</span>
<a name="l00288"></a>00288 <span class="preprocessor">  double c_phi_inv_k[ths-&gt;d+1];         \</span>
<a name="l00289"></a>00289 <span class="preprocessor">  int k_plain[ths-&gt;d+1];                \</span>
<a name="l00290"></a>00290 <span class="preprocessor">  int ks_plain[ths-&gt;d+1];               \</span>
<a name="l00291"></a>00291 <span class="preprocessor">  double _Complex *f_hat, *g_hat;       \</span>
<a name="l00292"></a>00292 <span class="preprocessor">                                                                              \</span>
<a name="l00293"></a>00293 <span class="preprocessor">  f_hat=ths-&gt;f_hat; g_hat=ths-&gt;g_hat;                                         \</span>
<a name="l00294"></a>00294 <span class="preprocessor">  MACRO_nfft_D_init_result_ ## which_one;                                     \</span>
<a name="l00295"></a>00295 <span class="preprocessor">                                                                              \</span>
<a name="l00296"></a>00296 <span class="preprocessor">  c_phi_inv_k[0]=1;                                                           \</span>
<a name="l00297"></a>00297 <span class="preprocessor">  k_plain[0]=0;                                                               \</span>
<a name="l00298"></a>00298 <span class="preprocessor">  ks_plain[0]=0;                                                              \</span>
<a name="l00299"></a>00299 <span class="preprocessor">                                                                              \</span>
<a name="l00300"></a>00300 <span class="preprocessor">  if(ths-&gt;nfft_flags &amp; PRE_PHI_HUT)                                           \</span>
<a name="l00301"></a>00301 <span class="preprocessor">    {                                                                         \</span>
<a name="l00302"></a>00302 <span class="preprocessor">      MACRO_init_k_ks;                                                        \</span>
<a name="l00303"></a>00303 <span class="preprocessor">                                                                              \</span>
<a name="l00304"></a>00304 <span class="preprocessor">      for(k_L=0; k_L&lt;ths-&gt;N_total; k_L++)                                     \</span>
<a name="l00305"></a>00305 <span class="preprocessor">  {                                                                     \</span>
<a name="l00306"></a>00306 <span class="preprocessor">          MACRO_update_c_phi_inv_k(with_PRE_PHI_HUT);                         \</span>
<a name="l00307"></a>00307 <span class="preprocessor">                                                                              \</span>
<a name="l00308"></a>00308 <span class="preprocessor">    MACRO_nfft_D_compute_ ## which_one;                                 \</span>
<a name="l00309"></a>00309 <span class="preprocessor">                                                                        \</span>
<a name="l00310"></a>00310 <span class="preprocessor">    MACRO_count_k_ks;                                                   \</span>
<a name="l00311"></a>00311 <span class="preprocessor">  } </span><span class="comment">/* for(k_L) */</span>                                                      \
<a name="l00312"></a>00312     } <span class="comment">/* if(PRE_PHI_HUT) */</span>                                                   \
<a name="l00313"></a>00313   else                                                                        \
<a name="l00314"></a>00314     {                                                                         \
<a name="l00315"></a>00315       MACRO_init_k_ks;                                                        \
<a name="l00316"></a>00316                                                                               \
<a name="l00317"></a>00317       for(k_L=0; k_L&lt;ths-&gt;N_total; k_L++)                                     \
<a name="l00318"></a>00318     {                                                                   \
<a name="l00319"></a>00319         MACRO_update_c_phi_inv_k(without_PRE_PHI_HUT);                        \
<a name="l00320"></a>00320                                                                               \
<a name="l00321"></a>00321       MACRO_nfft_D_compute_ ## which_one;                               \
<a name="l00322"></a>00322                                                                         \
<a name="l00323"></a>00323       MACRO_count_k_ks;                                                 \
<a name="l00324"></a>00324     } <span class="comment">/* for(k_L) */</span>                                                    \
<a name="l00325"></a>00325     } <span class="comment">/* else(PRE_PHI_HUT) */</span>                                                 \
<a name="l00326"></a>00326 } <span class="comment">/* nfft_D */</span>
<a name="l00327"></a>00327 
<a name="l00328"></a>00328 MACRO_nfft_D(A)
<a name="l00329"></a>00329 MACRO_nfft_D(T)
<a name="l00330"></a>00330 
<a name="l00334"></a>00334 <span class="preprocessor">#define MACRO_nfft_B_init_result_A  memset(f,0,ths-&gt;M_total*                  \</span>
<a name="l00335"></a>00335 <span class="preprocessor">                                           sizeof(double _Complex));</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span><span class="preprocessor">#define MACRO_nfft_B_init_result_T memset(g,0,ths-&gt;n_total*                   \</span>
<a name="l00337"></a>00337 <span class="preprocessor">                                          sizeof(double _Complex));</span>
<a name="l00338"></a>00338 <span class="preprocessor"></span>
<a name="l00339"></a>00339 <span class="preprocessor">#define MACRO_nfft_B_PRE_FULL_PSI_compute_A {                                 \</span>
<a name="l00340"></a>00340 <span class="preprocessor">  (*fj) += ths-&gt;psi[ix] * g[ths-&gt;psi_index_g[ix]];            \</span>
<a name="l00341"></a>00341 <span class="preprocessor">}</span>
<a name="l00342"></a>00342 <span class="preprocessor"></span>
<a name="l00343"></a>00343 <span class="preprocessor">#define MACRO_nfft_B_PRE_FULL_PSI_compute_T {                                 \</span>
<a name="l00344"></a>00344 <span class="preprocessor">  g[ths-&gt;psi_index_g[ix]] += ths-&gt;psi[ix] * (*fj);                            \</span>
<a name="l00345"></a>00345 <span class="preprocessor">}</span>
<a name="l00346"></a>00346 <span class="preprocessor"></span>
<a name="l00347"></a>00347 <span class="preprocessor">#define MACRO_nfft_B_compute_A {                                              \</span>
<a name="l00348"></a>00348 <span class="preprocessor">  (*fj) += phi_prod[ths-&gt;d] * g[ll_plain[ths-&gt;d]];                            \</span>
<a name="l00349"></a>00349 <span class="preprocessor">}</span>
<a name="l00350"></a>00350 <span class="preprocessor"></span>
<a name="l00351"></a>00351 <span class="preprocessor">#define MACRO_nfft_B_compute_T {                                              \</span>
<a name="l00352"></a>00352 <span class="preprocessor">  g[ll_plain[ths-&gt;d]] += phi_prod[ths-&gt;d] * (*fj);                            \</span>
<a name="l00353"></a>00353 <span class="preprocessor">}</span>
<a name="l00354"></a>00354 <span class="preprocessor"></span>
<a name="l00355"></a>00355 <span class="preprocessor">#define MACRO_with_FG_PSI fg_psi[t2][lj[t2]]</span>
<a name="l00356"></a>00356 <span class="preprocessor"></span>
<a name="l00357"></a>00357 <span class="preprocessor">#define MACRO_with_PRE_PSI     ths-&gt;psi[(j*ths-&gt;d+t2)*(2*ths-&gt;m+2)+lj[t2]]</span>
<a name="l00358"></a>00358 <span class="preprocessor"></span>
<a name="l00359"></a>00359 <span class="preprocessor">#define MACRO_without_PRE_PSI  PHI(ths-&gt;x[j*ths-&gt;d+t2]-                       \</span>
<a name="l00360"></a>00360 <span class="preprocessor">                                   ((double)l[t2])/ths-&gt;n[t2], t2)</span>
<a name="l00361"></a>00361 <span class="preprocessor"></span>
<a name="l00362"></a>00362 <span class="preprocessor">#define MACRO_init_uo_l_lj_t {                                                \</span>
<a name="l00363"></a>00363 <span class="preprocessor">  for(t = ths-&gt;d-1; t&gt;=0; t--)                                                \</span>
<a name="l00364"></a>00364 <span class="preprocessor">    {                                                                         \</span>
<a name="l00365"></a>00365 <span class="preprocessor">      nfft_uo(ths,j,&amp;u[t],&amp;o[t],t);                                           \</span>
<a name="l00366"></a>00366 <span class="preprocessor">      l[t] = u[t];                                                            \</span>
<a name="l00367"></a>00367 <span class="preprocessor">      lj[t] = 0;                                                              \</span>
<a name="l00368"></a>00368 <span class="preprocessor">    } </span><span class="comment">/* for(t) */</span>                                                            \
<a name="l00369"></a>00369   t++;                                                                        \
<a name="l00370"></a>00370 }
<a name="l00371"></a>00371 
<a name="l00372"></a>00372 <span class="preprocessor">#define MACRO_update_phi_prod_ll_plain(which_one) {                           \</span>
<a name="l00373"></a>00373 <span class="preprocessor">  for(t2=t; t2&lt;ths-&gt;d; t2++)                                                  \</span>
<a name="l00374"></a>00374 <span class="preprocessor">    {                                                                         \</span>
<a name="l00375"></a>00375 <span class="preprocessor">      phi_prod[t2+1]=phi_prod[t2]* MACRO_ ## which_one;                       \</span>
<a name="l00376"></a>00376 <span class="preprocessor">      ll_plain[t2+1]=ll_plain[t2]*ths-&gt;n[t2] +(l[t2]+ths-&gt;n[t2])%ths-&gt;n[t2];  \</span>
<a name="l00377"></a>00377 <span class="preprocessor">    } </span><span class="comment">/* for(t2) */</span>                                                           \
<a name="l00378"></a>00378 }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380 <span class="preprocessor">#define MACRO_count_uo_l_lj_t {                                               \</span>
<a name="l00381"></a>00381 <span class="preprocessor">  for(t = ths-&gt;d-1; (t&gt;0)&amp;&amp;(l[t]==o[t]); t--)                                 \</span>
<a name="l00382"></a>00382 <span class="preprocessor">    {                                                                         \</span>
<a name="l00383"></a>00383 <span class="preprocessor">      l[t] = u[t];                                                            \</span>
<a name="l00384"></a>00384 <span class="preprocessor">      lj[t] = 0;                                                              \</span>
<a name="l00385"></a>00385 <span class="preprocessor">    } </span><span class="comment">/* for(t) */</span>                                                            \
<a name="l00386"></a>00386                                                                               \
<a name="l00387"></a>00387   l[t]++;                                                                     \
<a name="l00388"></a>00388   lj[t]++;                                                                    \
<a name="l00389"></a>00389 }
<a name="l00390"></a>00390 
<a name="l00391"></a>00391 <span class="preprocessor">#define MACRO_nfft_B(which_one)                                               \</span>
<a name="l00392"></a>00392 <span class="preprocessor">static inline void nfft_B_ ## which_one (nfft_plan *ths)                      \</span>
<a name="l00393"></a>00393 <span class="preprocessor">{                                                                             \</span>
<a name="l00394"></a>00394 <span class="preprocessor">  int lprod;                            \</span>
<a name="l00395"></a>00395 <span class="preprocessor">  int u[ths-&gt;d], o[ths-&gt;d];             \</span>
<a name="l00396"></a>00396 <span class="preprocessor">  int t, t2;                            \</span>
<a name="l00397"></a>00397 <span class="preprocessor">  int j;                                \</span>
<a name="l00398"></a>00398 <span class="preprocessor">  int l_L, ix;                          \</span>
<a name="l00399"></a>00399 <span class="preprocessor">  int l[ths-&gt;d];                        \</span>
<a name="l00400"></a>00400 <span class="preprocessor">  int lj[ths-&gt;d];                       \</span>
<a name="l00401"></a>00401 <span class="preprocessor">  int ll_plain[ths-&gt;d+1];               \</span>
<a name="l00402"></a>00402 <span class="preprocessor">  double phi_prod[ths-&gt;d+1];            \</span>
<a name="l00403"></a>00403 <span class="preprocessor">  double _Complex *f, *g;               \</span>
<a name="l00404"></a>00404 <span class="preprocessor">  double _Complex *fj;                  \</span>
<a name="l00405"></a>00405 <span class="preprocessor">  double y[ths-&gt;d];                                                           \</span>
<a name="l00406"></a>00406 <span class="preprocessor">  double fg_psi[ths-&gt;d][2*ths-&gt;m+2];                                          \</span>
<a name="l00407"></a>00407 <span class="preprocessor">  double fg_exp_l[ths-&gt;d][2*ths-&gt;m+2];                                        \</span>
<a name="l00408"></a>00408 <span class="preprocessor">  int l_fg,lj_fg;                                                             \</span>
<a name="l00409"></a>00409 <span class="preprocessor">  double tmpEXP1, tmpEXP2, tmpEXP2sq, tmp1, tmp2, tmp3;                       \</span>
<a name="l00410"></a>00410 <span class="preprocessor">  double ip_w;                                                                \</span>
<a name="l00411"></a>00411 <span class="preprocessor">  int ip_u;                                                                   \</span>
<a name="l00412"></a>00412 <span class="preprocessor">  int ip_s=ths-&gt;K/(ths-&gt;m+2);                                                 \</span>
<a name="l00413"></a>00413 <span class="preprocessor">                                                                              \</span>
<a name="l00414"></a>00414 <span class="preprocessor">  f=ths-&gt;f; g=ths-&gt;g;                                                         \</span>
<a name="l00415"></a>00415 <span class="preprocessor">                                                                              \</span>
<a name="l00416"></a>00416 <span class="preprocessor">  MACRO_nfft_B_init_result_ ## which_one;                                     \</span>
<a name="l00417"></a>00417 <span class="preprocessor">                                                                              \</span>
<a name="l00418"></a>00418 <span class="preprocessor">  if(ths-&gt;nfft_flags &amp; PRE_FULL_PSI)                                          \</span>
<a name="l00419"></a>00419 <span class="preprocessor">    {                                                                         \</span>
<a name="l00420"></a>00420 <span class="preprocessor">      for(ix=0, j=0, fj=f; j&lt;ths-&gt;M_total; j++, fj++)                         \</span>
<a name="l00421"></a>00421 <span class="preprocessor">        for(l_L=0; l_L&lt;ths-&gt;psi_index_f[j]; l_L++, ix++)                      \</span>
<a name="l00422"></a>00422 <span class="preprocessor">    MACRO_nfft_B_PRE_FULL_PSI_compute_ ## which_one;                    \</span>
<a name="l00423"></a>00423 <span class="preprocessor">      return;                                                                 \</span>
<a name="l00424"></a>00424 <span class="preprocessor">    }                                                                         \</span>
<a name="l00425"></a>00425 <span class="preprocessor">                                                                              \</span>
<a name="l00426"></a>00426 <span class="preprocessor">  phi_prod[0]=1;                                                              \</span>
<a name="l00427"></a>00427 <span class="preprocessor">  ll_plain[0]=0;                                                              \</span>
<a name="l00428"></a>00428 <span class="preprocessor">                                                                              \</span>
<a name="l00429"></a>00429 <span class="preprocessor">  for(t=0,lprod = 1; t&lt;ths-&gt;d; t++)                                           \</span>
<a name="l00430"></a>00430 <span class="preprocessor">    lprod *= (2*ths-&gt;m+2);                                                    \</span>
<a name="l00431"></a>00431 <span class="preprocessor">                                                                              \</span>
<a name="l00432"></a>00432 <span class="preprocessor">  if(ths-&gt;nfft_flags &amp; PRE_PSI)                                               \</span>
<a name="l00433"></a>00433 <span class="preprocessor">    {                                                                         \</span>
<a name="l00434"></a>00434 <span class="preprocessor">      for(j=0, fj=f; j&lt;ths-&gt;M_total; j++, fj++)                               \</span>
<a name="l00435"></a>00435 <span class="preprocessor">  {                                                                     \</span>
<a name="l00436"></a>00436 <span class="preprocessor">          MACRO_init_uo_l_lj_t;                                               \</span>
<a name="l00437"></a>00437 <span class="preprocessor">                                                                              \</span>
<a name="l00438"></a>00438 <span class="preprocessor">    for(l_L=0; l_L&lt;lprod; l_L++)                                        \</span>
<a name="l00439"></a>00439 <span class="preprocessor">      {                                                                 \</span>
<a name="l00440"></a>00440 <span class="preprocessor">              MACRO_update_phi_prod_ll_plain(with_PRE_PSI);                   \</span>
<a name="l00441"></a>00441 <span class="preprocessor">                                                                              \</span>
<a name="l00442"></a>00442 <span class="preprocessor">        MACRO_nfft_B_compute_ ## which_one;                             \</span>
<a name="l00443"></a>00443 <span class="preprocessor">                                                                  \</span>
<a name="l00444"></a>00444 <span class="preprocessor">        MACRO_count_uo_l_lj_t;                                          \</span>
<a name="l00445"></a>00445 <span class="preprocessor">            } </span><span class="comment">/* for(l_L) */</span>                                                  \
<a name="l00446"></a>00446   } <span class="comment">/* for(j) */</span>                                                        \
<a name="l00447"></a>00447       return;                                                                 \
<a name="l00448"></a>00448     } <span class="comment">/* if(PRE_PSI) */</span>                                                       \
<a name="l00449"></a>00449                                                                               \
<a name="l00450"></a>00450   if(ths-&gt;nfft_flags &amp; PRE_FG_PSI)                                            \
<a name="l00451"></a>00451     {                                                                         \
<a name="l00452"></a>00452       for(t2=0; t2&lt;ths-&gt;d; t2++)                                              \
<a name="l00453"></a>00453         {                                                                     \
<a name="l00454"></a>00454           tmpEXP2 = exp(-1.0/ths-&gt;b[t2]);                                     \
<a name="l00455"></a>00455           tmpEXP2sq = tmpEXP2*tmpEXP2;                                        \
<a name="l00456"></a>00456           tmp2 = 1.0;                                                         \
<a name="l00457"></a>00457           tmp3 = 1.0;                                                         \
<a name="l00458"></a>00458           fg_exp_l[t2][0] = 1.0;                                              \
<a name="l00459"></a>00459           for(lj_fg=1; lj_fg &lt;= (2*ths-&gt;m+2); lj_fg++)                        \
<a name="l00460"></a>00460             {                                                                 \
<a name="l00461"></a>00461               tmp3 = tmp2*tmpEXP2;                                            \
<a name="l00462"></a>00462               tmp2 *= tmpEXP2sq;                                              \
<a name="l00463"></a>00463               fg_exp_l[t2][lj_fg] = fg_exp_l[t2][lj_fg-1]*tmp3;               \
<a name="l00464"></a>00464             }                                                                 \
<a name="l00465"></a>00465         }                                                                     \
<a name="l00466"></a>00466       for(j=0, fj=f; j&lt;ths-&gt;M_total; j++, fj++)                               \
<a name="l00467"></a>00467   {                                                                     \
<a name="l00468"></a>00468           MACRO_init_uo_l_lj_t;                                               \
<a name="l00469"></a>00469                                                                               \
<a name="l00470"></a>00470           for(t2=0; t2&lt;ths-&gt;d; t2++)                                          \
<a name="l00471"></a>00471             {                                                                 \
<a name="l00472"></a>00472               fg_psi[t2][0] = ths-&gt;psi[2*(j*ths-&gt;d+t2)];                      \
<a name="l00473"></a>00473               tmpEXP1 = ths-&gt;psi[2*(j*ths-&gt;d+t2)+1];                          \
<a name="l00474"></a>00474               tmp1 = 1.0;                                                     \
<a name="l00475"></a>00475               for(l_fg=u[t2]+1, lj_fg=1; l_fg &lt;= o[t2]; l_fg++, lj_fg++)      \
<a name="l00476"></a>00476                 {                                                             \
<a name="l00477"></a>00477                   tmp1 *= tmpEXP1;                                            \
<a name="l00478"></a>00478                   fg_psi[t2][lj_fg] = fg_psi[t2][0]*tmp1*fg_exp_l[t2][lj_fg]; \
<a name="l00479"></a>00479                 }                                                             \
<a name="l00480"></a>00480             }                                                                 \
<a name="l00481"></a>00481                                                                               \
<a name="l00482"></a>00482     for(l_L=0; l_L&lt;lprod; l_L++)                                        \
<a name="l00483"></a>00483       {                                                                 \
<a name="l00484"></a>00484               MACRO_update_phi_prod_ll_plain(with_FG_PSI);                    \
<a name="l00485"></a>00485                                                                               \
<a name="l00486"></a>00486         MACRO_nfft_B_compute_ ## which_one;                             \
<a name="l00487"></a>00487                                                                   \
<a name="l00488"></a>00488         MACRO_count_uo_l_lj_t;                                          \
<a name="l00489"></a>00489             } <span class="comment">/* for(l_L) */</span>                                                  \
<a name="l00490"></a>00490   } <span class="comment">/* for(j) */</span>                                                        \
<a name="l00491"></a>00491       return;                                                                 \
<a name="l00492"></a>00492     } <span class="comment">/* if(PRE_FG_PSI) */</span>                                                    \
<a name="l00493"></a>00493                                                                               \
<a name="l00494"></a>00494   if(ths-&gt;nfft_flags &amp; FG_PSI)                                                \
<a name="l00495"></a>00495     {                                                                         \
<a name="l00496"></a>00496       for(t2=0; t2&lt;ths-&gt;d; t2++)                                              \
<a name="l00497"></a>00497         {                                                                     \
<a name="l00498"></a>00498           tmpEXP2 = exp(-1.0/ths-&gt;b[t2]);                                     \
<a name="l00499"></a>00499           tmpEXP2sq = tmpEXP2*tmpEXP2;                                        \
<a name="l00500"></a>00500           tmp2 = 1.0;                                                         \
<a name="l00501"></a>00501           tmp3 = 1.0;                                                         \
<a name="l00502"></a>00502           fg_exp_l[t2][0] = 1.0;                                              \
<a name="l00503"></a>00503           for(lj_fg=1; lj_fg &lt;= (2*ths-&gt;m+2); lj_fg++)                        \
<a name="l00504"></a>00504             {                                                                 \
<a name="l00505"></a>00505               tmp3 = tmp2*tmpEXP2;                                            \
<a name="l00506"></a>00506               tmp2 *= tmpEXP2sq;                                              \
<a name="l00507"></a>00507               fg_exp_l[t2][lj_fg] = fg_exp_l[t2][lj_fg-1]*tmp3;               \
<a name="l00508"></a>00508             }                                                                 \
<a name="l00509"></a>00509         }                                                                     \
<a name="l00510"></a>00510       for(j=0, fj=f; j&lt;ths-&gt;M_total; j++, fj++)                               \
<a name="l00511"></a>00511   {                                                                     \
<a name="l00512"></a>00512           MACRO_init_uo_l_lj_t;                                               \
<a name="l00513"></a>00513                                                                               \
<a name="l00514"></a>00514           for(t2=0; t2&lt;ths-&gt;d; t2++)                                          \
<a name="l00515"></a>00515             {                                                                 \
<a name="l00516"></a>00516               fg_psi[t2][0] =                                                 \
<a name="l00517"></a>00517                 (PHI((ths-&gt;x[j*ths-&gt;d+t2]-((double)u[t2])/ths-&gt;n[t2]),t2));   \
<a name="l00518"></a>00518                                                                               \
<a name="l00519"></a>00519               tmpEXP1 = exp(2.0*(ths-&gt;n[t2]*ths-&gt;x[j*ths-&gt;d+t2] - u[t2])      \
<a name="l00520"></a>00520                       / ths-&gt;b[t2]);                                          \
<a name="l00521"></a>00521               tmp1 = 1.0;                                                     \
<a name="l00522"></a>00522               for(l_fg=u[t2]+1, lj_fg=1; l_fg &lt;= o[t2]; l_fg++, lj_fg++)      \
<a name="l00523"></a>00523                 {                                                             \
<a name="l00524"></a>00524                   tmp1 *= tmpEXP1;                                            \
<a name="l00525"></a>00525                   fg_psi[t2][lj_fg] = fg_psi[t2][0]*tmp1*fg_exp_l[t2][lj_fg]; \
<a name="l00526"></a>00526                 }                                                             \
<a name="l00527"></a>00527             }                                                                 \
<a name="l00528"></a>00528                                                                               \
<a name="l00529"></a>00529     for(l_L=0; l_L&lt;lprod; l_L++)                                        \
<a name="l00530"></a>00530       {                                                                 \
<a name="l00531"></a>00531               MACRO_update_phi_prod_ll_plain(with_FG_PSI);                    \
<a name="l00532"></a>00532                                                                               \
<a name="l00533"></a>00533         MACRO_nfft_B_compute_ ## which_one;                             \
<a name="l00534"></a>00534                                                                   \
<a name="l00535"></a>00535         MACRO_count_uo_l_lj_t;                                          \
<a name="l00536"></a>00536             } <span class="comment">/* for(l_L) */</span>                                                  \
<a name="l00537"></a>00537   } <span class="comment">/* for(j) */</span>                                                        \
<a name="l00538"></a>00538       return;                                                                 \
<a name="l00539"></a>00539     } <span class="comment">/* if(FG_PSI) */</span>                                                        \
<a name="l00540"></a>00540                                                                               \
<a name="l00541"></a>00541                                                                               \
<a name="l00542"></a>00542   if(ths-&gt;nfft_flags &amp; PRE_LIN_PSI)                                           \
<a name="l00543"></a>00543     {                                                                         \
<a name="l00544"></a>00544       for(j=0, fj=f; j&lt;ths-&gt;M_total; j++, fj++)                               \
<a name="l00545"></a>00545   {                                                                     \
<a name="l00546"></a>00546           MACRO_init_uo_l_lj_t;                                               \
<a name="l00547"></a>00547                                                                               \
<a name="l00548"></a>00548           for(t2=0; t2&lt;ths-&gt;d; t2++)                                          \
<a name="l00549"></a>00549             {                                                                 \
<a name="l00550"></a>00550               y[t2] = ((ths-&gt;n[t2]*ths-&gt;x[j*ths-&gt;d+t2]-                       \
<a name="l00551"></a>00551                           (double)u[t2]) * ((double)ths-&gt;K))/(ths-&gt;m+2);      \
<a name="l00552"></a>00552               ip_u  = LRINT(floor(y[t2]));                                    \
<a name="l00553"></a>00553               ip_w  = y[t2]-ip_u;                                             \
<a name="l00554"></a>00554               for(l_fg=u[t2], lj_fg=0; l_fg &lt;= o[t2]; l_fg++, lj_fg++)        \
<a name="l00555"></a>00555                 {                                                             \
<a name="l00556"></a>00556                   fg_psi[t2][lj_fg] = ths-&gt;psi[(ths-&gt;K+1)*t2+                 \
<a name="l00557"></a>00557                  abs(ip_u-lj_fg*ip_s)]*         \
<a name="l00558"></a>00558                                       (1-ip_w) +                              \
<a name="l00559"></a>00559                                       ths-&gt;psi[(ths-&gt;K+1)*t2+                 \
<a name="l00560"></a>00560                  abs(ip_u-lj_fg*ip_s+1)]*       \
<a name="l00561"></a>00561                                        (ip_w);                                \
<a name="l00562"></a>00562               }                                                               \
<a name="l00563"></a>00563             }                                                                 \
<a name="l00564"></a>00564                                                                               \
<a name="l00565"></a>00565     for(l_L=0; l_L&lt;lprod; l_L++)                                        \
<a name="l00566"></a>00566       {                                                                 \
<a name="l00567"></a>00567               MACRO_update_phi_prod_ll_plain(with_FG_PSI);                    \
<a name="l00568"></a>00568                                                                               \
<a name="l00569"></a>00569         MACRO_nfft_B_compute_ ## which_one;                             \
<a name="l00570"></a>00570                                                                   \
<a name="l00571"></a>00571         MACRO_count_uo_l_lj_t;                                          \
<a name="l00572"></a>00572             } <span class="comment">/* for(l_L) */</span>                                                  \
<a name="l00573"></a>00573   } <span class="comment">/* for(j) */</span>                                                        \
<a name="l00574"></a>00574       return;                                                                 \
<a name="l00575"></a>00575     } <span class="comment">/* if(PRE_LIN_PSI) */</span>                                                   \
<a name="l00576"></a>00576                                                                               \
<a name="l00577"></a>00577   <span class="comment">/* no precomputed psi at all */</span>                                             \
<a name="l00578"></a>00578   for(j=0, fj=f; j&lt;ths-&gt;M_total; j++, fj++)                                   \
<a name="l00579"></a>00579     {                                                                         \
<a name="l00580"></a>00580       MACRO_init_uo_l_lj_t;                                                   \
<a name="l00581"></a>00581                                                                         \
<a name="l00582"></a>00582       for(l_L=0; l_L&lt;lprod; l_L++)                                            \
<a name="l00583"></a>00583       {                                                                     \
<a name="l00584"></a>00584           MACRO_update_phi_prod_ll_plain(without_PRE_PSI);                    \
<a name="l00585"></a>00585                                                                               \
<a name="l00586"></a>00586           MACRO_nfft_B_compute_ ## which_one;                                 \
<a name="l00587"></a>00587                                                                   \
<a name="l00588"></a>00588           MACRO_count_uo_l_lj_t;                                              \
<a name="l00589"></a>00589   } <span class="comment">/* for(l_L) */</span>                                                      \
<a name="l00590"></a>00590     } <span class="comment">/* for(j) */</span>                                                            \
<a name="l00591"></a>00591 } <span class="comment">/* nfft_B */</span>                                                                \
<a name="l00592"></a>00592 
<a name="l00593"></a>00593 MACRO_nfft_B(A)
<a name="l00594"></a>00594 MACRO_nfft_B(T)
<a name="l00595"></a>00595 
<a name="l00596"></a>00596 <span class="comment">/* ############################################################ SPECIFIC VERSIONS FOR d=1 */</span>
<a name="l00597"></a>00597 
<a name="l00598"></a>00598 static <span class="keywordtype">void</span> nfft_1d_init_fg_exp_l(<span class="keywordtype">double</span> *fg_exp_l, const <span class="keywordtype">int</span> m, const <span class="keywordtype">double</span> b)
<a name="l00599"></a>00599 {
<a name="l00600"></a>00600   <span class="keywordtype">int</span> l;
<a name="l00601"></a>00601   <span class="keywordtype">double</span> fg_exp_b0, fg_exp_b1, fg_exp_b2, fg_exp_b0_sq;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603   fg_exp_b0 = exp(-1.0/b);
<a name="l00604"></a>00604   fg_exp_b0_sq = fg_exp_b0*fg_exp_b0;
<a name="l00605"></a>00605   fg_exp_b1 = 1.0;
<a name="l00606"></a>00606   fg_exp_b2 = 1.0;
<a name="l00607"></a>00607   fg_exp_l[0] = 1.0;
<a name="l00608"></a>00608   <span class="keywordflow">for</span>(l=1; l &lt;= 2*m+1; l++)
<a name="l00609"></a>00609     {
<a name="l00610"></a>00610       fg_exp_b2 = fg_exp_b1*fg_exp_b0;
<a name="l00611"></a>00611       fg_exp_b1 *= fg_exp_b0_sq;
<a name="l00612"></a>00612       fg_exp_l[l] = fg_exp_l[l-1]*fg_exp_b2;
<a name="l00613"></a>00613     }
<a name="l00614"></a>00614 }
<a name="l00615"></a>00615 
<a name="l00616"></a>00616 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_trafo_1d_compute(<span class="keywordtype">double</span> _Complex *fj, <span class="keyword">const</span> <span class="keywordtype">double</span> _Complex *g,<span class="keyword">const</span> <span class="keywordtype">double</span> *psij_const, <span class="keyword">const</span> <span class="keywordtype">double</span> *xj, <span class="keyword">const</span> <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">int</span> m)
<a name="l00617"></a>00617 {
<a name="l00618"></a>00618   <span class="keywordtype">int</span> u,o,l;
<a name="l00619"></a>00619   <span class="keyword">const</span> <span class="keywordtype">double</span> _Complex *gj;
<a name="l00620"></a>00620   <span class="keyword">const</span> <span class="keywordtype">double</span> *psij;
<a name="l00621"></a>00621   psij=psij_const;
<a name="l00622"></a>00622 
<a name="l00623"></a>00623   nfft_uo2(&amp;u,&amp;o,*xj, n, m);
<a name="l00624"></a>00624 
<a name="l00625"></a>00625   <span class="keywordflow">if</span>(u&lt;o)
<a name="l00626"></a>00626     <span class="keywordflow">for</span>(l=1,gj=g+u,(*fj)=(*psij++) * (*gj++); l&lt;=2*m+1; l++)
<a name="l00627"></a>00627       (*fj) += (*psij++) * (*gj++);
<a name="l00628"></a>00628   <span class="keywordflow">else</span>
<a name="l00629"></a>00629     {
<a name="l00630"></a>00630       <span class="keywordflow">for</span>(l=1,gj=g+u,(*fj)=(*psij++) * (*gj++); l&lt;2*m+1-o; l++)
<a name="l00631"></a>00631   (*fj) += (*psij++) * (*gj++);
<a name="l00632"></a>00632       <span class="keywordflow">for</span>(l=0,gj=g; l&lt;=o; l++)
<a name="l00633"></a>00633   (*fj) += (*psij++) * (*gj++);
<a name="l00634"></a>00634     }
<a name="l00635"></a>00635 }
<a name="l00636"></a>00636 
<a name="l00637"></a>00637 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_adjoint_1d_compute(<span class="keyword">const</span> <span class="keywordtype">double</span> _Complex *fj, <span class="keywordtype">double</span> _Complex *g,<span class="keyword">const</span> <span class="keywordtype">double</span> *psij_const, <span class="keyword">const</span> <span class="keywordtype">double</span> *xj, <span class="keyword">const</span> <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">int</span> m)
<a name="l00638"></a>00638 {
<a name="l00639"></a>00639   <span class="keywordtype">int</span> u,o,l;
<a name="l00640"></a>00640   <span class="keywordtype">double</span> _Complex *gj;
<a name="l00641"></a>00641   <span class="keyword">const</span> <span class="keywordtype">double</span> *psij;
<a name="l00642"></a>00642   psij=psij_const;
<a name="l00643"></a>00643 
<a name="l00644"></a>00644   nfft_uo2(&amp;u,&amp;o,*xj, n, m);
<a name="l00645"></a>00645   
<a name="l00646"></a>00646   <span class="keywordflow">if</span>(u&lt;o)
<a name="l00647"></a>00647     <span class="keywordflow">for</span>(l=0,gj=g+u; l&lt;=2*m+1; l++)
<a name="l00648"></a>00648       (*gj++) += (*psij++) * (*fj);
<a name="l00649"></a>00649   <span class="keywordflow">else</span>
<a name="l00650"></a>00650     {
<a name="l00651"></a>00651       <span class="keywordflow">for</span>(l=0,gj=g+u; l&lt;2*m+1-o; l++)
<a name="l00652"></a>00652   (*gj++) += (*psij++) * (*fj);
<a name="l00653"></a>00653       <span class="keywordflow">for</span>(l=0,gj=g; l&lt;=o; l++)
<a name="l00654"></a>00654   (*gj++) += (*psij++) * (*fj);
<a name="l00655"></a>00655     }
<a name="l00656"></a>00656 }
<a name="l00657"></a>00657 
<a name="l00658"></a>00658 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_trafo_1d_B(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l00659"></a>00659 {
<a name="l00660"></a>00660   <span class="keywordtype">int</span> n,N,u,o,j,M,l,m, *psi_index_g,K,ip_s,ip_u;
<a name="l00661"></a>00661   <span class="keywordtype">double</span> _Complex *fj,*g;
<a name="l00662"></a>00662   <span class="keywordtype">double</span> *psij, *psij_const, *xj, ip_y,ip_w;
<a name="l00663"></a>00663 
<a name="l00664"></a>00664   <span class="keywordtype">double</span> *fg_exp_l, fg_psij0, fg_psij1, fg_psij2;
<a name="l00665"></a>00665 
<a name="l00666"></a>00666   N=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[0];
<a name="l00667"></a>00667   n=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[0];
<a name="l00668"></a>00668   M=ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>;
<a name="l00669"></a>00669   m=ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>;
<a name="l00670"></a>00670 
<a name="l00671"></a>00671   g=ths-&gt;<a class="code" href="structnfft__plan.html#844b51e453d6c80462eaad7844633539" title="Oversampled vector of samples, size is n_total double complex.">g</a>;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673 
<a name="l00674"></a>00674   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g7ad8a7e19519b16340dabec48899c6a4" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FULL_PSI</a>)
<a name="l00675"></a>00675     {
<a name="l00676"></a>00676       psi_index_g=ths-&gt;<a class="code" href="structnfft__plan.html#877d6cbe17ec77a9e66bdbea3cfafe0a" title="Indices in source/target vector for PRE_FULL_PSI.">psi_index_g</a>;
<a name="l00677"></a>00677       <span class="keywordflow">for</span>(j=0, fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>, psij=ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>; j&lt;M; j++, fj++)
<a name="l00678"></a>00678         <span class="keywordflow">for</span>(l=1, (*fj)=(*psij++) * g[(*psi_index_g++)]; l&lt;=2*m+1; l++)
<a name="l00679"></a>00679     (*fj) += (*psij++) * g[(*psi_index_g++)];
<a name="l00680"></a>00680       <span class="keywordflow">return</span>;
<a name="l00681"></a>00681     } <span class="comment">/* if(PRE_FULL_PSI) */</span>
<a name="l00682"></a>00682 
<a name="l00683"></a>00683   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g959463a5c7723ccef5057ddcb784b40c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_PSI</a>)
<a name="l00684"></a>00684     {
<a name="l00685"></a>00685       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>; j&lt;M; j++,fj++,xj++)
<a name="l00686"></a>00686   nfft_trafo_1d_compute(fj, g, ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>+j*(2*m+2), xj, n, m);
<a name="l00687"></a>00687       <span class="keywordflow">return</span>;
<a name="l00688"></a>00688     } <span class="comment">/* if(PRE_PSI) */</span>
<a name="l00689"></a>00689 
<a name="l00690"></a>00690   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g9c5a5ab61009a801082897ca40a1658c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FG_PSI</a>)
<a name="l00691"></a>00691     {
<a name="l00692"></a>00692       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l00693"></a>00693       fg_exp_l=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l00694"></a>00694 
<a name="l00695"></a>00695       nfft_1d_init_fg_exp_l(fg_exp_l, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l00696"></a>00696 
<a name="l00697"></a>00697       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj++)
<a name="l00698"></a>00698   {
<a name="l00699"></a>00699     fg_psij0 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*j];
<a name="l00700"></a>00700     fg_psij1 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*j+1];
<a name="l00701"></a>00701     fg_psij2 = 1.0;
<a name="l00702"></a>00702     psij_const[0] = fg_psij0;
<a name="l00703"></a>00703     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l00704"></a>00704       {
<a name="l00705"></a>00705         fg_psij2 *= fg_psij1;
<a name="l00706"></a>00706         psij_const[l] = fg_psij0*fg_psij2*fg_exp_l[l];
<a name="l00707"></a>00707       }
<a name="l00708"></a>00708 
<a name="l00709"></a>00709     nfft_trafo_1d_compute(fj, g, psij_const, xj, n, m);
<a name="l00710"></a>00710   }
<a name="l00711"></a>00711       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(fg_exp_l);
<a name="l00712"></a>00712       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l00713"></a>00713       <span class="keywordflow">return</span>;
<a name="l00714"></a>00714     } <span class="comment">/* if(PRE_FG_PSI) */</span>
<a name="l00715"></a>00715 
<a name="l00716"></a>00716   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g01ebac2d2071639df189f083fc9f24eb" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">FG_PSI</a>)
<a name="l00717"></a>00717     {
<a name="l00718"></a>00718       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l00719"></a>00719       fg_exp_l=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l00720"></a>00720 
<a name="l00721"></a>00721       nfft_1d_init_fg_exp_l(fg_exp_l, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj++)
<a name="l00724"></a>00724   {
<a name="l00725"></a>00725     nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l00726"></a>00726     fg_psij0 = (PHI(*xj-((<span class="keywordtype">double</span>)u)/n,0));
<a name="l00727"></a>00727     fg_psij1 = exp(2.0*(n*(*xj) - u)/ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l00728"></a>00728     fg_psij2 = 1.0;
<a name="l00729"></a>00729     psij_const[0] = fg_psij0;
<a name="l00730"></a>00730     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l00731"></a>00731       {
<a name="l00732"></a>00732         fg_psij2 *= fg_psij1;
<a name="l00733"></a>00733         psij_const[l] = fg_psij0*fg_psij2*fg_exp_l[l];
<a name="l00734"></a>00734       }
<a name="l00735"></a>00735 
<a name="l00736"></a>00736     nfft_trafo_1d_compute(fj, g, psij_const, xj, n, m);
<a name="l00737"></a>00737   }
<a name="l00738"></a>00738       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(fg_exp_l);
<a name="l00739"></a>00739       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l00740"></a>00740       <span class="keywordflow">return</span>;
<a name="l00741"></a>00741     } <span class="comment">/* if(FG_PSI) */</span>
<a name="l00742"></a>00742 
<a name="l00743"></a>00743   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#gbb1ad048b695cb806baf010c5d1b2caf" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_LIN_PSI</a>)
<a name="l00744"></a>00744     {
<a name="l00745"></a>00745       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l00746"></a>00746       K=ths-&gt;<a class="code" href="structnfft__plan.html#0b3735bcdd415a86126e0c86d47941a4" title="Number of equispaced samples of the window function for PRE_LIN_PSI.">K</a>;
<a name="l00747"></a>00747       ip_s=K/(m+2);
<a name="l00748"></a>00748 
<a name="l00749"></a>00749       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj++)
<a name="l00750"></a>00750   {
<a name="l00751"></a>00751     nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l00752"></a>00752 
<a name="l00753"></a>00753     ip_y = fabs(n*(*xj) - u)*((double)ip_s);
<a name="l00754"></a>00754     ip_u = LRINT(floor(ip_y));
<a name="l00755"></a>00755     ip_w = ip_y-ip_u;
<a name="l00756"></a>00756     <span class="keywordflow">for</span>(l=0; l &lt; 2*m+2; l++)
<a name="l00757"></a>00757       psij_const[l] = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[abs(ip_u-l*ip_s)]*(1.0-ip_w) +
<a name="l00758"></a>00758         ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[abs(ip_u-l*ip_s+1)]*(ip_w);
<a name="l00759"></a>00759 
<a name="l00760"></a>00760     nfft_trafo_1d_compute(fj, g, psij_const, xj, n, m);
<a name="l00761"></a>00761   }
<a name="l00762"></a>00762       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l00763"></a>00763       <span class="keywordflow">return</span>;
<a name="l00764"></a>00764     } <span class="comment">/* if(PRE_LIN_PSI) */</span>
<a name="l00765"></a>00765 
<a name="l00766"></a>00766   <span class="comment">/* no precomputed psi at all */</span>
<a name="l00767"></a>00767   psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l00768"></a>00768   <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj++)
<a name="l00769"></a>00769     {
<a name="l00770"></a>00770       nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l00771"></a>00771 
<a name="l00772"></a>00772       <span class="keywordflow">for</span>(l=0;l&lt;=2*m+1;l++)
<a name="l00773"></a>00773   psij_const[l]=(PHI(*xj-((<span class="keywordtype">double</span>)((u+l)))/n,0));
<a name="l00774"></a>00774 
<a name="l00775"></a>00775       nfft_trafo_1d_compute(fj, g, psij_const, xj, n, m);
<a name="l00776"></a>00776     }
<a name="l00777"></a>00777   <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l00778"></a>00778 }
<a name="l00779"></a>00779 
<a name="l00780"></a>00780 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_adjoint_1d_B(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l00781"></a>00781 {
<a name="l00782"></a>00782   <span class="keywordtype">int</span> n,u,o,j,M,l,m, *psi_index_g,K,ip_s,ip_u;
<a name="l00783"></a>00783   <span class="keywordtype">double</span> _Complex *fj,*g;
<a name="l00784"></a>00784   <span class="keywordtype">double</span> *psij, *psij_const, *xj, ip_y, ip_w;
<a name="l00785"></a>00785   <span class="keywordtype">double</span> *fg_exp_l, fg_psij0, fg_psij1, fg_psij2;
<a name="l00786"></a>00786 
<a name="l00787"></a>00787   n=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[0];
<a name="l00788"></a>00788   M=ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>;
<a name="l00789"></a>00789   m=ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>;
<a name="l00790"></a>00790 
<a name="l00791"></a>00791   g=ths-&gt;<a class="code" href="structnfft__plan.html#844b51e453d6c80462eaad7844633539" title="Oversampled vector of samples, size is n_total double complex.">g</a>;
<a name="l00792"></a>00792   memset(g,0,ths-&gt;<a class="code" href="structnfft__plan.html#d8a5fdac5bcf62d86479c800768fdeb7" title="Total size of FFTW.">n_total</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> _Complex));
<a name="l00793"></a>00793 
<a name="l00794"></a>00794   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g7ad8a7e19519b16340dabec48899c6a4" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FULL_PSI</a>)
<a name="l00795"></a>00795     {
<a name="l00796"></a>00796       psi_index_g=ths-&gt;<a class="code" href="structnfft__plan.html#877d6cbe17ec77a9e66bdbea3cfafe0a" title="Indices in source/target vector for PRE_FULL_PSI.">psi_index_g</a>;
<a name="l00797"></a>00797       <span class="keywordflow">for</span>(j=0, fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>, psij=ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>; j&lt;M; j++, fj++)
<a name="l00798"></a>00798         <span class="keywordflow">for</span>(l=0; l&lt;=2*m+1; l++)
<a name="l00799"></a>00799     g[*psi_index_g++] += (*psij++) * (*fj);
<a name="l00800"></a>00800       <span class="keywordflow">return</span>;
<a name="l00801"></a>00801     } <span class="comment">/* if(PRE_FULL_PSI) */</span>
<a name="l00802"></a>00802 
<a name="l00803"></a>00803   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g959463a5c7723ccef5057ddcb784b40c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_PSI</a>)
<a name="l00804"></a>00804     {
<a name="l00805"></a>00805       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>; j&lt;M; j++,fj++,xj++)
<a name="l00806"></a>00806   nfft_adjoint_1d_compute(fj, g, ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>+j*(2*m+2), xj, n, m);
<a name="l00807"></a>00807       <span class="keywordflow">return</span>;
<a name="l00808"></a>00808     } <span class="comment">/* if(PRE_PSI) */</span>
<a name="l00809"></a>00809 
<a name="l00810"></a>00810   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g9c5a5ab61009a801082897ca40a1658c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FG_PSI</a>)
<a name="l00811"></a>00811     {
<a name="l00812"></a>00812       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l00813"></a>00813       fg_exp_l=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l00814"></a>00814 
<a name="l00815"></a>00815       nfft_1d_init_fg_exp_l(fg_exp_l, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l00816"></a>00816 
<a name="l00817"></a>00817       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj++)
<a name="l00818"></a>00818   {
<a name="l00819"></a>00819     fg_psij0 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*j];
<a name="l00820"></a>00820     fg_psij1 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*j+1];
<a name="l00821"></a>00821     fg_psij2 = 1.0;
<a name="l00822"></a>00822     psij_const[0] = fg_psij0;
<a name="l00823"></a>00823     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l00824"></a>00824       {
<a name="l00825"></a>00825         fg_psij2 *= fg_psij1;
<a name="l00826"></a>00826         psij_const[l] = fg_psij0*fg_psij2*fg_exp_l[l];
<a name="l00827"></a>00827       }
<a name="l00828"></a>00828 
<a name="l00829"></a>00829     nfft_adjoint_1d_compute(fj, g, psij_const, xj, n, m);
<a name="l00830"></a>00830   }
<a name="l00831"></a>00831       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(fg_exp_l);
<a name="l00832"></a>00832       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l00833"></a>00833       <span class="keywordflow">return</span>;
<a name="l00834"></a>00834     } <span class="comment">/* if(PRE_FG_PSI) */</span>
<a name="l00835"></a>00835 
<a name="l00836"></a>00836   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g01ebac2d2071639df189f083fc9f24eb" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">FG_PSI</a>)
<a name="l00837"></a>00837     {
<a name="l00838"></a>00838       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l00839"></a>00839       fg_exp_l=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l00840"></a>00840 
<a name="l00841"></a>00841       nfft_1d_init_fg_exp_l(fg_exp_l, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l00842"></a>00842 
<a name="l00843"></a>00843       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj++)
<a name="l00844"></a>00844   {
<a name="l00845"></a>00845     nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l00846"></a>00846     fg_psij0 = (PHI(*xj-((<span class="keywordtype">double</span>)u)/n,0));
<a name="l00847"></a>00847     fg_psij1 = exp(2.0*(n*(*xj) - u)/ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l00848"></a>00848     fg_psij2 = 1.0;
<a name="l00849"></a>00849     psij_const[0] = fg_psij0;
<a name="l00850"></a>00850     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l00851"></a>00851       {
<a name="l00852"></a>00852         fg_psij2 *= fg_psij1;
<a name="l00853"></a>00853         psij_const[l] = fg_psij0*fg_psij2*fg_exp_l[l];
<a name="l00854"></a>00854       }
<a name="l00855"></a>00855 
<a name="l00856"></a>00856     nfft_adjoint_1d_compute(fj, g, psij_const, xj, n, m);
<a name="l00857"></a>00857   }
<a name="l00858"></a>00858       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(fg_exp_l);
<a name="l00859"></a>00859       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l00860"></a>00860       <span class="keywordflow">return</span>;
<a name="l00861"></a>00861     } <span class="comment">/* if(FG_PSI) */</span>
<a name="l00862"></a>00862 
<a name="l00863"></a>00863   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#gbb1ad048b695cb806baf010c5d1b2caf" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_LIN_PSI</a>)
<a name="l00864"></a>00864     {
<a name="l00865"></a>00865       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l00866"></a>00866       K=ths-&gt;<a class="code" href="structnfft__plan.html#0b3735bcdd415a86126e0c86d47941a4" title="Number of equispaced samples of the window function for PRE_LIN_PSI.">K</a>;
<a name="l00867"></a>00867       ip_s=K/(m+2);
<a name="l00868"></a>00868 
<a name="l00869"></a>00869       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj++)
<a name="l00870"></a>00870   {
<a name="l00871"></a>00871     nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l00872"></a>00872 
<a name="l00873"></a>00873     ip_y = fabs(n*(*xj) - u)*((double)ip_s);
<a name="l00874"></a>00874     ip_u = LRINT(floor(ip_y));
<a name="l00875"></a>00875     ip_w = ip_y-ip_u;
<a name="l00876"></a>00876     <span class="keywordflow">for</span>(l=0; l &lt; 2*m+2; l++)
<a name="l00877"></a>00877       psij_const[l] = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[abs(ip_u-l*ip_s)]*(1.0-ip_w) +
<a name="l00878"></a>00878         ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[abs(ip_u-l*ip_s+1)]*(ip_w);
<a name="l00879"></a>00879 
<a name="l00880"></a>00880     nfft_adjoint_1d_compute(fj, g, psij_const, xj, n, m);
<a name="l00881"></a>00881   }
<a name="l00882"></a>00882       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l00883"></a>00883       <span class="keywordflow">return</span>;
<a name="l00884"></a>00884     } <span class="comment">/* if(PRE_LIN_PSI) */</span>
<a name="l00885"></a>00885 
<a name="l00886"></a>00886   <span class="comment">/* no precomputed psi at all */</span>
<a name="l00887"></a>00887   psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l00888"></a>00888   <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj++)
<a name="l00889"></a>00889     {
<a name="l00890"></a>00890       nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l00891"></a>00891 
<a name="l00892"></a>00892       <span class="keywordflow">for</span>(l=0;l&lt;=2*m+1;l++)
<a name="l00893"></a>00893   psij_const[l]=(PHI(*xj-((<span class="keywordtype">double</span>)((u+l)))/n,0));
<a name="l00894"></a>00894 
<a name="l00895"></a>00895       nfft_adjoint_1d_compute(fj, g, psij_const, xj, n, m);
<a name="l00896"></a>00896     }
<a name="l00897"></a>00897   <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l00898"></a>00898 }
<a name="l00899"></a>00899 
<a name="l00900"></a>00900 <span class="keywordtype">void</span> nfft_trafo_1d(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l00901"></a>00901 {
<a name="l00902"></a>00902   <span class="keywordtype">int</span> k,n,N;
<a name="l00903"></a>00903   <span class="keywordtype">double</span> _Complex *g_hat1,*g_hat2,*f_hat1,*f_hat2;
<a name="l00904"></a>00904   <span class="keywordtype">double</span> *c_phi_inv1, *c_phi_inv2;
<a name="l00905"></a>00905 
<a name="l00906"></a>00906   ths-&gt;<a class="code" href="structnfft__plan.html#2dff6c2b829694a7d4cca5acc7c7d6d5" title="Zero-padded vector of Fourier coefficients, size is n_total fftw_complex.">g_hat</a>=ths-&gt;<a class="code" href="structnfft__plan.html#2190e7201c55214d153b4d91eaa7efda" title="Input of fftw.">g1</a>;
<a name="l00907"></a>00907   ths-&gt;<a class="code" href="structnfft__plan.html#844b51e453d6c80462eaad7844633539" title="Oversampled vector of samples, size is n_total double complex.">g</a>=ths-&gt;<a class="code" href="structnfft__plan.html#d96e0aa935ea3589e999c131c43d8a78" title="Output of fftw.">g2</a>;
<a name="l00908"></a>00908 
<a name="l00909"></a>00909   N=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[0];
<a name="l00910"></a>00910   n=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[0];
<a name="l00911"></a>00911 
<a name="l00912"></a>00912   f_hat1=ths-&gt;<a class="code" href="structnfft__plan.html#23409aec68871e9a56f11711e2891691" title="Vector of Fourier coefficients, \ size is N_total float_types.">f_hat</a>;
<a name="l00913"></a>00913   f_hat2=&amp;ths-&gt;<a class="code" href="structnfft__plan.html#23409aec68871e9a56f11711e2891691" title="Vector of Fourier coefficients, \ size is N_total float_types.">f_hat</a>[N/2];
<a name="l00914"></a>00914   g_hat1=&amp;ths-&gt;<a class="code" href="structnfft__plan.html#2dff6c2b829694a7d4cca5acc7c7d6d5" title="Zero-padded vector of Fourier coefficients, size is n_total fftw_complex.">g_hat</a>[n-N/2];
<a name="l00915"></a>00915   g_hat2=ths-&gt;<a class="code" href="structnfft__plan.html#2dff6c2b829694a7d4cca5acc7c7d6d5" title="Zero-padded vector of Fourier coefficients, size is n_total fftw_complex.">g_hat</a>;
<a name="l00916"></a>00916 
<a name="l00917"></a>00917   <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(0)
<a name="l00918"></a>00918   memset(ths-&gt;g_hat,0,ths-&gt;n_total*sizeof(<span class="keywordtype">double</span> _Complex));
<a name="l00919"></a>00919   if(ths-&gt;nfft_flags &amp; <a class="code" href="group__nfft.html#gda3a356fdaf5840f98374a0a7aaf3e9c" title="If this flag is set, the deconvolution step (the multiplication with the diagonal...">PRE_PHI_HUT</a>)
<a name="l00920"></a>00920     {
<a name="l00921"></a>00921       c_phi_inv1=ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[0];
<a name="l00922"></a>00922       c_phi_inv2=&amp;ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[0][N/2];
<a name="l00923"></a>00923       <span class="keywordflow">for</span>(k=0;k&lt;N/2;k++)
<a name="l00924"></a>00924   {
<a name="l00925"></a>00925     (*g_hat1++) = (*f_hat1++) * (*c_phi_inv1++);
<a name="l00926"></a>00926     (*g_hat2++) = (*f_hat2++) * (*c_phi_inv2++);
<a name="l00927"></a>00927   }
<a name="l00928"></a>00928     }
<a name="l00929"></a>00929   <span class="keywordflow">else</span>
<a name="l00930"></a>00930     <span class="keywordflow">for</span>(k=0;k&lt;N/2;k++)
<a name="l00931"></a>00931       {
<a name="l00932"></a>00932   (*g_hat1++) = (*f_hat1++) / (PHI_HUT(k-N/2,0));
<a name="l00933"></a>00933   (*g_hat2++) = (*f_hat2++) / (PHI_HUT(k,0));
<a name="l00934"></a>00934       }
<a name="l00935"></a>00935 
<a name="l00936"></a>00936   TOC(0)
<a name="l00937"></a>00937 
<a name="l00938"></a>00938   TIC_FFTW(1)
<a name="l00939"></a>00939   fftw_execute(ths-&gt;my_fftw_plan1);
<a name="l00940"></a>00940   TOC_FFTW(1);
<a name="l00941"></a>00941 
<a name="l00942"></a>00942   <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(2);
<a name="l00943"></a>00943   nfft_trafo_1d_B(ths);
<a name="l00944"></a>00944   TOC(2);
<a name="l00945"></a>00945 }
<a name="l00946"></a>00946 
<a name="l00947"></a>00947 <span class="keywordtype">void</span> nfft_adjoint_1d(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l00948"></a>00948 {
<a name="l00949"></a>00949   <span class="keywordtype">int</span> k,n,N;
<a name="l00950"></a>00950   <span class="keywordtype">double</span> _Complex *g_hat1,*g_hat2,*f_hat1,*f_hat2;
<a name="l00951"></a>00951   <span class="keywordtype">double</span> *c_phi_inv1, *c_phi_inv2;
<a name="l00952"></a>00952 
<a name="l00953"></a>00953   N=ths-&gt;N[0];
<a name="l00954"></a>00954   n=ths-&gt;n[0];
<a name="l00955"></a>00955 
<a name="l00956"></a>00956   ths-&gt;g_hat=ths-&gt;g1;
<a name="l00957"></a>00957   ths-&gt;g=ths-&gt;g2;
<a name="l00958"></a>00958 
<a name="l00959"></a>00959   f_hat1=ths-&gt;f_hat;
<a name="l00960"></a>00960   f_hat2=&amp;ths-&gt;f_hat[N/2];
<a name="l00961"></a>00961   g_hat1=&amp;ths-&gt;g_hat[n-N/2];
<a name="l00962"></a>00962   g_hat2=ths-&gt;g_hat;
<a name="l00963"></a>00963 
<a name="l00964"></a>00964   <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(2)
<a name="l00965"></a>00965   nfft_adjoint_1d_B(ths);
<a name="l00966"></a>00966   TOC(0)
<a name="l00967"></a>00967 
<a name="l00968"></a>00968   TIC_FFTW(1)
<a name="l00969"></a>00969   fftw_execute(ths-&gt;my_fftw_plan2);
<a name="l00970"></a>00970   TOC_FFTW(1);
<a name="l00971"></a>00971 
<a name="l00972"></a>00972   <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(0)
<a name="l00973"></a>00973   if(ths-&gt;nfft_flags &amp; PRE_PHI_HUT)
<a name="l00974"></a>00974     {
<a name="l00975"></a>00975       c_phi_inv1=ths-&gt;c_phi_inv[0];
<a name="l00976"></a>00976       c_phi_inv2=&amp;ths-&gt;c_phi_inv[0][N/2];
<a name="l00977"></a>00977       <span class="keywordflow">for</span>(k=0;k&lt;N/2;k++)
<a name="l00978"></a>00978   {
<a name="l00979"></a>00979     (*f_hat1++) = (*g_hat1++) * (*c_phi_inv1++);
<a name="l00980"></a>00980     (*f_hat2++) = (*g_hat2++) * (*c_phi_inv2++);
<a name="l00981"></a>00981   }
<a name="l00982"></a>00982     }
<a name="l00983"></a>00983   <span class="keywordflow">else</span>
<a name="l00984"></a>00984     <span class="keywordflow">for</span>(k=0;k&lt;N/2;k++)
<a name="l00985"></a>00985       {
<a name="l00986"></a>00986   (*f_hat1++) = (*g_hat1++) / (PHI_HUT(k-N/2,0));
<a name="l00987"></a>00987   (*f_hat2++) = (*g_hat2++) / (PHI_HUT(k,0));
<a name="l00988"></a>00988       }
<a name="l00989"></a>00989   TOC(0)
<a name="l00990"></a>00990 }
<a name="l00991"></a>00991 
<a name="l00992"></a>00992 
<a name="l00993"></a>00993 <span class="comment">/* ############################################################ SPECIFIC VERSIONS FOR d=2 */</span>
<a name="l00994"></a>00994 
<a name="l00995"></a>00995 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_2d_init_fg_exp_l(<span class="keywordtype">double</span> *fg_exp_l, <span class="keyword">const</span> <span class="keywordtype">int</span> m, <span class="keyword">const</span> <span class="keywordtype">double</span> b)
<a name="l00996"></a>00996 {
<a name="l00997"></a>00997   <span class="keywordtype">int</span> l;
<a name="l00998"></a>00998   <span class="keywordtype">double</span> fg_exp_b0, fg_exp_b1, fg_exp_b2, fg_exp_b0_sq;
<a name="l00999"></a>00999 
<a name="l01000"></a>01000   fg_exp_b0 = exp(-1.0/b);
<a name="l01001"></a>01001   fg_exp_b0_sq = fg_exp_b0*fg_exp_b0;
<a name="l01002"></a>01002   fg_exp_b1 = 1.0;
<a name="l01003"></a>01003   fg_exp_b2 = 1.0;
<a name="l01004"></a>01004   fg_exp_l[0] = 1.0;
<a name="l01005"></a>01005   <span class="keywordflow">for</span>(l=1; l &lt;= 2*m+1; l++)
<a name="l01006"></a>01006     {
<a name="l01007"></a>01007       fg_exp_b2 = fg_exp_b1*fg_exp_b0;
<a name="l01008"></a>01008       fg_exp_b1 *= fg_exp_b0_sq;
<a name="l01009"></a>01009       fg_exp_l[l] = fg_exp_l[l-1]*fg_exp_b2;
<a name="l01010"></a>01010     }
<a name="l01011"></a>01011 }
<a name="l01012"></a>01012 
<a name="l01013"></a>01013 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_trafo_2d_compute(<span class="keywordtype">double</span> _Complex *fj, <span class="keyword">const</span> <span class="keywordtype">double</span> _Complex *g,
<a name="l01014"></a>01014           <span class="keyword">const</span> <span class="keywordtype">double</span> *psij_const0, <span class="keyword">const</span> <span class="keywordtype">double</span> *psij_const1,
<a name="l01015"></a>01015           <span class="keyword">const</span> <span class="keywordtype">double</span> *xj0, <span class="keyword">const</span> <span class="keywordtype">double</span> *xj1,
<a name="l01016"></a>01016           <span class="keyword">const</span> <span class="keywordtype">int</span> n0, <span class="keyword">const</span> <span class="keywordtype">int</span> n1, <span class="keyword">const</span> <span class="keywordtype">int</span> m)
<a name="l01017"></a>01017 {
<a name="l01018"></a>01018   <span class="keywordtype">int</span> u0,o0,l0,u1,o1,l1;
<a name="l01019"></a>01019   <span class="keyword">const</span> <span class="keywordtype">double</span> _Complex *gj;
<a name="l01020"></a>01020   <span class="keyword">const</span> <span class="keywordtype">double</span> *psij0,*psij1;
<a name="l01021"></a>01021 
<a name="l01022"></a>01022   psij0=psij_const0;
<a name="l01023"></a>01023   psij1=psij_const1;
<a name="l01024"></a>01024 
<a name="l01025"></a>01025   nfft_uo2(&amp;u0,&amp;o0,*xj0, n0, m);
<a name="l01026"></a>01026   nfft_uo2(&amp;u1,&amp;o1,*xj1, n1, m);
<a name="l01027"></a>01027 
<a name="l01028"></a>01028   *fj=0;
<a name="l01029"></a>01029 
<a name="l01030"></a>01030   <span class="keywordflow">if</span>(u0&lt;o0)
<a name="l01031"></a>01031       <span class="keywordflow">if</span>(u1&lt;o1)
<a name="l01032"></a>01032     <span class="keywordflow">for</span>(l0=0; l0&lt;=2*m+1; l0++,psij0++)
<a name="l01033"></a>01033     {
<a name="l01034"></a>01034         psij1=psij_const1;
<a name="l01035"></a>01035         gj=g+(u0+l0)*n1+u1;
<a name="l01036"></a>01036         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++)
<a name="l01037"></a>01037       (*fj) += (*psij0) * (*psij1++) * (*gj++);
<a name="l01038"></a>01038     }
<a name="l01039"></a>01039       <span class="keywordflow">else</span>
<a name="l01040"></a>01040     <span class="keywordflow">for</span>(l0=0; l0&lt;=2*m+1; l0++,psij0++)
<a name="l01041"></a>01041     {
<a name="l01042"></a>01042         psij1=psij_const1;
<a name="l01043"></a>01043         gj=g+(u0+l0)*n1+u1;
<a name="l01044"></a>01044         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++)
<a name="l01045"></a>01045       (*fj) += (*psij0) * (*psij1++) * (*gj++);
<a name="l01046"></a>01046         gj=g+(u0+l0)*n1;
<a name="l01047"></a>01047         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++)
<a name="l01048"></a>01048       (*fj) += (*psij0) * (*psij1++) * (*gj++);
<a name="l01049"></a>01049     }
<a name="l01050"></a>01050   <span class="keywordflow">else</span>
<a name="l01051"></a>01051       <span class="keywordflow">if</span>(u1&lt;o1)
<a name="l01052"></a>01052       {
<a name="l01053"></a>01053     <span class="keywordflow">for</span>(l0=0; l0&lt;2*m+1-o0; l0++,psij0++)
<a name="l01054"></a>01054     {
<a name="l01055"></a>01055         psij1=psij_const1;
<a name="l01056"></a>01056         gj=g+(u0+l0)*n1+u1;
<a name="l01057"></a>01057         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++)
<a name="l01058"></a>01058       (*fj) += (*psij0) * (*psij1++) * (*gj++);
<a name="l01059"></a>01059     }
<a name="l01060"></a>01060     <span class="keywordflow">for</span>(l0=0; l0&lt;=o0; l0++,psij0++)
<a name="l01061"></a>01061     {
<a name="l01062"></a>01062         psij1=psij_const1;
<a name="l01063"></a>01063         gj=g+l0*n1+u1;
<a name="l01064"></a>01064         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++)
<a name="l01065"></a>01065       (*fj) += (*psij0) * (*psij1++) * (*gj++);
<a name="l01066"></a>01066     }
<a name="l01067"></a>01067       }
<a name="l01068"></a>01068       <span class="keywordflow">else</span>
<a name="l01069"></a>01069       {
<a name="l01070"></a>01070     <span class="keywordflow">for</span>(l0=0; l0&lt;2*m+1-o0; l0++,psij0++)
<a name="l01071"></a>01071     {
<a name="l01072"></a>01072         psij1=psij_const1;
<a name="l01073"></a>01073         gj=g+(u0+l0)*n1+u1;
<a name="l01074"></a>01074         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++)
<a name="l01075"></a>01075       (*fj) += (*psij0) * (*psij1++) * (*gj++);
<a name="l01076"></a>01076         gj=g+(u0+l0)*n1;
<a name="l01077"></a>01077         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++)
<a name="l01078"></a>01078       (*fj) += (*psij0) * (*psij1++) * (*gj++);
<a name="l01079"></a>01079     }
<a name="l01080"></a>01080     <span class="keywordflow">for</span>(l0=0; l0&lt;=o0; l0++,psij0++)
<a name="l01081"></a>01081     {
<a name="l01082"></a>01082         psij1=psij_const1;
<a name="l01083"></a>01083         gj=g+l0*n1+u1;
<a name="l01084"></a>01084         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++)
<a name="l01085"></a>01085       (*fj) += (*psij0) * (*psij1++) * (*gj++);
<a name="l01086"></a>01086         gj=g+l0*n1;
<a name="l01087"></a>01087         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++)
<a name="l01088"></a>01088       (*fj) += (*psij0) * (*psij1++) * (*gj++);
<a name="l01089"></a>01089     }
<a name="l01090"></a>01090       }
<a name="l01091"></a>01091 }
<a name="l01092"></a>01092 
<a name="l01093"></a>01093 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_adjoint_2d_compute(<span class="keyword">const</span> <span class="keywordtype">double</span> _Complex *fj, <span class="keywordtype">double</span> _Complex *g,
<a name="l01094"></a>01094             <span class="keyword">const</span> <span class="keywordtype">double</span> *psij_const0, <span class="keyword">const</span> <span class="keywordtype">double</span> *psij_const1,
<a name="l01095"></a>01095             <span class="keyword">const</span> <span class="keywordtype">double</span> *xj0, <span class="keyword">const</span> <span class="keywordtype">double</span> *xj1,
<a name="l01096"></a>01096             <span class="keyword">const</span> <span class="keywordtype">int</span> n0, <span class="keyword">const</span> <span class="keywordtype">int</span> n1, <span class="keyword">const</span> <span class="keywordtype">int</span> m)
<a name="l01097"></a>01097 {
<a name="l01098"></a>01098   <span class="keywordtype">int</span> u0,o0,l0,u1,o1,l1;
<a name="l01099"></a>01099   <span class="keywordtype">double</span> _Complex *gj;
<a name="l01100"></a>01100   <span class="keyword">const</span> <span class="keywordtype">double</span> *psij0,*psij1;
<a name="l01101"></a>01101 
<a name="l01102"></a>01102   psij0=psij_const0;
<a name="l01103"></a>01103   psij1=psij_const1;
<a name="l01104"></a>01104 
<a name="l01105"></a>01105   nfft_uo2(&amp;u0,&amp;o0,*xj0, n0, m);
<a name="l01106"></a>01106   nfft_uo2(&amp;u1,&amp;o1,*xj1, n1, m);
<a name="l01107"></a>01107 
<a name="l01108"></a>01108   <span class="keywordflow">if</span>(u0&lt;o0)
<a name="l01109"></a>01109       <span class="keywordflow">if</span>(u1&lt;o1)
<a name="l01110"></a>01110     <span class="keywordflow">for</span>(l0=0; l0&lt;=2*m+1; l0++,psij0++)
<a name="l01111"></a>01111     {
<a name="l01112"></a>01112         psij1=psij_const1;
<a name="l01113"></a>01113         gj=g+(u0+l0)*n1+u1;
<a name="l01114"></a>01114         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++)
<a name="l01115"></a>01115     (*gj++) += (*psij0) * (*psij1++) * (*fj);
<a name="l01116"></a>01116     }
<a name="l01117"></a>01117       <span class="keywordflow">else</span>
<a name="l01118"></a>01118     <span class="keywordflow">for</span>(l0=0; l0&lt;=2*m+1; l0++,psij0++)
<a name="l01119"></a>01119     {
<a name="l01120"></a>01120         psij1=psij_const1;
<a name="l01121"></a>01121         gj=g+(u0+l0)*n1+u1;
<a name="l01122"></a>01122         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++)
<a name="l01123"></a>01123       (*gj++) += (*psij0) * (*psij1++) * (*fj);
<a name="l01124"></a>01124         gj=g+(u0+l0)*n1;
<a name="l01125"></a>01125         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++)
<a name="l01126"></a>01126       (*gj++) += (*psij0) * (*psij1++) * (*fj);
<a name="l01127"></a>01127     }
<a name="l01128"></a>01128   <span class="keywordflow">else</span>
<a name="l01129"></a>01129       <span class="keywordflow">if</span>(u1&lt;o1)
<a name="l01130"></a>01130       {
<a name="l01131"></a>01131     <span class="keywordflow">for</span>(l0=0; l0&lt;2*m+1-o0; l0++,psij0++)
<a name="l01132"></a>01132     {
<a name="l01133"></a>01133         psij1=psij_const1;
<a name="l01134"></a>01134         gj=g+(u0+l0)*n1+u1;
<a name="l01135"></a>01135         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++)
<a name="l01136"></a>01136       (*gj++) += (*psij0) * (*psij1++) * (*fj);
<a name="l01137"></a>01137     }
<a name="l01138"></a>01138     <span class="keywordflow">for</span>(l0=0; l0&lt;=o0; l0++,psij0++)
<a name="l01139"></a>01139     {
<a name="l01140"></a>01140         psij1=psij_const1;
<a name="l01141"></a>01141         gj=g+l0*n1+u1;
<a name="l01142"></a>01142         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++)
<a name="l01143"></a>01143       (*gj++) += (*psij0) * (*psij1++) * (*fj);
<a name="l01144"></a>01144     }
<a name="l01145"></a>01145       }
<a name="l01146"></a>01146       <span class="keywordflow">else</span>
<a name="l01147"></a>01147       {
<a name="l01148"></a>01148     <span class="keywordflow">for</span>(l0=0; l0&lt;2*m+1-o0; l0++,psij0++)
<a name="l01149"></a>01149     {
<a name="l01150"></a>01150         psij1=psij_const1;
<a name="l01151"></a>01151         gj=g+(u0+l0)*n1+u1;
<a name="l01152"></a>01152         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++)
<a name="l01153"></a>01153       (*gj++) += (*psij0) * (*psij1++) * (*fj);
<a name="l01154"></a>01154         gj=g+(u0+l0)*n1;
<a name="l01155"></a>01155         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++)
<a name="l01156"></a>01156       (*gj++) += (*psij0) * (*psij1++) * (*fj);
<a name="l01157"></a>01157     }
<a name="l01158"></a>01158     <span class="keywordflow">for</span>(l0=0; l0&lt;=o0; l0++,psij0++)
<a name="l01159"></a>01159     {
<a name="l01160"></a>01160         psij1=psij_const1;
<a name="l01161"></a>01161         gj=g+l0*n1+u1;
<a name="l01162"></a>01162         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++)
<a name="l01163"></a>01163       (*gj++) += (*psij0) * (*psij1++) * (*fj);
<a name="l01164"></a>01164         gj=g+l0*n1;
<a name="l01165"></a>01165         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++)
<a name="l01166"></a>01166       (*gj++) += (*psij0) * (*psij1++) * (*fj);
<a name="l01167"></a>01167     }
<a name="l01168"></a>01168       }
<a name="l01169"></a>01169 }
<a name="l01170"></a>01170 
<a name="l01171"></a>01171 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_trafo_2d_B(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l01172"></a>01172 {
<a name="l01173"></a>01173   <span class="keywordtype">int</span> n0,N0,n1,N1,u,o,j,M,l,m, *psi_index_g,K,ip_s,ip_u;
<a name="l01174"></a>01174   <span class="keywordtype">double</span> _Complex *fj,*g;
<a name="l01175"></a>01175   <span class="keywordtype">double</span> *psij, *psij_const, *xj, ip_y, ip_w;
<a name="l01176"></a>01176 
<a name="l01177"></a>01177   <span class="keywordtype">double</span> *fg_exp_l, fg_psij0, fg_psij1, fg_psij2;
<a name="l01178"></a>01178 
<a name="l01179"></a>01179   N0=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[0];
<a name="l01180"></a>01180   n0=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[0];
<a name="l01181"></a>01181   N1=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[1];
<a name="l01182"></a>01182   n1=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[1];
<a name="l01183"></a>01183   M=ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>;
<a name="l01184"></a>01184   m=ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>;
<a name="l01185"></a>01185 
<a name="l01186"></a>01186   g=ths-&gt;<a class="code" href="structnfft__plan.html#844b51e453d6c80462eaad7844633539" title="Oversampled vector of samples, size is n_total double complex.">g</a>;
<a name="l01187"></a>01187 
<a name="l01188"></a>01188   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g7ad8a7e19519b16340dabec48899c6a4" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FULL_PSI</a>)
<a name="l01189"></a>01189     {
<a name="l01190"></a>01190       psi_index_g=ths-&gt;<a class="code" href="structnfft__plan.html#877d6cbe17ec77a9e66bdbea3cfafe0a" title="Indices in source/target vector for PRE_FULL_PSI.">psi_index_g</a>;
<a name="l01191"></a>01191       <span class="keywordflow">for</span>(j=0, fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>, psij=ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>; j&lt;M; j++, fj++)
<a name="l01192"></a>01192         <span class="keywordflow">for</span>(l=1, (*fj)=(*psij++) * g[(*psi_index_g++)]; l&lt;(2*m+2)*(2*m+2); l++)
<a name="l01193"></a>01193     (*fj) += (*psij++) * g[(*psi_index_g++)];
<a name="l01194"></a>01194       <span class="keywordflow">return</span>;
<a name="l01195"></a>01195     } <span class="comment">/* if(PRE_FULL_PSI) */</span>
<a name="l01196"></a>01196 
<a name="l01197"></a>01197   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g959463a5c7723ccef5057ddcb784b40c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_PSI</a>)
<a name="l01198"></a>01198     {
<a name="l01199"></a>01199       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>; j&lt;M; j++,fj++,xj+=2)
<a name="l01200"></a>01200   nfft_trafo_2d_compute(fj, g, ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>+j*2*(2*m+2), ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>+(j*2+1)*(2*m+2), xj, xj+1, n0, n1, m);
<a name="l01201"></a>01201       <span class="keywordflow">return</span>;
<a name="l01202"></a>01202     } <span class="comment">/* if(PRE_PSI) */</span>
<a name="l01203"></a>01203 
<a name="l01204"></a>01204   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g9c5a5ab61009a801082897ca40a1658c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FG_PSI</a>)
<a name="l01205"></a>01205     {
<a name="l01206"></a>01206       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(2*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l01207"></a>01207       fg_exp_l=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(2*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l01208"></a>01208 
<a name="l01209"></a>01209       nfft_2d_init_fg_exp_l(fg_exp_l, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l01210"></a>01210       nfft_2d_init_fg_exp_l(fg_exp_l+2*m+2, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[1]);
<a name="l01211"></a>01211 
<a name="l01212"></a>01212       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=2)
<a name="l01213"></a>01213   {
<a name="l01214"></a>01214     fg_psij0 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*j*2];
<a name="l01215"></a>01215     fg_psij1 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*j*2+1];
<a name="l01216"></a>01216     fg_psij2 = 1.0;
<a name="l01217"></a>01217     psij_const[0] = fg_psij0;
<a name="l01218"></a>01218     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l01219"></a>01219       {
<a name="l01220"></a>01220         fg_psij2 *= fg_psij1;
<a name="l01221"></a>01221         psij_const[l] = fg_psij0*fg_psij2*fg_exp_l[l];
<a name="l01222"></a>01222       }
<a name="l01223"></a>01223 
<a name="l01224"></a>01224     fg_psij0 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*2+1)];
<a name="l01225"></a>01225     fg_psij1 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*2+1)+1];
<a name="l01226"></a>01226     fg_psij2 = 1.0;
<a name="l01227"></a>01227     psij_const[2*m+2] = fg_psij0;
<a name="l01228"></a>01228     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l01229"></a>01229       {
<a name="l01230"></a>01230         fg_psij2 *= fg_psij1;
<a name="l01231"></a>01231         psij_const[2*m+2+l] = fg_psij0*fg_psij2*fg_exp_l[2*m+2+l];
<a name="l01232"></a>01232       }
<a name="l01233"></a>01233 
<a name="l01234"></a>01234     nfft_trafo_2d_compute(fj, g, psij_const, psij_const+2*m+2, xj, xj+1, n0, n1, m);
<a name="l01235"></a>01235   }
<a name="l01236"></a>01236       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(fg_exp_l);
<a name="l01237"></a>01237       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l01238"></a>01238       <span class="keywordflow">return</span>;
<a name="l01239"></a>01239     } <span class="comment">/* if(PRE_FG_PSI) */</span>
<a name="l01240"></a>01240 
<a name="l01241"></a>01241   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g01ebac2d2071639df189f083fc9f24eb" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">FG_PSI</a>)
<a name="l01242"></a>01242     {
<a name="l01243"></a>01243       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(2*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l01244"></a>01244       fg_exp_l=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(2*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l01245"></a>01245 
<a name="l01246"></a>01246       nfft_2d_init_fg_exp_l(fg_exp_l, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l01247"></a>01247       nfft_2d_init_fg_exp_l(fg_exp_l+2*m+2, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[1]);
<a name="l01248"></a>01248 
<a name="l01249"></a>01249       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=2)
<a name="l01250"></a>01250   {
<a name="l01251"></a>01251     nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l01252"></a>01252     fg_psij0 = (PHI(*xj-((<span class="keywordtype">double</span>)u)/n0,0));
<a name="l01253"></a>01253     fg_psij1 = exp(2.0*(n0*(*xj) - u)/ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l01254"></a>01254     fg_psij2 = 1.0;
<a name="l01255"></a>01255     psij_const[0] = fg_psij0;
<a name="l01256"></a>01256     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l01257"></a>01257       {
<a name="l01258"></a>01258         fg_psij2 *= fg_psij1;
<a name="l01259"></a>01259         psij_const[l] = fg_psij0*fg_psij2*fg_exp_l[l];
<a name="l01260"></a>01260       }
<a name="l01261"></a>01261 
<a name="l01262"></a>01262     nfft_uo(ths,j,&amp;u,&amp;o,1);
<a name="l01263"></a>01263     fg_psij0 = (PHI(*(xj+1)-((<span class="keywordtype">double</span>)u)/n1,1));
<a name="l01264"></a>01264     fg_psij1 = exp(2.0*(n1*(*(xj+1)) - u)/ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[1]);
<a name="l01265"></a>01265     fg_psij2 = 1.0;
<a name="l01266"></a>01266     psij_const[2*m+2] = fg_psij0;
<a name="l01267"></a>01267     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l01268"></a>01268       {
<a name="l01269"></a>01269         fg_psij2 *= fg_psij1;
<a name="l01270"></a>01270         psij_const[2*m+2+l] = fg_psij0*fg_psij2*fg_exp_l[2*m+2+l];
<a name="l01271"></a>01271       }
<a name="l01272"></a>01272 
<a name="l01273"></a>01273     nfft_trafo_2d_compute(fj, g, psij_const, psij_const+2*m+2, xj, xj+1, n0, n1, m);
<a name="l01274"></a>01274   }
<a name="l01275"></a>01275       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(fg_exp_l);
<a name="l01276"></a>01276       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l01277"></a>01277       <span class="keywordflow">return</span>;
<a name="l01278"></a>01278     } <span class="comment">/* if(FG_PSI) */</span>
<a name="l01279"></a>01279 
<a name="l01280"></a>01280   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#gbb1ad048b695cb806baf010c5d1b2caf" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_LIN_PSI</a>)
<a name="l01281"></a>01281     {
<a name="l01282"></a>01282       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(2*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l01283"></a>01283       K=ths-&gt;<a class="code" href="structnfft__plan.html#0b3735bcdd415a86126e0c86d47941a4" title="Number of equispaced samples of the window function for PRE_LIN_PSI.">K</a>;
<a name="l01284"></a>01284       ip_s=K/(m+2);
<a name="l01285"></a>01285 
<a name="l01286"></a>01286       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=2)
<a name="l01287"></a>01287   {
<a name="l01288"></a>01288     nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l01289"></a>01289     ip_y = fabs(n0*(*(xj+0)) - u)*((double)ip_s);
<a name="l01290"></a>01290     ip_u = LRINT(floor(ip_y));
<a name="l01291"></a>01291     ip_w = ip_y-ip_u;
<a name="l01292"></a>01292     <span class="keywordflow">for</span>(l=0; l &lt; 2*m+2; l++)
<a name="l01293"></a>01293       psij_const[l] = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[abs(ip_u-l*ip_s)]*(1.0-ip_w) + ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[abs(ip_u-l*ip_s+1)]*(ip_w);
<a name="l01294"></a>01294 
<a name="l01295"></a>01295     nfft_uo(ths,j,&amp;u,&amp;o,1);
<a name="l01296"></a>01296     ip_y = fabs(n1*(*(xj+1)) - u)*((double)ip_s);
<a name="l01297"></a>01297     ip_u = LRINT(floor(ip_y));
<a name="l01298"></a>01298     ip_w = ip_y-ip_u;
<a name="l01299"></a>01299     <span class="keywordflow">for</span>(l=0; l &lt; 2*m+2; l++)
<a name="l01300"></a>01300       psij_const[2*m+2+l] = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[(K+1)+abs(ip_u-l*ip_s)]*(1.0-ip_w) + ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[(K+1)+abs(ip_u-l*ip_s+1)]*(ip_w);
<a name="l01301"></a>01301 
<a name="l01302"></a>01302     nfft_trafo_2d_compute(fj, g, psij_const, psij_const+2*m+2, xj, xj+1, n0, n1, m);
<a name="l01303"></a>01303   }
<a name="l01304"></a>01304       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l01305"></a>01305       <span class="keywordflow">return</span>;
<a name="l01306"></a>01306     } <span class="comment">/* if(PRE_LIN_PSI) */</span>
<a name="l01307"></a>01307 
<a name="l01308"></a>01308   <span class="comment">/* no precomputed psi at all */</span>
<a name="l01309"></a>01309   psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(2*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l01310"></a>01310   <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=2)
<a name="l01311"></a>01311     {
<a name="l01312"></a>01312       nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l01313"></a>01313       <span class="keywordflow">for</span>(l=0;l&lt;=2*m+1;l++)
<a name="l01314"></a>01314   psij_const[l]=(PHI(*xj-((<span class="keywordtype">double</span>)((u+l)))/n0,0));
<a name="l01315"></a>01315 
<a name="l01316"></a>01316       nfft_uo(ths,j,&amp;u,&amp;o,1);
<a name="l01317"></a>01317       <span class="keywordflow">for</span>(l=0;l&lt;=2*m+1;l++)
<a name="l01318"></a>01318   psij_const[2*m+2+l]=(PHI(*(xj+1)-((<span class="keywordtype">double</span>)((u+l)))/n1,1));
<a name="l01319"></a>01319 
<a name="l01320"></a>01320       nfft_trafo_2d_compute(fj, g, psij_const, psij_const+2*m+2, xj, xj+1, n0, n1, m);
<a name="l01321"></a>01321     }
<a name="l01322"></a>01322   <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l01323"></a>01323 }
<a name="l01324"></a>01324 
<a name="l01325"></a>01325 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_adjoint_2d_B(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l01326"></a>01326 {
<a name="l01327"></a>01327   <span class="keywordtype">int</span> n0,N0,n1,N1,u,o,j,M,l,m, *psi_index_g,K,ip_s,ip_u;
<a name="l01328"></a>01328   <span class="keywordtype">double</span> _Complex *fj,*g;
<a name="l01329"></a>01329   <span class="keywordtype">double</span> *psij, *psij_const, *xj ,ip_y, ip_w;
<a name="l01330"></a>01330 
<a name="l01331"></a>01331   <span class="keywordtype">double</span> *fg_exp_l, fg_psij0, fg_psij1, fg_psij2;
<a name="l01332"></a>01332 
<a name="l01333"></a>01333   N0=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[0];
<a name="l01334"></a>01334   n0=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[0];
<a name="l01335"></a>01335   N1=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[1];
<a name="l01336"></a>01336   n1=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[1];
<a name="l01337"></a>01337   M=ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>;
<a name="l01338"></a>01338   m=ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>;
<a name="l01339"></a>01339 
<a name="l01340"></a>01340   g=ths-&gt;<a class="code" href="structnfft__plan.html#844b51e453d6c80462eaad7844633539" title="Oversampled vector of samples, size is n_total double complex.">g</a>;
<a name="l01341"></a>01341   memset(g,0,ths-&gt;<a class="code" href="structnfft__plan.html#d8a5fdac5bcf62d86479c800768fdeb7" title="Total size of FFTW.">n_total</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> _Complex));
<a name="l01342"></a>01342 
<a name="l01343"></a>01343   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g7ad8a7e19519b16340dabec48899c6a4" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FULL_PSI</a>)
<a name="l01344"></a>01344     {
<a name="l01345"></a>01345       psi_index_g=ths-&gt;<a class="code" href="structnfft__plan.html#877d6cbe17ec77a9e66bdbea3cfafe0a" title="Indices in source/target vector for PRE_FULL_PSI.">psi_index_g</a>;
<a name="l01346"></a>01346       <span class="keywordflow">for</span>(j=0, fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>, psij=ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>; j&lt;M; j++, fj++)
<a name="l01347"></a>01347     <span class="keywordflow">for</span>(l=0; l&lt;(2*m+2)*(2*m+2); l++)
<a name="l01348"></a>01348         g[(*psi_index_g++)] += (*psij++) * (*fj);
<a name="l01349"></a>01349       <span class="keywordflow">return</span>;
<a name="l01350"></a>01350     } <span class="comment">/* if(PRE_FULL_PSI) */</span>
<a name="l01351"></a>01351 
<a name="l01352"></a>01352   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g959463a5c7723ccef5057ddcb784b40c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_PSI</a>)
<a name="l01353"></a>01353     {
<a name="l01354"></a>01354       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>; j&lt;M; j++,fj++,xj+=2)
<a name="l01355"></a>01355   nfft_adjoint_2d_compute(fj, g, ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>+j*2*(2*m+2), ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>+(j*2+1)*(2*m+2), xj, xj+1, n0, n1, m);
<a name="l01356"></a>01356       <span class="keywordflow">return</span>;
<a name="l01357"></a>01357     } <span class="comment">/* if(PRE_PSI) */</span>
<a name="l01358"></a>01358 
<a name="l01359"></a>01359   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g9c5a5ab61009a801082897ca40a1658c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FG_PSI</a>)
<a name="l01360"></a>01360     {
<a name="l01361"></a>01361       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(2*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l01362"></a>01362       fg_exp_l=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(2*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l01363"></a>01363 
<a name="l01364"></a>01364       nfft_2d_init_fg_exp_l(fg_exp_l, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l01365"></a>01365       nfft_2d_init_fg_exp_l(fg_exp_l+2*m+2, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[1]);
<a name="l01366"></a>01366 
<a name="l01367"></a>01367       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=2)
<a name="l01368"></a>01368   {
<a name="l01369"></a>01369     fg_psij0 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*j*2];
<a name="l01370"></a>01370     fg_psij1 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*j*2+1];
<a name="l01371"></a>01371     fg_psij2 = 1.0;
<a name="l01372"></a>01372     psij_const[0] = fg_psij0;
<a name="l01373"></a>01373     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l01374"></a>01374       {
<a name="l01375"></a>01375         fg_psij2 *= fg_psij1;
<a name="l01376"></a>01376         psij_const[l] = fg_psij0*fg_psij2*fg_exp_l[l];
<a name="l01377"></a>01377       }
<a name="l01378"></a>01378 
<a name="l01379"></a>01379     fg_psij0 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*2+1)];
<a name="l01380"></a>01380     fg_psij1 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*2+1)+1];
<a name="l01381"></a>01381     fg_psij2 = 1.0;
<a name="l01382"></a>01382     psij_const[2*m+2] = fg_psij0;
<a name="l01383"></a>01383     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l01384"></a>01384       {
<a name="l01385"></a>01385         fg_psij2 *= fg_psij1;
<a name="l01386"></a>01386         psij_const[2*m+2+l] = fg_psij0*fg_psij2*fg_exp_l[2*m+2+l];
<a name="l01387"></a>01387       }
<a name="l01388"></a>01388 
<a name="l01389"></a>01389     nfft_adjoint_2d_compute(fj, g, psij_const, psij_const+2*m+2, xj, xj+1, n0, n1, m);
<a name="l01390"></a>01390   }
<a name="l01391"></a>01391       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(fg_exp_l);
<a name="l01392"></a>01392       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l01393"></a>01393       <span class="keywordflow">return</span>;
<a name="l01394"></a>01394     } <span class="comment">/* if(PRE_FG_PSI) */</span>
<a name="l01395"></a>01395 
<a name="l01396"></a>01396   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g01ebac2d2071639df189f083fc9f24eb" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">FG_PSI</a>)
<a name="l01397"></a>01397     {
<a name="l01398"></a>01398       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(2*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l01399"></a>01399       fg_exp_l=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(2*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l01400"></a>01400 
<a name="l01401"></a>01401       nfft_2d_init_fg_exp_l(fg_exp_l, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l01402"></a>01402       nfft_2d_init_fg_exp_l(fg_exp_l+2*m+2, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[1]);
<a name="l01403"></a>01403 
<a name="l01404"></a>01404       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=2)
<a name="l01405"></a>01405   {
<a name="l01406"></a>01406     nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l01407"></a>01407     fg_psij0 = (PHI(*xj-((<span class="keywordtype">double</span>)u)/n0,0));
<a name="l01408"></a>01408     fg_psij1 = exp(2.0*(n0*(*xj) - u)/ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l01409"></a>01409     fg_psij2 = 1.0;
<a name="l01410"></a>01410     psij_const[0] = fg_psij0;
<a name="l01411"></a>01411     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l01412"></a>01412       {
<a name="l01413"></a>01413         fg_psij2 *= fg_psij1;
<a name="l01414"></a>01414         psij_const[l] = fg_psij0*fg_psij2*fg_exp_l[l];
<a name="l01415"></a>01415       }
<a name="l01416"></a>01416 
<a name="l01417"></a>01417     nfft_uo(ths,j,&amp;u,&amp;o,1);
<a name="l01418"></a>01418     fg_psij0 = (PHI(*(xj+1)-((<span class="keywordtype">double</span>)u)/n1,1));
<a name="l01419"></a>01419     fg_psij1 = exp(2.0*(n1*(*(xj+1)) - u)/ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[1]);
<a name="l01420"></a>01420     fg_psij2 = 1.0;
<a name="l01421"></a>01421     psij_const[2*m+2] = fg_psij0;
<a name="l01422"></a>01422     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l01423"></a>01423       {
<a name="l01424"></a>01424         fg_psij2 *= fg_psij1;
<a name="l01425"></a>01425         psij_const[2*m+2+l] = fg_psij0*fg_psij2*fg_exp_l[2*m+2+l];
<a name="l01426"></a>01426       }
<a name="l01427"></a>01427 
<a name="l01428"></a>01428     nfft_adjoint_2d_compute(fj, g, psij_const, psij_const+2*m+2, xj, xj+1, n0, n1, m);
<a name="l01429"></a>01429   }
<a name="l01430"></a>01430       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(fg_exp_l);
<a name="l01431"></a>01431       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l01432"></a>01432       <span class="keywordflow">return</span>;
<a name="l01433"></a>01433     } <span class="comment">/* if(FG_PSI) */</span>
<a name="l01434"></a>01434 
<a name="l01435"></a>01435   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#gbb1ad048b695cb806baf010c5d1b2caf" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_LIN_PSI</a>)
<a name="l01436"></a>01436     {
<a name="l01437"></a>01437       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(2*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l01438"></a>01438       K=ths-&gt;<a class="code" href="structnfft__plan.html#0b3735bcdd415a86126e0c86d47941a4" title="Number of equispaced samples of the window function for PRE_LIN_PSI.">K</a>;
<a name="l01439"></a>01439       ip_s=K/(m+2);
<a name="l01440"></a>01440 
<a name="l01441"></a>01441       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=2)
<a name="l01442"></a>01442   {
<a name="l01443"></a>01443     nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l01444"></a>01444     ip_y = fabs(n0*(*(xj+0)) - u)*((double)ip_s);
<a name="l01445"></a>01445     ip_u = LRINT(floor(ip_y));
<a name="l01446"></a>01446     ip_w = ip_y-ip_u;
<a name="l01447"></a>01447     <span class="keywordflow">for</span>(l=0; l &lt; 2*m+2; l++)
<a name="l01448"></a>01448       psij_const[l] = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[abs(ip_u-l*ip_s)]*(1.0-ip_w) +
<a name="l01449"></a>01449         ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[abs(ip_u-l*ip_s+1)]*(ip_w);
<a name="l01450"></a>01450 
<a name="l01451"></a>01451     nfft_uo(ths,j,&amp;u,&amp;o,1);
<a name="l01452"></a>01452     ip_y = fabs(n1*(*(xj+1)) - u)*((double)ip_s);
<a name="l01453"></a>01453     ip_u = LRINT(floor(ip_y));
<a name="l01454"></a>01454     ip_w = ip_y-ip_u;
<a name="l01455"></a>01455     <span class="keywordflow">for</span>(l=0; l &lt; 2*m+2; l++)
<a name="l01456"></a>01456       psij_const[2*m+2+l] = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[(K+1)+abs(ip_u-l*ip_s)]*(1.0-ip_w) +
<a name="l01457"></a>01457         ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[(K+1)+abs(ip_u-l*ip_s+1)]*(ip_w);
<a name="l01458"></a>01458 
<a name="l01459"></a>01459     nfft_adjoint_2d_compute(fj, g, psij_const, psij_const+2*m+2, xj, xj+1, n0, n1, m);
<a name="l01460"></a>01460   }
<a name="l01461"></a>01461       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l01462"></a>01462       <span class="keywordflow">return</span>;
<a name="l01463"></a>01463     } <span class="comment">/* if(PRE_LIN_PSI) */</span>
<a name="l01464"></a>01464 
<a name="l01465"></a>01465   <span class="comment">/* no precomputed psi at all */</span>
<a name="l01466"></a>01466   psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(2*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l01467"></a>01467   <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=2)
<a name="l01468"></a>01468     {
<a name="l01469"></a>01469       nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l01470"></a>01470       <span class="keywordflow">for</span>(l=0;l&lt;=2*m+1;l++)
<a name="l01471"></a>01471   psij_const[l]=(PHI(*xj-((<span class="keywordtype">double</span>)((u+l)))/n0,0));
<a name="l01472"></a>01472 
<a name="l01473"></a>01473       nfft_uo(ths,j,&amp;u,&amp;o,1);
<a name="l01474"></a>01474       <span class="keywordflow">for</span>(l=0;l&lt;=2*m+1;l++)
<a name="l01475"></a>01475   psij_const[2*m+2+l]=(PHI(*(xj+1)-((<span class="keywordtype">double</span>)((u+l)))/n1,1));
<a name="l01476"></a>01476 
<a name="l01477"></a>01477       nfft_adjoint_2d_compute(fj, g, psij_const, psij_const+2*m+2, xj, xj+1, n0, n1, m);
<a name="l01478"></a>01478     }
<a name="l01479"></a>01479   <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l01480"></a>01480 }
<a name="l01481"></a>01481 
<a name="l01482"></a>01482 
<a name="l01483"></a>01483 <span class="keywordtype">void</span> nfft_trafo_2d(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l01484"></a>01484 {
<a name="l01485"></a>01485   <span class="keywordtype">int</span> k0,k1,n0,n1,N0,N1;
<a name="l01486"></a>01486   <span class="keywordtype">double</span> _Complex *g_hat,*f_hat;
<a name="l01487"></a>01487   <span class="keywordtype">double</span> *c_phi_inv01, *c_phi_inv02, *c_phi_inv11, *c_phi_inv12;
<a name="l01488"></a>01488   <span class="keywordtype">double</span> ck01, ck02, ck11, ck12;
<a name="l01489"></a>01489   <span class="keywordtype">double</span> _Complex *g_hat11,*f_hat11,*g_hat21,*f_hat21,*g_hat12,*f_hat12,*g_hat22,*f_hat22;
<a name="l01490"></a>01490 
<a name="l01491"></a>01491   ths-&gt;<a class="code" href="structnfft__plan.html#2dff6c2b829694a7d4cca5acc7c7d6d5" title="Zero-padded vector of Fourier coefficients, size is n_total fftw_complex.">g_hat</a>=ths-&gt;<a class="code" href="structnfft__plan.html#2190e7201c55214d153b4d91eaa7efda" title="Input of fftw.">g1</a>;
<a name="l01492"></a>01492   ths-&gt;<a class="code" href="structnfft__plan.html#844b51e453d6c80462eaad7844633539" title="Oversampled vector of samples, size is n_total double complex.">g</a>=ths-&gt;<a class="code" href="structnfft__plan.html#d96e0aa935ea3589e999c131c43d8a78" title="Output of fftw.">g2</a>;
<a name="l01493"></a>01493 
<a name="l01494"></a>01494   N0=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[0];
<a name="l01495"></a>01495   N1=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[1];
<a name="l01496"></a>01496   n0=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[0];
<a name="l01497"></a>01497   n1=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[1];
<a name="l01498"></a>01498 
<a name="l01499"></a>01499   f_hat=ths-&gt;<a class="code" href="structnfft__plan.html#23409aec68871e9a56f11711e2891691" title="Vector of Fourier coefficients, \ size is N_total float_types.">f_hat</a>;
<a name="l01500"></a>01500   g_hat=ths-&gt;<a class="code" href="structnfft__plan.html#2dff6c2b829694a7d4cca5acc7c7d6d5" title="Zero-padded vector of Fourier coefficients, size is n_total fftw_complex.">g_hat</a>;
<a name="l01501"></a>01501 
<a name="l01502"></a>01502   <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(0)
<a name="l01503"></a>01503   memset(ths-&gt;g_hat,0,ths-&gt;n_total*sizeof(<span class="keywordtype">double</span> _Complex));
<a name="l01504"></a>01504   if(ths-&gt;nfft_flags &amp; PRE_PHI_HUT)
<a name="l01505"></a>01505     {
<a name="l01506"></a>01506       c_phi_inv01=ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[0];
<a name="l01507"></a>01507       c_phi_inv02=&amp;ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[0][N0/2];
<a name="l01508"></a>01508 
<a name="l01509"></a>01509       <span class="keywordflow">for</span>(k0=0;k0&lt;N0/2;k0++)
<a name="l01510"></a>01510   {
<a name="l01511"></a>01511     ck01=(*c_phi_inv01++);
<a name="l01512"></a>01512     ck02=(*c_phi_inv02++);
<a name="l01513"></a>01513 
<a name="l01514"></a>01514     c_phi_inv11=ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[1];
<a name="l01515"></a>01515     c_phi_inv12=&amp;ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[1][N1/2];
<a name="l01516"></a>01516 
<a name="l01517"></a>01517     g_hat11=g_hat + (n0-N0/2+k0)*n1+n1-N1/2;
<a name="l01518"></a>01518     f_hat11=f_hat + k0*N1;
<a name="l01519"></a>01519           g_hat21=g_hat + k0*n1+n1-N1/2;
<a name="l01520"></a>01520           f_hat21=f_hat + (N0/2+k0)*N1;
<a name="l01521"></a>01521           g_hat12=g_hat + (n0-N0/2+k0)*n1;
<a name="l01522"></a>01522           f_hat12=f_hat + k0*N1+N1/2;
<a name="l01523"></a>01523     g_hat22=g_hat + k0*n1;
<a name="l01524"></a>01524     f_hat22=f_hat + (N0/2+k0)*N1+N1/2;
<a name="l01525"></a>01525     <span class="keywordflow">for</span>(k1=0;k1&lt;N1/2;k1++)
<a name="l01526"></a>01526       {
<a name="l01527"></a>01527         ck11=(*c_phi_inv11++);
<a name="l01528"></a>01528         ck12=(*c_phi_inv12++);
<a name="l01529"></a>01529 
<a name="l01530"></a>01530         (*g_hat11++) = (*f_hat11++) * ck01 * ck11;
<a name="l01531"></a>01531         (*g_hat21++) = (*f_hat21++) * ck02 * ck11;
<a name="l01532"></a>01532         (*g_hat12++) = (*f_hat12++) * ck01 * ck12;
<a name="l01533"></a>01533         (*g_hat22++) = (*f_hat22++) * ck02 * ck12;
<a name="l01534"></a>01534       }
<a name="l01535"></a>01535   }
<a name="l01536"></a>01536     }
<a name="l01537"></a>01537   <span class="keywordflow">else</span>
<a name="l01538"></a>01538     <span class="keywordflow">for</span>(k0=0;k0&lt;N0/2;k0++)
<a name="l01539"></a>01539       {
<a name="l01540"></a>01540   ck01=1./(PHI_HUT(k0-N0/2,0));
<a name="l01541"></a>01541   ck02=1./(PHI_HUT(k0,0));
<a name="l01542"></a>01542   <span class="keywordflow">for</span>(k1=0;k1&lt;N1/2;k1++)
<a name="l01543"></a>01543     {
<a name="l01544"></a>01544       ck11=1./(PHI_HUT(k1-N1/2,1));
<a name="l01545"></a>01545       ck12=1./(PHI_HUT(k1,1));
<a name="l01546"></a>01546       g_hat[(n0-N0/2+k0)*n1+n1-N1/2+k1] = f_hat[k0*N1+k1]             * ck01 * ck11;
<a name="l01547"></a>01547       g_hat[k0*n1+n1-N1/2+k1]           = f_hat[(N0/2+k0)*N1+k1]      * ck02 * ck11;
<a name="l01548"></a>01548       g_hat[(n0-N0/2+k0)*n1+k1]         = f_hat[k0*N1+N1/2+k1]        * ck01 * ck12;
<a name="l01549"></a>01549       g_hat[k0*n1+k1]                   = f_hat[(N0/2+k0)*N1+N1/2+k1] * ck02 * ck12;
<a name="l01550"></a>01550     }
<a name="l01551"></a>01551       }
<a name="l01552"></a>01552 
<a name="l01553"></a>01553   TOC(0)
<a name="l01554"></a>01554 
<a name="l01555"></a>01555   TIC_FFTW(1)
<a name="l01556"></a>01556   fftw_execute(ths-&gt;my_fftw_plan1);
<a name="l01557"></a>01557   TOC_FFTW(1);
<a name="l01558"></a>01558 
<a name="l01559"></a>01559   <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(2);
<a name="l01560"></a>01560   nfft_trafo_2d_B(ths);
<a name="l01561"></a>01561   TOC(2);
<a name="l01562"></a>01562 }
<a name="l01563"></a>01563 
<a name="l01564"></a>01564 <span class="keywordtype">void</span> nfft_adjoint_2d(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l01565"></a>01565 {
<a name="l01566"></a>01566   <span class="keywordtype">int</span> k0,k1,n0,n1,N0,N1;
<a name="l01567"></a>01567   <span class="keywordtype">double</span> _Complex *g_hat,*f_hat;
<a name="l01568"></a>01568   <span class="keywordtype">double</span> *c_phi_inv01, *c_phi_inv02, *c_phi_inv11, *c_phi_inv12;
<a name="l01569"></a>01569   <span class="keywordtype">double</span> ck01, ck02, ck11, ck12;
<a name="l01570"></a>01570   <span class="keywordtype">double</span> _Complex *g_hat11,*f_hat11,*g_hat21,*f_hat21,*g_hat12,*f_hat12,*g_hat22,*f_hat22;
<a name="l01571"></a>01571 
<a name="l01572"></a>01572   ths-&gt;g_hat=ths-&gt;g1;
<a name="l01573"></a>01573   ths-&gt;g=ths-&gt;g2;
<a name="l01574"></a>01574 
<a name="l01575"></a>01575   N0=ths-&gt;N[0];
<a name="l01576"></a>01576   N1=ths-&gt;N[1];
<a name="l01577"></a>01577   n0=ths-&gt;n[0];
<a name="l01578"></a>01578   n1=ths-&gt;n[1];
<a name="l01579"></a>01579 
<a name="l01580"></a>01580   f_hat=ths-&gt;f_hat;
<a name="l01581"></a>01581   g_hat=ths-&gt;g_hat;
<a name="l01582"></a>01582 
<a name="l01583"></a>01583   <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(2);
<a name="l01584"></a>01584   nfft_adjoint_2d_B(ths);
<a name="l01585"></a>01585   TOC(2);
<a name="l01586"></a>01586 
<a name="l01587"></a>01587   TIC_FFTW(1)
<a name="l01588"></a>01588   fftw_execute(ths-&gt;my_fftw_plan2);
<a name="l01589"></a>01589   TOC_FFTW(1);
<a name="l01590"></a>01590 
<a name="l01591"></a>01591   <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(0)
<a name="l01592"></a>01592   if(ths-&gt;nfft_flags &amp; PRE_PHI_HUT)
<a name="l01593"></a>01593     {
<a name="l01594"></a>01594       c_phi_inv01=ths-&gt;c_phi_inv[0];
<a name="l01595"></a>01595       c_phi_inv02=&amp;ths-&gt;c_phi_inv[0][N0/2];
<a name="l01596"></a>01596   
<a name="l01597"></a>01597       <span class="keywordflow">for</span>(k0=0;k0&lt;N0/2;k0++)
<a name="l01598"></a>01598   {
<a name="l01599"></a>01599     ck01=(*c_phi_inv01++);
<a name="l01600"></a>01600     ck02=(*c_phi_inv02++);
<a name="l01601"></a>01601 
<a name="l01602"></a>01602     c_phi_inv11=ths-&gt;c_phi_inv[1];
<a name="l01603"></a>01603     c_phi_inv12=&amp;ths-&gt;c_phi_inv[1][N1/2];
<a name="l01604"></a>01604     g_hat11=g_hat + (n0-N0/2+k0)*n1+n1-N1/2;
<a name="l01605"></a>01605     f_hat11=f_hat + k0*N1;
<a name="l01606"></a>01606           g_hat21=g_hat + k0*n1+n1-N1/2;
<a name="l01607"></a>01607           f_hat21=f_hat + (N0/2+k0)*N1;
<a name="l01608"></a>01608           g_hat12=g_hat + (n0-N0/2+k0)*n1;
<a name="l01609"></a>01609           f_hat12=f_hat + k0*N1+N1/2;
<a name="l01610"></a>01610     g_hat22=g_hat + k0*n1;
<a name="l01611"></a>01611     f_hat22=f_hat + (N0/2+k0)*N1+N1/2;
<a name="l01612"></a>01612     <span class="keywordflow">for</span>(k1=0;k1&lt;N1/2;k1++)
<a name="l01613"></a>01613       {
<a name="l01614"></a>01614         ck11=(*c_phi_inv11++);
<a name="l01615"></a>01615         ck12=(*c_phi_inv12++);
<a name="l01616"></a>01616 
<a name="l01617"></a>01617         (*f_hat11++) = (*g_hat11++) * ck01 * ck11;
<a name="l01618"></a>01618         (*f_hat21++) = (*g_hat21++) * ck02 * ck11;
<a name="l01619"></a>01619         (*f_hat12++) = (*g_hat12++) * ck01 * ck12;
<a name="l01620"></a>01620         (*f_hat22++) = (*g_hat22++) * ck02 * ck12;
<a name="l01621"></a>01621       }
<a name="l01622"></a>01622   }
<a name="l01623"></a>01623     }
<a name="l01624"></a>01624   <span class="keywordflow">else</span>
<a name="l01625"></a>01625     <span class="keywordflow">for</span>(k0=0;k0&lt;N0/2;k0++)
<a name="l01626"></a>01626       {
<a name="l01627"></a>01627   ck01=1./(PHI_HUT(k0-N0/2,0));
<a name="l01628"></a>01628   ck02=1./(PHI_HUT(k0,0));
<a name="l01629"></a>01629   <span class="keywordflow">for</span>(k1=0;k1&lt;N1/2;k1++)
<a name="l01630"></a>01630     {
<a name="l01631"></a>01631       ck11=1./(PHI_HUT(k1-N1/2,1));
<a name="l01632"></a>01632       ck12=1./(PHI_HUT(k1,1));
<a name="l01633"></a>01633       f_hat[k0*N1+k1]             = g_hat[(n0-N0/2+k0)*n1+n1-N1/2+k1] * ck01 * ck11;
<a name="l01634"></a>01634       f_hat[(N0/2+k0)*N1+k1]      = g_hat[k0*n1+n1-N1/2+k1]           * ck02 * ck11;
<a name="l01635"></a>01635       f_hat[k0*N1+N1/2+k1]        = g_hat[(n0-N0/2+k0)*n1+k1]         * ck01 * ck12;
<a name="l01636"></a>01636       f_hat[(N0/2+k0)*N1+N1/2+k1] = g_hat[k0*n1+k1]                   * ck02 * ck12;
<a name="l01637"></a>01637     }
<a name="l01638"></a>01638       }
<a name="l01639"></a>01639   TOC(0)
<a name="l01640"></a>01640 }
<a name="l01641"></a>01641 
<a name="l01642"></a>01642 <span class="comment">/* ############################################################ SPECIFIC VERSIONS FOR d=3 */</span>
<a name="l01643"></a>01643 
<a name="l01644"></a>01644 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_3d_init_fg_exp_l(<span class="keywordtype">double</span> *fg_exp_l, <span class="keyword">const</span> <span class="keywordtype">int</span> m, <span class="keyword">const</span> <span class="keywordtype">double</span> b)
<a name="l01645"></a>01645 {
<a name="l01646"></a>01646   <span class="keywordtype">int</span> l;
<a name="l01647"></a>01647   <span class="keywordtype">double</span> fg_exp_b0, fg_exp_b1, fg_exp_b2, fg_exp_b0_sq;
<a name="l01648"></a>01648 
<a name="l01649"></a>01649   fg_exp_b0 = exp(-1.0/b);
<a name="l01650"></a>01650   fg_exp_b0_sq = fg_exp_b0*fg_exp_b0;
<a name="l01651"></a>01651   fg_exp_b1 = 1.0;
<a name="l01652"></a>01652   fg_exp_b2 = 1.0;
<a name="l01653"></a>01653   fg_exp_l[0] = 1.0;
<a name="l01654"></a>01654   <span class="keywordflow">for</span>(l=1; l &lt;= 2*m+1; l++)
<a name="l01655"></a>01655     {
<a name="l01656"></a>01656       fg_exp_b2 = fg_exp_b1*fg_exp_b0;
<a name="l01657"></a>01657       fg_exp_b1 *= fg_exp_b0_sq;
<a name="l01658"></a>01658       fg_exp_l[l] = fg_exp_l[l-1]*fg_exp_b2;
<a name="l01659"></a>01659     }
<a name="l01660"></a>01660 }
<a name="l01661"></a>01661 
<a name="l01662"></a>01662 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_trafo_3d_compute(<span class="keywordtype">double</span> _Complex *fj, <span class="keyword">const</span> <span class="keywordtype">double</span> _Complex *g,
<a name="l01663"></a>01663           <span class="keyword">const</span> <span class="keywordtype">double</span> *psij_const0, <span class="keyword">const</span> <span class="keywordtype">double</span> *psij_const1, <span class="keyword">const</span> <span class="keywordtype">double</span> *psij_const2,
<a name="l01664"></a>01664           <span class="keyword">const</span> <span class="keywordtype">double</span> *xj0, <span class="keyword">const</span> <span class="keywordtype">double</span> *xj1, <span class="keyword">const</span> <span class="keywordtype">double</span> *xj2,
<a name="l01665"></a>01665           <span class="keyword">const</span> <span class="keywordtype">int</span> n0, <span class="keyword">const</span> <span class="keywordtype">int</span> n1, <span class="keyword">const</span> <span class="keywordtype">int</span> n2, <span class="keyword">const</span> <span class="keywordtype">int</span> m)
<a name="l01666"></a>01666 {
<a name="l01667"></a>01667   <span class="keywordtype">int</span> u0,o0,l0,u1,o1,l1,u2,o2,l2;
<a name="l01668"></a>01668   <span class="keyword">const</span> <span class="keywordtype">double</span> _Complex *gj;
<a name="l01669"></a>01669   <span class="keyword">const</span> <span class="keywordtype">double</span> *psij0,*psij1,*psij2;
<a name="l01670"></a>01670 
<a name="l01671"></a>01671   psij0=psij_const0;
<a name="l01672"></a>01672   psij1=psij_const1;
<a name="l01673"></a>01673   psij2=psij_const2;
<a name="l01674"></a>01674 
<a name="l01675"></a>01675   nfft_uo2(&amp;u0,&amp;o0,*xj0, n0, m);
<a name="l01676"></a>01676   nfft_uo2(&amp;u1,&amp;o1,*xj1, n1, m);
<a name="l01677"></a>01677   nfft_uo2(&amp;u2,&amp;o2,*xj2, n2, m);
<a name="l01678"></a>01678 
<a name="l01679"></a>01679   *fj=0;
<a name="l01680"></a>01680 
<a name="l01681"></a>01681   <span class="keywordflow">if</span>(u0&lt;o0)
<a name="l01682"></a>01682     <span class="keywordflow">if</span>(u1&lt;o1)
<a name="l01683"></a>01683       <span class="keywordflow">if</span>(u2&lt;o2)
<a name="l01684"></a>01684   <span class="keywordflow">for</span>(l0=0; l0&lt;=2*m+1; l0++,psij0++)
<a name="l01685"></a>01685     {
<a name="l01686"></a>01686       psij1=psij_const1;
<a name="l01687"></a>01687       <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++,psij1++)
<a name="l01688"></a>01688         {
<a name="l01689"></a>01689     psij2=psij_const2;
<a name="l01690"></a>01690     gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l01691"></a>01691     <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l01692"></a>01692       (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01693"></a>01693         }
<a name="l01694"></a>01694     }
<a name="l01695"></a>01695       <span class="keywordflow">else</span><span class="comment">/* asserts (u2&gt;o2)*/</span>
<a name="l01696"></a>01696   <span class="keywordflow">for</span>(l0=0; l0&lt;=2*m+1; l0++,psij0++)
<a name="l01697"></a>01697     {
<a name="l01698"></a>01698       psij1=psij_const1;
<a name="l01699"></a>01699       <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++,psij1++)
<a name="l01700"></a>01700         {
<a name="l01701"></a>01701     psij2=psij_const2;
<a name="l01702"></a>01702     gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l01703"></a>01703     <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l01704"></a>01704       (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01705"></a>01705     gj=g+((u0+l0)*n1+(u1+l1))*n2;
<a name="l01706"></a>01706     <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l01707"></a>01707       (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01708"></a>01708         }
<a name="l01709"></a>01709     }
<a name="l01710"></a>01710     <span class="keywordflow">else</span><span class="comment">/* asserts (u1&gt;o1)*/</span>
<a name="l01711"></a>01711       <span class="keywordflow">if</span>(u2&lt;o2)
<a name="l01712"></a>01712   <span class="keywordflow">for</span>(l0=0; l0&lt;=2*m+1; l0++,psij0++)
<a name="l01713"></a>01713     {
<a name="l01714"></a>01714       psij1=psij_const1;
<a name="l01715"></a>01715       <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++,psij1++)
<a name="l01716"></a>01716         {
<a name="l01717"></a>01717     psij2=psij_const2;
<a name="l01718"></a>01718     gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l01719"></a>01719     <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l01720"></a>01720       (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01721"></a>01721         }
<a name="l01722"></a>01722       <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++,psij1++)
<a name="l01723"></a>01723         {
<a name="l01724"></a>01724     psij2=psij_const2;
<a name="l01725"></a>01725     gj=g+((u0+l0)*n1+l1)*n2+u2;
<a name="l01726"></a>01726     <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l01727"></a>01727       (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01728"></a>01728         }
<a name="l01729"></a>01729     }
<a name="l01730"></a>01730       <span class="keywordflow">else</span><span class="comment">/* asserts (u2&gt;o2) */</span>
<a name="l01731"></a>01731   {
<a name="l01732"></a>01732     <span class="keywordflow">for</span>(l0=0; l0&lt;=2*m+1; l0++,psij0++)
<a name="l01733"></a>01733       {
<a name="l01734"></a>01734         psij1=psij_const1;
<a name="l01735"></a>01735         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++,psij1++)
<a name="l01736"></a>01736     {
<a name="l01737"></a>01737       psij2=psij_const2;
<a name="l01738"></a>01738       gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l01739"></a>01739       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l01740"></a>01740         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01741"></a>01741       gj=g+((u0+l0)*n1+(u1+l1))*n2;
<a name="l01742"></a>01742       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l01743"></a>01743         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01744"></a>01744     }
<a name="l01745"></a>01745         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++,psij1++)
<a name="l01746"></a>01746     {
<a name="l01747"></a>01747       psij2=psij_const2;
<a name="l01748"></a>01748       gj=g+((u0+l0)*n1+l1)*n2+u2;
<a name="l01749"></a>01749       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l01750"></a>01750         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01751"></a>01751       gj=g+((u0+l0)*n1+l1)*n2;
<a name="l01752"></a>01752       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l01753"></a>01753         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01754"></a>01754     }
<a name="l01755"></a>01755       }
<a name="l01756"></a>01756   }
<a name="l01757"></a>01757   <span class="keywordflow">else</span><span class="comment">/* asserts (u0&gt;o0) */</span>
<a name="l01758"></a>01758     <span class="keywordflow">if</span>(u1&lt;o1)
<a name="l01759"></a>01759       <span class="keywordflow">if</span>(u2&lt;o2)
<a name="l01760"></a>01760   {
<a name="l01761"></a>01761     <span class="keywordflow">for</span>(l0=0; l0&lt;2*m+1-o0; l0++,psij0++)
<a name="l01762"></a>01762       {
<a name="l01763"></a>01763         psij1=psij_const1;
<a name="l01764"></a>01764         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++,psij1++)
<a name="l01765"></a>01765     {
<a name="l01766"></a>01766       psij2=psij_const2;
<a name="l01767"></a>01767       gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l01768"></a>01768       <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l01769"></a>01769         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01770"></a>01770     }
<a name="l01771"></a>01771       }
<a name="l01772"></a>01772 
<a name="l01773"></a>01773     <span class="keywordflow">for</span>(l0=0; l0&lt;=o0; l0++,psij0++)
<a name="l01774"></a>01774       {
<a name="l01775"></a>01775         psij1=psij_const1;
<a name="l01776"></a>01776         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++,psij1++)
<a name="l01777"></a>01777     {
<a name="l01778"></a>01778       psij2=psij_const2;
<a name="l01779"></a>01779       gj=g+(l0*n1+(u1+l1))*n2+u2;
<a name="l01780"></a>01780       <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l01781"></a>01781         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01782"></a>01782     }
<a name="l01783"></a>01783       }
<a name="l01784"></a>01784   }
<a name="l01785"></a>01785       <span class="keywordflow">else</span><span class="comment">/* asserts (u2&gt;o2) */</span>
<a name="l01786"></a>01786   {
<a name="l01787"></a>01787     <span class="keywordflow">for</span>(l0=0; l0&lt;2*m+1-o0; l0++,psij0++)
<a name="l01788"></a>01788       {
<a name="l01789"></a>01789         psij1=psij_const1;
<a name="l01790"></a>01790         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++,psij1++)
<a name="l01791"></a>01791     {
<a name="l01792"></a>01792       psij2=psij_const2;
<a name="l01793"></a>01793       gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l01794"></a>01794       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l01795"></a>01795         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01796"></a>01796       gj=g+((u0+l0)*n1+(u1+l1))*n2;
<a name="l01797"></a>01797       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l01798"></a>01798         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01799"></a>01799     }
<a name="l01800"></a>01800       }
<a name="l01801"></a>01801 
<a name="l01802"></a>01802     <span class="keywordflow">for</span>(l0=0; l0&lt;=o0; l0++,psij0++)
<a name="l01803"></a>01803       {
<a name="l01804"></a>01804         psij1=psij_const1;
<a name="l01805"></a>01805         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++,psij1++)
<a name="l01806"></a>01806     {
<a name="l01807"></a>01807       psij2=psij_const2;
<a name="l01808"></a>01808       gj=g+(l0*n1+(u1+l1))*n2+u2;
<a name="l01809"></a>01809       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l01810"></a>01810         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01811"></a>01811       gj=g+(l0*n1+(u1+l1))*n2;
<a name="l01812"></a>01812       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l01813"></a>01813         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01814"></a>01814     }
<a name="l01815"></a>01815       }
<a name="l01816"></a>01816   }
<a name="l01817"></a>01817     <span class="keywordflow">else</span><span class="comment">/* asserts (u1&gt;o1) */</span>
<a name="l01818"></a>01818       <span class="keywordflow">if</span>(u2&lt;o2)
<a name="l01819"></a>01819   {
<a name="l01820"></a>01820     <span class="keywordflow">for</span>(l0=0; l0&lt;2*m+1-o0; l0++,psij0++)
<a name="l01821"></a>01821       {
<a name="l01822"></a>01822         psij1=psij_const1;
<a name="l01823"></a>01823         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++,psij1++)
<a name="l01824"></a>01824     {
<a name="l01825"></a>01825       psij2=psij_const2;
<a name="l01826"></a>01826       gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l01827"></a>01827       <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l01828"></a>01828         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01829"></a>01829     }
<a name="l01830"></a>01830         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++,psij1++)
<a name="l01831"></a>01831     {
<a name="l01832"></a>01832       psij2=psij_const2;
<a name="l01833"></a>01833       gj=g+((u0+l0)*n1+l1)*n2+u2;
<a name="l01834"></a>01834       <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l01835"></a>01835         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01836"></a>01836     }
<a name="l01837"></a>01837       }
<a name="l01838"></a>01838     <span class="keywordflow">for</span>(l0=0; l0&lt;=o0; l0++,psij0++)
<a name="l01839"></a>01839       {
<a name="l01840"></a>01840         psij1=psij_const1;
<a name="l01841"></a>01841         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++,psij1++)
<a name="l01842"></a>01842     {
<a name="l01843"></a>01843       psij2=psij_const2;
<a name="l01844"></a>01844       gj=g+(l0*n1+(u1+l1))*n2+u2;
<a name="l01845"></a>01845       <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l01846"></a>01846         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01847"></a>01847     }
<a name="l01848"></a>01848         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++,psij1++)
<a name="l01849"></a>01849     {
<a name="l01850"></a>01850       psij2=psij_const2;
<a name="l01851"></a>01851       gj=g+(l0*n1+l1)*n2+u2;
<a name="l01852"></a>01852       <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l01853"></a>01853         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01854"></a>01854     }
<a name="l01855"></a>01855       }
<a name="l01856"></a>01856   }
<a name="l01857"></a>01857       <span class="keywordflow">else</span><span class="comment">/* asserts (u2&gt;o2) */</span>
<a name="l01858"></a>01858   {
<a name="l01859"></a>01859     <span class="keywordflow">for</span>(l0=0; l0&lt;2*m+1-o0; l0++,psij0++)
<a name="l01860"></a>01860       {
<a name="l01861"></a>01861         psij1=psij_const1;
<a name="l01862"></a>01862         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++,psij1++)
<a name="l01863"></a>01863     {
<a name="l01864"></a>01864       psij2=psij_const2;
<a name="l01865"></a>01865       gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l01866"></a>01866       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l01867"></a>01867         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01868"></a>01868       gj=g+((u0+l0)*n1+(u1+l1))*n2;
<a name="l01869"></a>01869       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l01870"></a>01870         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01871"></a>01871     }
<a name="l01872"></a>01872         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++,psij1++)
<a name="l01873"></a>01873     {
<a name="l01874"></a>01874       psij2=psij_const2;
<a name="l01875"></a>01875       gj=g+((u0+l0)*n1+l1)*n2+u2;
<a name="l01876"></a>01876       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l01877"></a>01877         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01878"></a>01878       gj=g+((u0+l0)*n1+l1)*n2;
<a name="l01879"></a>01879       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l01880"></a>01880         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01881"></a>01881     }
<a name="l01882"></a>01882       }
<a name="l01883"></a>01883 
<a name="l01884"></a>01884     <span class="keywordflow">for</span>(l0=0; l0&lt;=o0; l0++,psij0++)
<a name="l01885"></a>01885       {
<a name="l01886"></a>01886         psij1=psij_const1;
<a name="l01887"></a>01887         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++,psij1++)
<a name="l01888"></a>01888     {
<a name="l01889"></a>01889       psij2=psij_const2;
<a name="l01890"></a>01890       gj=g+(l0*n1+(u1+l1))*n2+u2;
<a name="l01891"></a>01891       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l01892"></a>01892         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01893"></a>01893       gj=g+(l0*n1+(u1+l1))*n2;
<a name="l01894"></a>01894       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l01895"></a>01895         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01896"></a>01896     }
<a name="l01897"></a>01897         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++,psij1++)
<a name="l01898"></a>01898     {
<a name="l01899"></a>01899       psij2=psij_const2;
<a name="l01900"></a>01900       gj=g+(l0*n1+l1)*n2+u2;
<a name="l01901"></a>01901       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l01902"></a>01902         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01903"></a>01903       gj=g+(l0*n1+l1)*n2;
<a name="l01904"></a>01904       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l01905"></a>01905         (*fj) += (*psij0) * (*psij1) * (*psij2++) * (*gj++);
<a name="l01906"></a>01906     }
<a name="l01907"></a>01907       }
<a name="l01908"></a>01908   }
<a name="l01909"></a>01909 }
<a name="l01910"></a>01910 
<a name="l01911"></a>01911 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_adjoint_3d_compute(<span class="keyword">const</span> <span class="keywordtype">double</span> _Complex *fj, <span class="keywordtype">double</span> _Complex *g,
<a name="l01912"></a>01912             <span class="keyword">const</span> <span class="keywordtype">double</span> *psij_const0, <span class="keyword">const</span> <span class="keywordtype">double</span> *psij_const1, <span class="keyword">const</span> <span class="keywordtype">double</span> *psij_const2,
<a name="l01913"></a>01913             <span class="keyword">const</span> <span class="keywordtype">double</span> *xj0, <span class="keyword">const</span> <span class="keywordtype">double</span> *xj1, <span class="keyword">const</span> <span class="keywordtype">double</span> *xj2,
<a name="l01914"></a>01914             <span class="keyword">const</span> <span class="keywordtype">int</span> n0, <span class="keyword">const</span> <span class="keywordtype">int</span> n1, <span class="keyword">const</span> <span class="keywordtype">int</span> n2, <span class="keyword">const</span> <span class="keywordtype">int</span> m)
<a name="l01915"></a>01915 {
<a name="l01916"></a>01916   <span class="keywordtype">int</span> u0,o0,l0,u1,o1,l1,u2,o2,l2;
<a name="l01917"></a>01917   <span class="keywordtype">double</span> _Complex *gj;
<a name="l01918"></a>01918   <span class="keyword">const</span> <span class="keywordtype">double</span> *psij0,*psij1,*psij2;
<a name="l01919"></a>01919 
<a name="l01920"></a>01920   psij0=psij_const0;
<a name="l01921"></a>01921   psij1=psij_const1;
<a name="l01922"></a>01922   psij2=psij_const2;
<a name="l01923"></a>01923 
<a name="l01924"></a>01924   nfft_uo2(&amp;u0,&amp;o0,*xj0, n0, m);
<a name="l01925"></a>01925   nfft_uo2(&amp;u1,&amp;o1,*xj1, n1, m);
<a name="l01926"></a>01926   nfft_uo2(&amp;u2,&amp;o2,*xj2, n2, m);
<a name="l01927"></a>01927 
<a name="l01928"></a>01928   <span class="keywordflow">if</span>(u0&lt;o0)
<a name="l01929"></a>01929     <span class="keywordflow">if</span>(u1&lt;o1)
<a name="l01930"></a>01930       <span class="keywordflow">if</span>(u2&lt;o2)
<a name="l01931"></a>01931   <span class="keywordflow">for</span>(l0=0; l0&lt;=2*m+1; l0++,psij0++)
<a name="l01932"></a>01932     {
<a name="l01933"></a>01933       psij1=psij_const1;
<a name="l01934"></a>01934       <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++,psij1++)
<a name="l01935"></a>01935         {
<a name="l01936"></a>01936     psij2=psij_const2;
<a name="l01937"></a>01937     gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l01938"></a>01938     <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l01939"></a>01939       (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l01940"></a>01940         }
<a name="l01941"></a>01941     }
<a name="l01942"></a>01942       <span class="keywordflow">else</span><span class="comment">/* asserts (u2&gt;o2)*/</span>
<a name="l01943"></a>01943   <span class="keywordflow">for</span>(l0=0; l0&lt;=2*m+1; l0++,psij0++)
<a name="l01944"></a>01944     {
<a name="l01945"></a>01945       psij1=psij_const1;
<a name="l01946"></a>01946       <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++,psij1++)
<a name="l01947"></a>01947         {
<a name="l01948"></a>01948     psij2=psij_const2;
<a name="l01949"></a>01949     gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l01950"></a>01950     <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l01951"></a>01951       (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l01952"></a>01952     gj=g+((u0+l0)*n1+(u1+l1))*n2;
<a name="l01953"></a>01953     <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l01954"></a>01954       (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l01955"></a>01955         }
<a name="l01956"></a>01956     }
<a name="l01957"></a>01957     <span class="keywordflow">else</span><span class="comment">/* asserts (u1&gt;o1)*/</span>
<a name="l01958"></a>01958       <span class="keywordflow">if</span>(u2&lt;o2)
<a name="l01959"></a>01959   <span class="keywordflow">for</span>(l0=0; l0&lt;=2*m+1; l0++,psij0++)
<a name="l01960"></a>01960     {
<a name="l01961"></a>01961       psij1=psij_const1;
<a name="l01962"></a>01962       <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++,psij1++)
<a name="l01963"></a>01963         {
<a name="l01964"></a>01964     psij2=psij_const2;
<a name="l01965"></a>01965     gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l01966"></a>01966     <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l01967"></a>01967       (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l01968"></a>01968         }
<a name="l01969"></a>01969       <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++,psij1++)
<a name="l01970"></a>01970         {
<a name="l01971"></a>01971     psij2=psij_const2;
<a name="l01972"></a>01972     gj=g+((u0+l0)*n1+l1)*n2+u2;
<a name="l01973"></a>01973     <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l01974"></a>01974       (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l01975"></a>01975         }
<a name="l01976"></a>01976     }
<a name="l01977"></a>01977       <span class="keywordflow">else</span><span class="comment">/* asserts (u2&gt;o2) */</span>
<a name="l01978"></a>01978   {
<a name="l01979"></a>01979     <span class="keywordflow">for</span>(l0=0; l0&lt;=2*m+1; l0++,psij0++)
<a name="l01980"></a>01980       {
<a name="l01981"></a>01981         psij1=psij_const1;
<a name="l01982"></a>01982         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++,psij1++)
<a name="l01983"></a>01983     {
<a name="l01984"></a>01984       psij2=psij_const2;
<a name="l01985"></a>01985       gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l01986"></a>01986       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l01987"></a>01987         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l01988"></a>01988       gj=g+((u0+l0)*n1+(u1+l1))*n2;
<a name="l01989"></a>01989       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l01990"></a>01990         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l01991"></a>01991     }
<a name="l01992"></a>01992         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++,psij1++)
<a name="l01993"></a>01993     {
<a name="l01994"></a>01994       psij2=psij_const2;
<a name="l01995"></a>01995       gj=g+((u0+l0)*n1+l1)*n2+u2;
<a name="l01996"></a>01996       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l01997"></a>01997         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l01998"></a>01998       gj=g+((u0+l0)*n1+l1)*n2;
<a name="l01999"></a>01999       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l02000"></a>02000         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02001"></a>02001     }
<a name="l02002"></a>02002       }
<a name="l02003"></a>02003   }
<a name="l02004"></a>02004   <span class="keywordflow">else</span><span class="comment">/* asserts (u0&gt;o0) */</span>
<a name="l02005"></a>02005     <span class="keywordflow">if</span>(u1&lt;o1)
<a name="l02006"></a>02006       <span class="keywordflow">if</span>(u2&lt;o2)
<a name="l02007"></a>02007   {
<a name="l02008"></a>02008     <span class="keywordflow">for</span>(l0=0; l0&lt;2*m+1-o0; l0++,psij0++)
<a name="l02009"></a>02009       {
<a name="l02010"></a>02010         psij1=psij_const1;
<a name="l02011"></a>02011         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++,psij1++)
<a name="l02012"></a>02012     {
<a name="l02013"></a>02013       psij2=psij_const2;
<a name="l02014"></a>02014       gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l02015"></a>02015       <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l02016"></a>02016         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02017"></a>02017     }
<a name="l02018"></a>02018       }
<a name="l02019"></a>02019 
<a name="l02020"></a>02020     <span class="keywordflow">for</span>(l0=0; l0&lt;=o0; l0++,psij0++)
<a name="l02021"></a>02021       {
<a name="l02022"></a>02022         psij1=psij_const1;
<a name="l02023"></a>02023         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++,psij1++)
<a name="l02024"></a>02024     {
<a name="l02025"></a>02025       psij2=psij_const2;
<a name="l02026"></a>02026       gj=g+(l0*n1+(u1+l1))*n2+u2;
<a name="l02027"></a>02027       <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l02028"></a>02028         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02029"></a>02029     }
<a name="l02030"></a>02030       }
<a name="l02031"></a>02031   }
<a name="l02032"></a>02032       <span class="keywordflow">else</span><span class="comment">/* asserts (u2&gt;o2) */</span>
<a name="l02033"></a>02033   {
<a name="l02034"></a>02034     <span class="keywordflow">for</span>(l0=0; l0&lt;2*m+1-o0; l0++,psij0++)
<a name="l02035"></a>02035       {
<a name="l02036"></a>02036         psij1=psij_const1;
<a name="l02037"></a>02037         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++,psij1++)
<a name="l02038"></a>02038     {
<a name="l02039"></a>02039       psij2=psij_const2;
<a name="l02040"></a>02040       gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l02041"></a>02041       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l02042"></a>02042         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02043"></a>02043       gj=g+((u0+l0)*n1+(u1+l1))*n2;
<a name="l02044"></a>02044       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l02045"></a>02045         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02046"></a>02046     }
<a name="l02047"></a>02047       }
<a name="l02048"></a>02048 
<a name="l02049"></a>02049     <span class="keywordflow">for</span>(l0=0; l0&lt;=o0; l0++,psij0++)
<a name="l02050"></a>02050       {
<a name="l02051"></a>02051         psij1=psij_const1;
<a name="l02052"></a>02052         <span class="keywordflow">for</span>(l1=0; l1&lt;=2*m+1; l1++,psij1++)
<a name="l02053"></a>02053     {
<a name="l02054"></a>02054       psij2=psij_const2;
<a name="l02055"></a>02055       gj=g+(l0*n1+(u1+l1))*n2+u2;
<a name="l02056"></a>02056       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l02057"></a>02057         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02058"></a>02058       gj=g+(l0*n1+(u1+l1))*n2;
<a name="l02059"></a>02059       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l02060"></a>02060         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02061"></a>02061     }
<a name="l02062"></a>02062       }
<a name="l02063"></a>02063   }
<a name="l02064"></a>02064     <span class="keywordflow">else</span><span class="comment">/* asserts (u1&gt;o1) */</span>
<a name="l02065"></a>02065       <span class="keywordflow">if</span>(u2&lt;o2)
<a name="l02066"></a>02066   {
<a name="l02067"></a>02067     <span class="keywordflow">for</span>(l0=0; l0&lt;2*m+1-o0; l0++,psij0++)
<a name="l02068"></a>02068       {
<a name="l02069"></a>02069         psij1=psij_const1;
<a name="l02070"></a>02070         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++,psij1++)
<a name="l02071"></a>02071     {
<a name="l02072"></a>02072       psij2=psij_const2;
<a name="l02073"></a>02073       gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l02074"></a>02074       <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l02075"></a>02075         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02076"></a>02076     }
<a name="l02077"></a>02077         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++,psij1++)
<a name="l02078"></a>02078     {
<a name="l02079"></a>02079       psij2=psij_const2;
<a name="l02080"></a>02080       gj=g+((u0+l0)*n1+l1)*n2+u2;
<a name="l02081"></a>02081       <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l02082"></a>02082         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02083"></a>02083     }
<a name="l02084"></a>02084       }
<a name="l02085"></a>02085     <span class="keywordflow">for</span>(l0=0; l0&lt;=o0; l0++,psij0++)
<a name="l02086"></a>02086       {
<a name="l02087"></a>02087         psij1=psij_const1;
<a name="l02088"></a>02088         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++,psij1++)
<a name="l02089"></a>02089     {
<a name="l02090"></a>02090       psij2=psij_const2;
<a name="l02091"></a>02091       gj=g+(l0*n1+(u1+l1))*n2+u2;
<a name="l02092"></a>02092       <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l02093"></a>02093         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02094"></a>02094     }
<a name="l02095"></a>02095         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++,psij1++)
<a name="l02096"></a>02096     {
<a name="l02097"></a>02097       psij2=psij_const2;
<a name="l02098"></a>02098       gj=g+(l0*n1+l1)*n2+u2;
<a name="l02099"></a>02099       <span class="keywordflow">for</span>(l2=0; l2&lt;=2*m+1; l2++)
<a name="l02100"></a>02100         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02101"></a>02101     }
<a name="l02102"></a>02102       }
<a name="l02103"></a>02103   }
<a name="l02104"></a>02104       <span class="keywordflow">else</span><span class="comment">/* asserts (u2&gt;o2) */</span>
<a name="l02105"></a>02105   {
<a name="l02106"></a>02106     <span class="keywordflow">for</span>(l0=0; l0&lt;2*m+1-o0; l0++,psij0++)
<a name="l02107"></a>02107       {
<a name="l02108"></a>02108         psij1=psij_const1;
<a name="l02109"></a>02109         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++,psij1++)
<a name="l02110"></a>02110     {
<a name="l02111"></a>02111       psij2=psij_const2;
<a name="l02112"></a>02112       gj=g+((u0+l0)*n1+(u1+l1))*n2+u2;
<a name="l02113"></a>02113       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l02114"></a>02114         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02115"></a>02115       gj=g+((u0+l0)*n1+(u1+l1))*n2;
<a name="l02116"></a>02116       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l02117"></a>02117         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02118"></a>02118     }
<a name="l02119"></a>02119         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++,psij1++)
<a name="l02120"></a>02120     {
<a name="l02121"></a>02121       psij2=psij_const2;
<a name="l02122"></a>02122       gj=g+((u0+l0)*n1+l1)*n2+u2;
<a name="l02123"></a>02123       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l02124"></a>02124         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02125"></a>02125       gj=g+((u0+l0)*n1+l1)*n2;
<a name="l02126"></a>02126       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l02127"></a>02127         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02128"></a>02128     }
<a name="l02129"></a>02129       }
<a name="l02130"></a>02130 
<a name="l02131"></a>02131     <span class="keywordflow">for</span>(l0=0; l0&lt;=o0; l0++,psij0++)
<a name="l02132"></a>02132       {
<a name="l02133"></a>02133         psij1=psij_const1;
<a name="l02134"></a>02134         <span class="keywordflow">for</span>(l1=0; l1&lt;2*m+1-o1; l1++,psij1++)
<a name="l02135"></a>02135     {
<a name="l02136"></a>02136       psij2=psij_const2;
<a name="l02137"></a>02137       gj=g+(l0*n1+(u1+l1))*n2+u2;
<a name="l02138"></a>02138       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l02139"></a>02139         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02140"></a>02140       gj=g+(l0*n1+(u1+l1))*n2;
<a name="l02141"></a>02141       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l02142"></a>02142         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02143"></a>02143     }
<a name="l02144"></a>02144         <span class="keywordflow">for</span>(l1=0; l1&lt;=o1; l1++,psij1++)
<a name="l02145"></a>02145     {
<a name="l02146"></a>02146       psij2=psij_const2;
<a name="l02147"></a>02147       gj=g+(l0*n1+l1)*n2+u2;
<a name="l02148"></a>02148       <span class="keywordflow">for</span>(l2=0; l2&lt;2*m+1-o2; l2++)
<a name="l02149"></a>02149         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02150"></a>02150       gj=g+(l0*n1+l1)*n2;
<a name="l02151"></a>02151       <span class="keywordflow">for</span>(l2=0; l2&lt;=o2; l2++)
<a name="l02152"></a>02152         (*gj++) += (*psij0) * (*psij1) * (*psij2++) * (*fj);
<a name="l02153"></a>02153     }
<a name="l02154"></a>02154       }
<a name="l02155"></a>02155   }
<a name="l02156"></a>02156 }
<a name="l02157"></a>02157 
<a name="l02158"></a>02158 
<a name="l02159"></a>02159 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_trafo_3d_B(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02160"></a>02160 {
<a name="l02161"></a>02161   <span class="keywordtype">int</span> n0,N0,n1,N1,n2,N2,u,o,j,M,l,m, *psi_index_g,K,ip_s,ip_u;
<a name="l02162"></a>02162   <span class="keywordtype">double</span> _Complex *fj,*g;
<a name="l02163"></a>02163   <span class="keywordtype">double</span> *psij, *psij_const, *xj, ip_y, ip_w;
<a name="l02164"></a>02164 
<a name="l02165"></a>02165   <span class="keywordtype">double</span> *fg_exp_l, fg_psij0, fg_psij1, fg_psij2;
<a name="l02166"></a>02166 
<a name="l02167"></a>02167   N0=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[0];
<a name="l02168"></a>02168   n0=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[0];
<a name="l02169"></a>02169   N1=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[1];
<a name="l02170"></a>02170   n1=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[1];
<a name="l02171"></a>02171   N2=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[2];
<a name="l02172"></a>02172   n2=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[2];
<a name="l02173"></a>02173   M=ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>;
<a name="l02174"></a>02174   m=ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>;
<a name="l02175"></a>02175 
<a name="l02176"></a>02176   g=ths-&gt;<a class="code" href="structnfft__plan.html#844b51e453d6c80462eaad7844633539" title="Oversampled vector of samples, size is n_total double complex.">g</a>;
<a name="l02177"></a>02177 
<a name="l02178"></a>02178   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g7ad8a7e19519b16340dabec48899c6a4" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FULL_PSI</a>)
<a name="l02179"></a>02179     {
<a name="l02180"></a>02180       psi_index_g=ths-&gt;<a class="code" href="structnfft__plan.html#877d6cbe17ec77a9e66bdbea3cfafe0a" title="Indices in source/target vector for PRE_FULL_PSI.">psi_index_g</a>;
<a name="l02181"></a>02181       <span class="keywordflow">for</span>(j=0, fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>, psij=ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>; j&lt;M; j++, fj++)
<a name="l02182"></a>02182         <span class="keywordflow">for</span>(l=1, (*fj)=(*psij++) * g[(*psi_index_g++)]; l&lt;(2*m+2)*(2*m+2)*(2*m+2); l++)
<a name="l02183"></a>02183     (*fj) += (*psij++) * g[(*psi_index_g++)];
<a name="l02184"></a>02184       <span class="keywordflow">return</span>;
<a name="l02185"></a>02185     } <span class="comment">/* if(PRE_FULL_PSI) */</span>
<a name="l02186"></a>02186 
<a name="l02187"></a>02187   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g959463a5c7723ccef5057ddcb784b40c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_PSI</a>)
<a name="l02188"></a>02188     {
<a name="l02189"></a>02189       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>; j&lt;M; j++,fj++,xj+=3)
<a name="l02190"></a>02190   nfft_trafo_3d_compute(fj, g, ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>+j*3*(2*m+2), ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>+(j*3+1)*(2*m+2), ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>+(j*3+2)*(2*m+2), xj, xj+1, xj+2, n0, n1, n2, m);
<a name="l02191"></a>02191       <span class="keywordflow">return</span>;
<a name="l02192"></a>02192     } <span class="comment">/* if(PRE_PSI) */</span>
<a name="l02193"></a>02193 
<a name="l02194"></a>02194   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g9c5a5ab61009a801082897ca40a1658c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FG_PSI</a>)
<a name="l02195"></a>02195     {
<a name="l02196"></a>02196       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(3*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l02197"></a>02197       fg_exp_l=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(3*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l02198"></a>02198 
<a name="l02199"></a>02199       nfft_3d_init_fg_exp_l(fg_exp_l, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l02200"></a>02200       nfft_3d_init_fg_exp_l(fg_exp_l+2*m+2, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[1]);
<a name="l02201"></a>02201       nfft_3d_init_fg_exp_l(fg_exp_l+2*(2*m+2), m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[2]);
<a name="l02202"></a>02202 
<a name="l02203"></a>02203       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=3)
<a name="l02204"></a>02204   {
<a name="l02205"></a>02205     fg_psij0 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*j*3];
<a name="l02206"></a>02206     fg_psij1 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*j*3+1];
<a name="l02207"></a>02207     fg_psij2 = 1.0;
<a name="l02208"></a>02208     psij_const[0] = fg_psij0;
<a name="l02209"></a>02209     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l02210"></a>02210       {
<a name="l02211"></a>02211         fg_psij2 *= fg_psij1;
<a name="l02212"></a>02212         psij_const[l] = fg_psij0*fg_psij2*fg_exp_l[l];
<a name="l02213"></a>02213       }
<a name="l02214"></a>02214 
<a name="l02215"></a>02215     fg_psij0 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*3+1)];
<a name="l02216"></a>02216     fg_psij1 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*3+1)+1];
<a name="l02217"></a>02217     fg_psij2 = 1.0;
<a name="l02218"></a>02218     psij_const[2*m+2] = fg_psij0;
<a name="l02219"></a>02219     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l02220"></a>02220       {
<a name="l02221"></a>02221         fg_psij2 *= fg_psij1;
<a name="l02222"></a>02222         psij_const[2*m+2+l] = fg_psij0*fg_psij2*fg_exp_l[2*m+2+l];
<a name="l02223"></a>02223       }
<a name="l02224"></a>02224 
<a name="l02225"></a>02225     fg_psij0 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*3+2)];
<a name="l02226"></a>02226     fg_psij1 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*3+2)+1];
<a name="l02227"></a>02227     fg_psij2 = 1.0;
<a name="l02228"></a>02228     psij_const[2*(2*m+2)] = fg_psij0;
<a name="l02229"></a>02229     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l02230"></a>02230       {
<a name="l02231"></a>02231         fg_psij2 *= fg_psij1;
<a name="l02232"></a>02232         psij_const[2*(2*m+2)+l] = fg_psij0*fg_psij2*fg_exp_l[2*(2*m+2)+l];
<a name="l02233"></a>02233       }
<a name="l02234"></a>02234 
<a name="l02235"></a>02235     nfft_trafo_3d_compute(fj, g, psij_const, psij_const+2*m+2, psij_const+(2*m+2)*2, xj, xj+1, xj+2, n0, n1, n2, m);
<a name="l02236"></a>02236   }
<a name="l02237"></a>02237       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(fg_exp_l);
<a name="l02238"></a>02238       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l02239"></a>02239       <span class="keywordflow">return</span>;
<a name="l02240"></a>02240     } <span class="comment">/* if(PRE_FG_PSI) */</span>
<a name="l02241"></a>02241 
<a name="l02242"></a>02242   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g01ebac2d2071639df189f083fc9f24eb" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">FG_PSI</a>)
<a name="l02243"></a>02243     {
<a name="l02244"></a>02244       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(3*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l02245"></a>02245       fg_exp_l=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(3*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l02246"></a>02246 
<a name="l02247"></a>02247       nfft_3d_init_fg_exp_l(fg_exp_l, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l02248"></a>02248       nfft_3d_init_fg_exp_l(fg_exp_l+2*m+2, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[1]);
<a name="l02249"></a>02249       nfft_3d_init_fg_exp_l(fg_exp_l+2*(2*m+2), m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[2]);
<a name="l02250"></a>02250 
<a name="l02251"></a>02251       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=3)
<a name="l02252"></a>02252   {
<a name="l02253"></a>02253     nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l02254"></a>02254     fg_psij0 = (PHI(*xj-((<span class="keywordtype">double</span>)u)/n0,0));
<a name="l02255"></a>02255     fg_psij1 = exp(2.0*(n0*(*xj) - u)/ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l02256"></a>02256     fg_psij2 = 1.0;
<a name="l02257"></a>02257     psij_const[0] = fg_psij0;
<a name="l02258"></a>02258     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l02259"></a>02259       {
<a name="l02260"></a>02260         fg_psij2 *= fg_psij1;
<a name="l02261"></a>02261         psij_const[l] = fg_psij0*fg_psij2*fg_exp_l[l];
<a name="l02262"></a>02262       }
<a name="l02263"></a>02263 
<a name="l02264"></a>02264     nfft_uo(ths,j,&amp;u,&amp;o,1);
<a name="l02265"></a>02265     fg_psij0 = (PHI(*(xj+1)-((<span class="keywordtype">double</span>)u)/n1,1));
<a name="l02266"></a>02266     fg_psij1 = exp(2.0*(n1*(*(xj+1)) - u)/ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[1]);
<a name="l02267"></a>02267     fg_psij2 = 1.0;
<a name="l02268"></a>02268     psij_const[2*m+2] = fg_psij0;
<a name="l02269"></a>02269     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l02270"></a>02270       {
<a name="l02271"></a>02271         fg_psij2 *= fg_psij1;
<a name="l02272"></a>02272         psij_const[2*m+2+l] = fg_psij0*fg_psij2*fg_exp_l[2*m+2+l];
<a name="l02273"></a>02273       }
<a name="l02274"></a>02274 
<a name="l02275"></a>02275     nfft_uo(ths,j,&amp;u,&amp;o,2);
<a name="l02276"></a>02276     fg_psij0 = (PHI(*(xj+2)-((<span class="keywordtype">double</span>)u)/n2,2));
<a name="l02277"></a>02277     fg_psij1 = exp(2.0*(n2*(*(xj+2)) - u)/ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[2]);
<a name="l02278"></a>02278     fg_psij2 = 1.0;
<a name="l02279"></a>02279     psij_const[2*(2*m+2)] = fg_psij0;
<a name="l02280"></a>02280     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l02281"></a>02281       {
<a name="l02282"></a>02282         fg_psij2 *= fg_psij1;
<a name="l02283"></a>02283         psij_const[2*(2*m+2)+l] = fg_psij0*fg_psij2*fg_exp_l[2*(2*m+2)+l];
<a name="l02284"></a>02284       }
<a name="l02285"></a>02285 
<a name="l02286"></a>02286     nfft_trafo_3d_compute(fj, g, psij_const, psij_const+2*m+2, psij_const+(2*m+2)*2, xj, xj+1, xj+2, n0, n1, n2, m);
<a name="l02287"></a>02287   }
<a name="l02288"></a>02288       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(fg_exp_l);
<a name="l02289"></a>02289       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l02290"></a>02290       <span class="keywordflow">return</span>;
<a name="l02291"></a>02291     } <span class="comment">/* if(FG_PSI) */</span>
<a name="l02292"></a>02292 
<a name="l02293"></a>02293   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#gbb1ad048b695cb806baf010c5d1b2caf" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_LIN_PSI</a>)
<a name="l02294"></a>02294     {
<a name="l02295"></a>02295       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(3*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l02296"></a>02296       K=ths-&gt;<a class="code" href="structnfft__plan.html#0b3735bcdd415a86126e0c86d47941a4" title="Number of equispaced samples of the window function for PRE_LIN_PSI.">K</a>;
<a name="l02297"></a>02297       ip_s=K/(m+2);
<a name="l02298"></a>02298 
<a name="l02299"></a>02299       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=3)
<a name="l02300"></a>02300   {
<a name="l02301"></a>02301     nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l02302"></a>02302     ip_y = fabs(n0*(*(xj+0)) - u)*((double)ip_s);
<a name="l02303"></a>02303     ip_u = LRINT(floor(ip_y));
<a name="l02304"></a>02304     ip_w = ip_y-ip_u;
<a name="l02305"></a>02305     <span class="keywordflow">for</span>(l=0; l &lt; 2*m+2; l++)
<a name="l02306"></a>02306       psij_const[l] = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[abs(ip_u-l*ip_s)]*(1.0-ip_w) +
<a name="l02307"></a>02307         ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[abs(ip_u-l*ip_s+1)]*(ip_w);
<a name="l02308"></a>02308 
<a name="l02309"></a>02309     nfft_uo(ths,j,&amp;u,&amp;o,1);
<a name="l02310"></a>02310     ip_y = fabs(n1*(*(xj+1)) - u)*((double)ip_s);
<a name="l02311"></a>02311     ip_u = LRINT(floor(ip_y));
<a name="l02312"></a>02312     ip_w = ip_y-ip_u;
<a name="l02313"></a>02313     <span class="keywordflow">for</span>(l=0; l &lt; 2*m+2; l++)
<a name="l02314"></a>02314       psij_const[2*m+2+l] = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[(K+1)+abs(ip_u-l*ip_s)]*(1.0-ip_w) +
<a name="l02315"></a>02315         ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[(K+1)+abs(ip_u-l*ip_s+1)]*(ip_w);
<a name="l02316"></a>02316 
<a name="l02317"></a>02317     nfft_uo(ths,j,&amp;u,&amp;o,2);
<a name="l02318"></a>02318     ip_y = fabs(n2*(*(xj+2)) - u)*((double)ip_s);
<a name="l02319"></a>02319     ip_u = LRINT(floor(ip_y));
<a name="l02320"></a>02320     ip_w = ip_y-ip_u;
<a name="l02321"></a>02321     <span class="keywordflow">for</span>(l=0; l &lt; 2*m+2; l++)
<a name="l02322"></a>02322       psij_const[2*(2*m+2)+l] = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(K+1)+abs(ip_u-l*ip_s)]*(1.0-ip_w) +
<a name="l02323"></a>02323         ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(K+1)+abs(ip_u-l*ip_s+1)]*(ip_w);
<a name="l02324"></a>02324 
<a name="l02325"></a>02325     nfft_trafo_3d_compute(fj, g, psij_const, psij_const+2*m+2, psij_const+(2*m+2)*2, xj, xj+1, xj+2, n0, n1, n2, m);
<a name="l02326"></a>02326   }
<a name="l02327"></a>02327       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l02328"></a>02328       <span class="keywordflow">return</span>;
<a name="l02329"></a>02329     } <span class="comment">/* if(PRE_LIN_PSI) */</span>
<a name="l02330"></a>02330 
<a name="l02331"></a>02331   <span class="comment">/* no precomputed psi at all */</span>
<a name="l02332"></a>02332   psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(3*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l02333"></a>02333   <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=3)
<a name="l02334"></a>02334     {
<a name="l02335"></a>02335       nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l02336"></a>02336       <span class="keywordflow">for</span>(l=0;l&lt;=2*m+1;l++)
<a name="l02337"></a>02337   psij_const[l]=(PHI(*xj-((<span class="keywordtype">double</span>)((u+l)))/n0,0));
<a name="l02338"></a>02338 
<a name="l02339"></a>02339       nfft_uo(ths,j,&amp;u,&amp;o,1);
<a name="l02340"></a>02340       <span class="keywordflow">for</span>(l=0;l&lt;=2*m+1;l++)
<a name="l02341"></a>02341   psij_const[2*m+2+l]=(PHI(*(xj+1)-((<span class="keywordtype">double</span>)((u+l)))/n1,1));
<a name="l02342"></a>02342 
<a name="l02343"></a>02343       nfft_uo(ths,j,&amp;u,&amp;o,2);
<a name="l02344"></a>02344       <span class="keywordflow">for</span>(l=0;l&lt;=2*m+1;l++)
<a name="l02345"></a>02345   psij_const[2*(2*m+2)+l]=(PHI(*(xj+2)-((<span class="keywordtype">double</span>)((u+l)))/n2,2));
<a name="l02346"></a>02346 
<a name="l02347"></a>02347       nfft_trafo_3d_compute(fj, g, psij_const, psij_const+2*m+2, psij_const+(2*m+2)*2, xj, xj+1, xj+2, n0, n1, n2, m);
<a name="l02348"></a>02348     }
<a name="l02349"></a>02349   <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l02350"></a>02350 }
<a name="l02351"></a>02351 
<a name="l02352"></a>02352 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_adjoint_3d_B(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02353"></a>02353 {
<a name="l02354"></a>02354   <span class="keywordtype">int</span> n0,N0,n1,N1,n2,N2,u,o,j,M,l,m, *psi_index_g,K,ip_s,ip_u;
<a name="l02355"></a>02355   <span class="keywordtype">double</span> _Complex *fj,*g;
<a name="l02356"></a>02356   <span class="keywordtype">double</span> *psij, *psij_const, *xj, ip_y, ip_w;
<a name="l02357"></a>02357 
<a name="l02358"></a>02358   <span class="keywordtype">double</span> *fg_exp_l, fg_psij0, fg_psij1, fg_psij2;
<a name="l02359"></a>02359 
<a name="l02360"></a>02360   N0=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[0];
<a name="l02361"></a>02361   n0=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[0];
<a name="l02362"></a>02362   N1=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[1];
<a name="l02363"></a>02363   n1=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[1];
<a name="l02364"></a>02364   N2=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[2];
<a name="l02365"></a>02365   n2=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[2];
<a name="l02366"></a>02366   M=ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>;
<a name="l02367"></a>02367   m=ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>;
<a name="l02368"></a>02368 
<a name="l02369"></a>02369   g=ths-&gt;<a class="code" href="structnfft__plan.html#844b51e453d6c80462eaad7844633539" title="Oversampled vector of samples, size is n_total double complex.">g</a>;
<a name="l02370"></a>02370   memset(g,0,ths-&gt;<a class="code" href="structnfft__plan.html#d8a5fdac5bcf62d86479c800768fdeb7" title="Total size of FFTW.">n_total</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> _Complex));
<a name="l02371"></a>02371 
<a name="l02372"></a>02372   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g7ad8a7e19519b16340dabec48899c6a4" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FULL_PSI</a>)
<a name="l02373"></a>02373     {
<a name="l02374"></a>02374       psi_index_g=ths-&gt;<a class="code" href="structnfft__plan.html#877d6cbe17ec77a9e66bdbea3cfafe0a" title="Indices in source/target vector for PRE_FULL_PSI.">psi_index_g</a>;
<a name="l02375"></a>02375       <span class="keywordflow">for</span>(j=0, fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>, psij=ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>; j&lt;M; j++, fj++)
<a name="l02376"></a>02376         <span class="keywordflow">for</span>(l=0; l&lt;(2*m+2)*(2*m+2)*(2*m+2); l++)
<a name="l02377"></a>02377     g[(*psi_index_g++)] += (*psij++) * (*fj);
<a name="l02378"></a>02378       <span class="keywordflow">return</span>;
<a name="l02379"></a>02379     } <span class="comment">/* if(PRE_FULL_PSI) */</span>
<a name="l02380"></a>02380 
<a name="l02381"></a>02381   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g959463a5c7723ccef5057ddcb784b40c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_PSI</a>)
<a name="l02382"></a>02382     {
<a name="l02383"></a>02383       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>; j&lt;M; j++,fj++,xj+=3)
<a name="l02384"></a>02384   nfft_adjoint_3d_compute(fj, g, ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>+j*3*(2*m+2), ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>+(j*3+1)*(2*m+2), ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>+(j*3+2)*(2*m+2), xj, xj+1, xj+2, n0, n1, n2, m);
<a name="l02385"></a>02385       <span class="keywordflow">return</span>;
<a name="l02386"></a>02386     } <span class="comment">/* if(PRE_PSI) */</span>
<a name="l02387"></a>02387 
<a name="l02388"></a>02388   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g9c5a5ab61009a801082897ca40a1658c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FG_PSI</a>)
<a name="l02389"></a>02389     {
<a name="l02390"></a>02390       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(3*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l02391"></a>02391       fg_exp_l=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(3*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l02392"></a>02392 
<a name="l02393"></a>02393       nfft_3d_init_fg_exp_l(fg_exp_l, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l02394"></a>02394       nfft_3d_init_fg_exp_l(fg_exp_l+2*m+2, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[1]);
<a name="l02395"></a>02395       nfft_3d_init_fg_exp_l(fg_exp_l+2*(2*m+2), m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[2]);
<a name="l02396"></a>02396 
<a name="l02397"></a>02397       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=3)
<a name="l02398"></a>02398   {
<a name="l02399"></a>02399     fg_psij0 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*j*3];
<a name="l02400"></a>02400     fg_psij1 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*j*3+1];
<a name="l02401"></a>02401     fg_psij2 = 1.0;
<a name="l02402"></a>02402     psij_const[0] = fg_psij0;
<a name="l02403"></a>02403     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l02404"></a>02404       {
<a name="l02405"></a>02405         fg_psij2 *= fg_psij1;
<a name="l02406"></a>02406         psij_const[l] = fg_psij0*fg_psij2*fg_exp_l[l];
<a name="l02407"></a>02407       }
<a name="l02408"></a>02408 
<a name="l02409"></a>02409     fg_psij0 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*3+1)];
<a name="l02410"></a>02410     fg_psij1 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*3+1)+1];
<a name="l02411"></a>02411     fg_psij2 = 1.0;
<a name="l02412"></a>02412     psij_const[2*m+2] = fg_psij0;
<a name="l02413"></a>02413     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l02414"></a>02414       {
<a name="l02415"></a>02415         fg_psij2 *= fg_psij1;
<a name="l02416"></a>02416         psij_const[2*m+2+l] = fg_psij0*fg_psij2*fg_exp_l[2*m+2+l];
<a name="l02417"></a>02417       }
<a name="l02418"></a>02418 
<a name="l02419"></a>02419     fg_psij0 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*3+2)];
<a name="l02420"></a>02420     fg_psij1 = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*3+2)+1];
<a name="l02421"></a>02421     fg_psij2 = 1.0;
<a name="l02422"></a>02422     psij_const[2*(2*m+2)] = fg_psij0;
<a name="l02423"></a>02423     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l02424"></a>02424       {
<a name="l02425"></a>02425         fg_psij2 *= fg_psij1;
<a name="l02426"></a>02426         psij_const[2*(2*m+2)+l] = fg_psij0*fg_psij2*fg_exp_l[2*(2*m+2)+l];
<a name="l02427"></a>02427       }
<a name="l02428"></a>02428 
<a name="l02429"></a>02429     nfft_adjoint_3d_compute(fj, g, psij_const, psij_const+2*m+2, psij_const+(2*m+2)*2, xj, xj+1, xj+2, n0, n1, n2, m);
<a name="l02430"></a>02430   }
<a name="l02431"></a>02431       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(fg_exp_l);
<a name="l02432"></a>02432       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l02433"></a>02433       <span class="keywordflow">return</span>;
<a name="l02434"></a>02434     } <span class="comment">/* if(PRE_FG_PSI) */</span>
<a name="l02435"></a>02435 
<a name="l02436"></a>02436   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g01ebac2d2071639df189f083fc9f24eb" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">FG_PSI</a>)
<a name="l02437"></a>02437     {
<a name="l02438"></a>02438       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(3*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l02439"></a>02439       fg_exp_l=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(3*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l02440"></a>02440 
<a name="l02441"></a>02441       nfft_3d_init_fg_exp_l(fg_exp_l, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l02442"></a>02442       nfft_3d_init_fg_exp_l(fg_exp_l+2*m+2, m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[1]);
<a name="l02443"></a>02443       nfft_3d_init_fg_exp_l(fg_exp_l+2*(2*m+2), m, ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[2]);
<a name="l02444"></a>02444 
<a name="l02445"></a>02445       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=3)
<a name="l02446"></a>02446   {
<a name="l02447"></a>02447     nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l02448"></a>02448     fg_psij0 = (PHI(*xj-((<span class="keywordtype">double</span>)u)/n0,0));
<a name="l02449"></a>02449     fg_psij1 = exp(2.0*(n0*(*xj) - u)/ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[0]);
<a name="l02450"></a>02450     fg_psij2 = 1.0;
<a name="l02451"></a>02451     psij_const[0] = fg_psij0;
<a name="l02452"></a>02452     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l02453"></a>02453       {
<a name="l02454"></a>02454         fg_psij2 *= fg_psij1;
<a name="l02455"></a>02455         psij_const[l] = fg_psij0*fg_psij2*fg_exp_l[l];
<a name="l02456"></a>02456       }
<a name="l02457"></a>02457 
<a name="l02458"></a>02458     nfft_uo(ths,j,&amp;u,&amp;o,1);
<a name="l02459"></a>02459     fg_psij0 = (PHI(*(xj+1)-((<span class="keywordtype">double</span>)u)/n1,1));
<a name="l02460"></a>02460     fg_psij1 = exp(2.0*(n1*(*(xj+1)) - u)/ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[1]);
<a name="l02461"></a>02461     fg_psij2 = 1.0;
<a name="l02462"></a>02462     psij_const[2*m+2] = fg_psij0;
<a name="l02463"></a>02463     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l02464"></a>02464       {
<a name="l02465"></a>02465         fg_psij2 *= fg_psij1;
<a name="l02466"></a>02466         psij_const[2*m+2+l] = fg_psij0*fg_psij2*fg_exp_l[2*m+2+l];
<a name="l02467"></a>02467       }
<a name="l02468"></a>02468 
<a name="l02469"></a>02469     nfft_uo(ths,j,&amp;u,&amp;o,2);
<a name="l02470"></a>02470     fg_psij0 = (PHI(*(xj+2)-((<span class="keywordtype">double</span>)u)/n2,2));
<a name="l02471"></a>02471     fg_psij1 = exp(2.0*(n2*(*(xj+2)) - u)/ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[2]);
<a name="l02472"></a>02472     fg_psij2 = 1.0;
<a name="l02473"></a>02473     psij_const[2*(2*m+2)] = fg_psij0;
<a name="l02474"></a>02474     <span class="keywordflow">for</span>(l=1; l&lt;=2*m+1; l++)
<a name="l02475"></a>02475       {
<a name="l02476"></a>02476         fg_psij2 *= fg_psij1;
<a name="l02477"></a>02477         psij_const[2*(2*m+2)+l] = fg_psij0*fg_psij2*fg_exp_l[2*(2*m+2)+l];
<a name="l02478"></a>02478       }
<a name="l02479"></a>02479 
<a name="l02480"></a>02480     nfft_adjoint_3d_compute(fj, g, psij_const, psij_const+2*m+2, psij_const+(2*m+2)*2, xj, xj+1, xj+2, n0, n1, n2, m);
<a name="l02481"></a>02481   }
<a name="l02482"></a>02482       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(fg_exp_l);
<a name="l02483"></a>02483       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l02484"></a>02484       <span class="keywordflow">return</span>;
<a name="l02485"></a>02485     } <span class="comment">/* if(FG_PSI) */</span>
<a name="l02486"></a>02486 
<a name="l02487"></a>02487   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#gbb1ad048b695cb806baf010c5d1b2caf" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_LIN_PSI</a>)
<a name="l02488"></a>02488     {
<a name="l02489"></a>02489       psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(3*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l02490"></a>02490       K=ths-&gt;<a class="code" href="structnfft__plan.html#0b3735bcdd415a86126e0c86d47941a4" title="Number of equispaced samples of the window function for PRE_LIN_PSI.">K</a>;
<a name="l02491"></a>02491       ip_s=K/(m+2);
<a name="l02492"></a>02492 
<a name="l02493"></a>02493       <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=3)
<a name="l02494"></a>02494   {
<a name="l02495"></a>02495     nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l02496"></a>02496     ip_y = fabs(n0*(*(xj+0)) - u)*((double)ip_s);
<a name="l02497"></a>02497     ip_u = LRINT(floor(ip_y));
<a name="l02498"></a>02498     ip_w = ip_y-ip_u;
<a name="l02499"></a>02499     <span class="keywordflow">for</span>(l=0; l &lt; 2*m+2; l++)
<a name="l02500"></a>02500       psij_const[l] = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[abs(ip_u-l*ip_s)]*(1.0-ip_w) +
<a name="l02501"></a>02501         ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[abs(ip_u-l*ip_s+1)]*(ip_w);
<a name="l02502"></a>02502 
<a name="l02503"></a>02503     nfft_uo(ths,j,&amp;u,&amp;o,1);
<a name="l02504"></a>02504     ip_y = fabs(n1*(*(xj+1)) - u)*((double)ip_s);
<a name="l02505"></a>02505     ip_u = LRINT(floor(ip_y));
<a name="l02506"></a>02506     ip_w = ip_y-ip_u;
<a name="l02507"></a>02507     <span class="keywordflow">for</span>(l=0; l &lt; 2*m+2; l++)
<a name="l02508"></a>02508       psij_const[2*m+2+l] = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[(K+1)+abs(ip_u-l*ip_s)]*(1.0-ip_w) +
<a name="l02509"></a>02509         ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[(K+1)+abs(ip_u-l*ip_s+1)]*(ip_w);
<a name="l02510"></a>02510 
<a name="l02511"></a>02511     nfft_uo(ths,j,&amp;u,&amp;o,2);
<a name="l02512"></a>02512     ip_y = fabs(n2*(*(xj+2)) - u)*((double)ip_s);
<a name="l02513"></a>02513     ip_u = LRINT(floor(ip_y));
<a name="l02514"></a>02514     ip_w = ip_y-ip_u;
<a name="l02515"></a>02515     <span class="keywordflow">for</span>(l=0; l &lt; 2*m+2; l++)
<a name="l02516"></a>02516       psij_const[2*(2*m+2)+l] = ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(K+1)+abs(ip_u-l*ip_s)]*(1.0-ip_w) +
<a name="l02517"></a>02517         ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(K+1)+abs(ip_u-l*ip_s+1)]*(ip_w);
<a name="l02518"></a>02518 
<a name="l02519"></a>02519     nfft_adjoint_3d_compute(fj, g, psij_const, psij_const+2*m+2, psij_const+(2*m+2)*2, xj, xj+1, xj+2, n0, n1, n2, m);
<a name="l02520"></a>02520   }
<a name="l02521"></a>02521       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l02522"></a>02522       <span class="keywordflow">return</span>;
<a name="l02523"></a>02523     } <span class="comment">/* if(PRE_LIN_PSI) */</span>
<a name="l02524"></a>02524 
<a name="l02525"></a>02525   <span class="comment">/* no precomputed psi at all */</span>
<a name="l02526"></a>02526   psij_const=(<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(3*(2*m+2)*<span class="keyword">sizeof</span>(double));
<a name="l02527"></a>02527   <span class="keywordflow">for</span>(j=0,fj=ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>,xj=ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>;j&lt;M;j++,fj++,xj+=3)
<a name="l02528"></a>02528     {
<a name="l02529"></a>02529       nfft_uo(ths,j,&amp;u,&amp;o,0);
<a name="l02530"></a>02530       <span class="keywordflow">for</span>(l=0;l&lt;=2*m+1;l++)
<a name="l02531"></a>02531   psij_const[l]=(PHI(*xj-((<span class="keywordtype">double</span>)((u+l)))/n0,0));
<a name="l02532"></a>02532 
<a name="l02533"></a>02533       nfft_uo(ths,j,&amp;u,&amp;o,1);
<a name="l02534"></a>02534       <span class="keywordflow">for</span>(l=0;l&lt;=2*m+1;l++)
<a name="l02535"></a>02535   psij_const[2*m+2+l]=(PHI(*(xj+1)-((<span class="keywordtype">double</span>)((u+l)))/n1,1));
<a name="l02536"></a>02536 
<a name="l02537"></a>02537       nfft_uo(ths,j,&amp;u,&amp;o,2);
<a name="l02538"></a>02538       <span class="keywordflow">for</span>(l=0;l&lt;=2*m+1;l++)
<a name="l02539"></a>02539   psij_const[2*(2*m+2)+l]=(PHI(*(xj+2)-((<span class="keywordtype">double</span>)((u+l)))/n2,2));
<a name="l02540"></a>02540 
<a name="l02541"></a>02541       nfft_adjoint_3d_compute(fj, g, psij_const, psij_const+2*m+2, psij_const+(2*m+2)*2, xj, xj+1, xj+2, n0, n1, n2, m);
<a name="l02542"></a>02542     }
<a name="l02543"></a>02543   <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(psij_const);
<a name="l02544"></a>02544 }
<a name="l02545"></a>02545 
<a name="l02546"></a>02546 <span class="keywordtype">void</span> nfft_trafo_3d(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02547"></a>02547 {
<a name="l02548"></a>02548   <span class="keywordtype">int</span> k0,k1,k2,n0,n1,n2,N0,N1,N2;
<a name="l02549"></a>02549   <span class="keywordtype">double</span> _Complex *g_hat,*f_hat;
<a name="l02550"></a>02550   <span class="keywordtype">double</span> *c_phi_inv01, *c_phi_inv02, *c_phi_inv11, *c_phi_inv12, *c_phi_inv21, *c_phi_inv22;
<a name="l02551"></a>02551   <span class="keywordtype">double</span> ck01, ck02, ck11, ck12, ck21, ck22;
<a name="l02552"></a>02552   <span class="keywordtype">double</span> _Complex *g_hat111,*f_hat111,*g_hat211,*f_hat211,*g_hat121,*f_hat121,*g_hat221,*f_hat221;
<a name="l02553"></a>02553   <span class="keywordtype">double</span> _Complex *g_hat112,*f_hat112,*g_hat212,*f_hat212,*g_hat122,*f_hat122,*g_hat222,*f_hat222;
<a name="l02554"></a>02554 
<a name="l02555"></a>02555   ths-&gt;<a class="code" href="structnfft__plan.html#2dff6c2b829694a7d4cca5acc7c7d6d5" title="Zero-padded vector of Fourier coefficients, size is n_total fftw_complex.">g_hat</a>=ths-&gt;<a class="code" href="structnfft__plan.html#2190e7201c55214d153b4d91eaa7efda" title="Input of fftw.">g1</a>;
<a name="l02556"></a>02556   ths-&gt;<a class="code" href="structnfft__plan.html#844b51e453d6c80462eaad7844633539" title="Oversampled vector of samples, size is n_total double complex.">g</a>=ths-&gt;<a class="code" href="structnfft__plan.html#d96e0aa935ea3589e999c131c43d8a78" title="Output of fftw.">g2</a>;
<a name="l02557"></a>02557 
<a name="l02558"></a>02558   N0=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[0];
<a name="l02559"></a>02559   N1=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[1];
<a name="l02560"></a>02560   N2=ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[2];
<a name="l02561"></a>02561   n0=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[0];
<a name="l02562"></a>02562   n1=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[1];
<a name="l02563"></a>02563   n2=ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[2];
<a name="l02564"></a>02564 
<a name="l02565"></a>02565   f_hat=ths-&gt;<a class="code" href="structnfft__plan.html#23409aec68871e9a56f11711e2891691" title="Vector of Fourier coefficients, \ size is N_total float_types.">f_hat</a>;
<a name="l02566"></a>02566   g_hat=ths-&gt;<a class="code" href="structnfft__plan.html#2dff6c2b829694a7d4cca5acc7c7d6d5" title="Zero-padded vector of Fourier coefficients, size is n_total fftw_complex.">g_hat</a>;
<a name="l02567"></a>02567 
<a name="l02568"></a>02568   <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(0)
<a name="l02569"></a>02569   memset(ths-&gt;g_hat,0,ths-&gt;n_total*sizeof(<span class="keywordtype">double</span> _Complex));
<a name="l02570"></a>02570   if(ths-&gt;nfft_flags &amp; PRE_PHI_HUT)
<a name="l02571"></a>02571     {
<a name="l02572"></a>02572       c_phi_inv01=ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[0];
<a name="l02573"></a>02573       c_phi_inv02=&amp;ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[0][N0/2];
<a name="l02574"></a>02574 
<a name="l02575"></a>02575       <span class="keywordflow">for</span>(k0=0;k0&lt;N0/2;k0++)
<a name="l02576"></a>02576   {
<a name="l02577"></a>02577     ck01=(*c_phi_inv01++);
<a name="l02578"></a>02578     ck02=(*c_phi_inv02++);
<a name="l02579"></a>02579     c_phi_inv11=ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[1];
<a name="l02580"></a>02580     c_phi_inv12=&amp;ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[1][N1/2];
<a name="l02581"></a>02581 
<a name="l02582"></a>02582     <span class="keywordflow">for</span>(k1=0;k1&lt;N1/2;k1++)
<a name="l02583"></a>02583       {
<a name="l02584"></a>02584         ck11=(*c_phi_inv11++);
<a name="l02585"></a>02585         ck12=(*c_phi_inv12++);
<a name="l02586"></a>02586         c_phi_inv21=ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[2];
<a name="l02587"></a>02587         c_phi_inv22=&amp;ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[2][N2/2];
<a name="l02588"></a>02588 
<a name="l02589"></a>02589         g_hat111=g_hat + ((n0-N0/2+k0)*n1+n1-N1/2+k1)*n2+n2-N2/2;
<a name="l02590"></a>02590         f_hat111=f_hat + (k0*N1+k1)*N2;
<a name="l02591"></a>02591         g_hat211=g_hat + (k0*n1+n1-N1/2+k1)*n2+n2-N2/2;
<a name="l02592"></a>02592         f_hat211=f_hat + ((N0/2+k0)*N1+k1)*N2;
<a name="l02593"></a>02593         g_hat121=g_hat + ((n0-N0/2+k0)*n1+k1)*n2+n2-N2/2;
<a name="l02594"></a>02594         f_hat121=f_hat + (k0*N1+N1/2+k1)*N2;
<a name="l02595"></a>02595         g_hat221=g_hat + (k0*n1+k1)*n2+n2-N2/2;
<a name="l02596"></a>02596         f_hat221=f_hat + ((N0/2+k0)*N1+N1/2+k1)*N2;
<a name="l02597"></a>02597 
<a name="l02598"></a>02598         g_hat112=g_hat + ((n0-N0/2+k0)*n1+n1-N1/2+k1)*n2;
<a name="l02599"></a>02599         f_hat112=f_hat + (k0*N1+k1)*N2+N2/2;
<a name="l02600"></a>02600         g_hat212=g_hat + (k0*n1+n1-N1/2+k1)*n2;
<a name="l02601"></a>02601         f_hat212=f_hat + ((N0/2+k0)*N1+k1)*N2+N2/2;
<a name="l02602"></a>02602         g_hat122=g_hat + ((n0-N0/2+k0)*n1+k1)*n2;
<a name="l02603"></a>02603         f_hat122=f_hat + (k0*N1+N1/2+k1)*N2+N2/2;
<a name="l02604"></a>02604         g_hat222=g_hat + (k0*n1+k1)*n2;
<a name="l02605"></a>02605         f_hat222=f_hat + ((N0/2+k0)*N1+N1/2+k1)*N2+N2/2;
<a name="l02606"></a>02606 
<a name="l02607"></a>02607         <span class="keywordflow">for</span>(k2=0;k2&lt;N2/2;k2++)
<a name="l02608"></a>02608     {
<a name="l02609"></a>02609       ck21=(*c_phi_inv21++);
<a name="l02610"></a>02610       ck22=(*c_phi_inv22++);
<a name="l02611"></a>02611 
<a name="l02612"></a>02612       (*g_hat111++) = (*f_hat111++) * ck01 * ck11 * ck21;
<a name="l02613"></a>02613       (*g_hat211++) = (*f_hat211++) * ck02 * ck11 * ck21;
<a name="l02614"></a>02614       (*g_hat121++) = (*f_hat121++) * ck01 * ck12 * ck21;
<a name="l02615"></a>02615       (*g_hat221++) = (*f_hat221++) * ck02 * ck12 * ck21;
<a name="l02616"></a>02616 
<a name="l02617"></a>02617       (*g_hat112++) = (*f_hat112++) * ck01 * ck11 * ck22;
<a name="l02618"></a>02618       (*g_hat212++) = (*f_hat212++) * ck02 * ck11 * ck22;
<a name="l02619"></a>02619       (*g_hat122++) = (*f_hat122++) * ck01 * ck12 * ck22;
<a name="l02620"></a>02620       (*g_hat222++) = (*f_hat222++) * ck02 * ck12 * ck22;
<a name="l02621"></a>02621     }
<a name="l02622"></a>02622       }
<a name="l02623"></a>02623   }
<a name="l02624"></a>02624     }
<a name="l02625"></a>02625   <span class="keywordflow">else</span>
<a name="l02626"></a>02626     <span class="keywordflow">for</span>(k0=0;k0&lt;N0/2;k0++)
<a name="l02627"></a>02627       {
<a name="l02628"></a>02628   ck01=1./(PHI_HUT(k0-N0/2,0));
<a name="l02629"></a>02629   ck02=1./(PHI_HUT(k0,0));
<a name="l02630"></a>02630   <span class="keywordflow">for</span>(k1=0;k1&lt;N1/2;k1++)
<a name="l02631"></a>02631     {
<a name="l02632"></a>02632       ck11=1./(PHI_HUT(k1-N1/2,1));
<a name="l02633"></a>02633       ck12=1./(PHI_HUT(k1,1));
<a name="l02634"></a>02634 
<a name="l02635"></a>02635       <span class="keywordflow">for</span>(k2=0;k2&lt;N2/2;k2++)
<a name="l02636"></a>02636         {
<a name="l02637"></a>02637     ck21=1./(PHI_HUT(k2-N2/2,2));
<a name="l02638"></a>02638     ck22=1./(PHI_HUT(k2,2));
<a name="l02639"></a>02639 
<a name="l02640"></a>02640     g_hat[((n0-N0/2+k0)*n1+n1-N1/2+k1)*n2+n2-N2/2+k2] = f_hat[(k0*N1+k1)*N2+k2]                  * ck01 * ck11 * ck21;
<a name="l02641"></a>02641     g_hat[(k0*n1+n1-N1/2+k1)*n2+n2-N2/2+k2]           = f_hat[((N0/2+k0)*N1+k1)*N2+k2]           * ck02 * ck11 * ck21;
<a name="l02642"></a>02642     g_hat[((n0-N0/2+k0)*n1+k1)*n2+n2-N2/2+k2]         = f_hat[(k0*N1+N1/2+k1)*N2+k2]             * ck01 * ck12 * ck21;
<a name="l02643"></a>02643     g_hat[(k0*n1+k1)*n2+n2-N2/2+k2]                   = f_hat[((N0/2+k0)*N1+N1/2+k1)*N2+k2]      * ck02 * ck12 * ck21;
<a name="l02644"></a>02644 
<a name="l02645"></a>02645     g_hat[((n0-N0/2+k0)*n1+n1-N1/2+k1)*n2+k2]         = f_hat[(k0*N1+k1)*N2+N2/2+k2]             * ck01 * ck11 * ck22;
<a name="l02646"></a>02646     g_hat[(k0*n1+n1-N1/2+k1)*n2+k2]                   = f_hat[((N0/2+k0)*N1+k1)*N2+N2/2+k2]      * ck02 * ck11 * ck22;
<a name="l02647"></a>02647     g_hat[((n0-N0/2+k0)*n1+k1)*n2+k2]                 = f_hat[(k0*N1+N1/2+k1)*N2+N2/2+k2]        * ck01 * ck12 * ck22;
<a name="l02648"></a>02648     g_hat[(k0*n1+k1)*n2+k2]                           = f_hat[((N0/2+k0)*N1+N1/2+k1)*N2+N2/2+k2] * ck02 * ck12 * ck22;
<a name="l02649"></a>02649         }
<a name="l02650"></a>02650     }
<a name="l02651"></a>02651       }
<a name="l02652"></a>02652 
<a name="l02653"></a>02653   TOC(0)
<a name="l02654"></a>02654 
<a name="l02655"></a>02655   TIC_FFTW(1)
<a name="l02656"></a>02656   fftw_execute(ths-&gt;my_fftw_plan1);
<a name="l02657"></a>02657   TOC_FFTW(1);
<a name="l02658"></a>02658 
<a name="l02659"></a>02659   <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(2);
<a name="l02660"></a>02660   nfft_trafo_3d_B(ths);
<a name="l02661"></a>02661   TOC(2);
<a name="l02662"></a>02662 }
<a name="l02663"></a>02663 
<a name="l02664"></a>02664 <span class="keywordtype">void</span> nfft_adjoint_3d(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02665"></a>02665 {
<a name="l02666"></a>02666   <span class="keywordtype">int</span> k0,k1,k2,n0,n1,n2,N0,N1,N2;
<a name="l02667"></a>02667   <span class="keywordtype">double</span> _Complex *g_hat,*f_hat;
<a name="l02668"></a>02668   <span class="keywordtype">double</span> *c_phi_inv01, *c_phi_inv02, *c_phi_inv11, *c_phi_inv12, *c_phi_inv21, *c_phi_inv22;
<a name="l02669"></a>02669   <span class="keywordtype">double</span> ck01, ck02, ck11, ck12, ck21, ck22;
<a name="l02670"></a>02670   <span class="keywordtype">double</span> _Complex *g_hat111,*f_hat111,*g_hat211,*f_hat211,*g_hat121,*f_hat121,*g_hat221,*f_hat221;
<a name="l02671"></a>02671   <span class="keywordtype">double</span> _Complex *g_hat112,*f_hat112,*g_hat212,*f_hat212,*g_hat122,*f_hat122,*g_hat222,*f_hat222;
<a name="l02672"></a>02672 
<a name="l02673"></a>02673   ths-&gt;g_hat=ths-&gt;g1;
<a name="l02674"></a>02674   ths-&gt;g=ths-&gt;g2;
<a name="l02675"></a>02675 
<a name="l02676"></a>02676   N0=ths-&gt;N[0];
<a name="l02677"></a>02677   N1=ths-&gt;N[1];
<a name="l02678"></a>02678   N2=ths-&gt;N[2];
<a name="l02679"></a>02679   n0=ths-&gt;n[0];
<a name="l02680"></a>02680   n1=ths-&gt;n[1];
<a name="l02681"></a>02681   n2=ths-&gt;n[2];
<a name="l02682"></a>02682 
<a name="l02683"></a>02683   f_hat=ths-&gt;f_hat;
<a name="l02684"></a>02684   g_hat=ths-&gt;g_hat;
<a name="l02685"></a>02685 
<a name="l02686"></a>02686   <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(2);
<a name="l02687"></a>02687   nfft_adjoint_3d_B(ths);
<a name="l02688"></a>02688   TOC(2);
<a name="l02689"></a>02689 
<a name="l02690"></a>02690   TIC_FFTW(1)
<a name="l02691"></a>02691   fftw_execute(ths-&gt;my_fftw_plan2);
<a name="l02692"></a>02692   TOC_FFTW(1);
<a name="l02693"></a>02693 
<a name="l02694"></a>02694   <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(0)
<a name="l02695"></a>02695   if(ths-&gt;nfft_flags &amp; PRE_PHI_HUT)
<a name="l02696"></a>02696     {
<a name="l02697"></a>02697       c_phi_inv01=ths-&gt;c_phi_inv[0];
<a name="l02698"></a>02698       c_phi_inv02=&amp;ths-&gt;c_phi_inv[0][N0/2];
<a name="l02699"></a>02699 
<a name="l02700"></a>02700       <span class="keywordflow">for</span>(k0=0;k0&lt;N0/2;k0++)
<a name="l02701"></a>02701   {
<a name="l02702"></a>02702     ck01=(*c_phi_inv01++);
<a name="l02703"></a>02703     ck02=(*c_phi_inv02++);
<a name="l02704"></a>02704     c_phi_inv11=ths-&gt;c_phi_inv[1];
<a name="l02705"></a>02705     c_phi_inv12=&amp;ths-&gt;c_phi_inv[1][N1/2];
<a name="l02706"></a>02706 
<a name="l02707"></a>02707     <span class="keywordflow">for</span>(k1=0;k1&lt;N1/2;k1++)
<a name="l02708"></a>02708       {
<a name="l02709"></a>02709         ck11=(*c_phi_inv11++);
<a name="l02710"></a>02710         ck12=(*c_phi_inv12++);
<a name="l02711"></a>02711         c_phi_inv21=ths-&gt;c_phi_inv[2];
<a name="l02712"></a>02712         c_phi_inv22=&amp;ths-&gt;c_phi_inv[2][N2/2];
<a name="l02713"></a>02713 
<a name="l02714"></a>02714         g_hat111=g_hat + ((n0-N0/2+k0)*n1+n1-N1/2+k1)*n2+n2-N2/2;
<a name="l02715"></a>02715         f_hat111=f_hat + (k0*N1+k1)*N2;
<a name="l02716"></a>02716         g_hat211=g_hat + (k0*n1+n1-N1/2+k1)*n2+n2-N2/2;
<a name="l02717"></a>02717         f_hat211=f_hat + ((N0/2+k0)*N1+k1)*N2;
<a name="l02718"></a>02718         g_hat121=g_hat + ((n0-N0/2+k0)*n1+k1)*n2+n2-N2/2;
<a name="l02719"></a>02719         f_hat121=f_hat + (k0*N1+N1/2+k1)*N2;
<a name="l02720"></a>02720         g_hat221=g_hat + (k0*n1+k1)*n2+n2-N2/2;
<a name="l02721"></a>02721         f_hat221=f_hat + ((N0/2+k0)*N1+N1/2+k1)*N2;
<a name="l02722"></a>02722 
<a name="l02723"></a>02723         g_hat112=g_hat + ((n0-N0/2+k0)*n1+n1-N1/2+k1)*n2;
<a name="l02724"></a>02724         f_hat112=f_hat + (k0*N1+k1)*N2+N2/2;
<a name="l02725"></a>02725         g_hat212=g_hat + (k0*n1+n1-N1/2+k1)*n2;
<a name="l02726"></a>02726         f_hat212=f_hat + ((N0/2+k0)*N1+k1)*N2+N2/2;
<a name="l02727"></a>02727         g_hat122=g_hat + ((n0-N0/2+k0)*n1+k1)*n2;
<a name="l02728"></a>02728         f_hat122=f_hat + (k0*N1+N1/2+k1)*N2+N2/2;
<a name="l02729"></a>02729         g_hat222=g_hat + (k0*n1+k1)*n2;
<a name="l02730"></a>02730         f_hat222=f_hat + ((N0/2+k0)*N1+N1/2+k1)*N2+N2/2;
<a name="l02731"></a>02731 
<a name="l02732"></a>02732         <span class="keywordflow">for</span>(k2=0;k2&lt;N2/2;k2++)
<a name="l02733"></a>02733     {
<a name="l02734"></a>02734       ck21=(*c_phi_inv21++);
<a name="l02735"></a>02735       ck22=(*c_phi_inv22++);
<a name="l02736"></a>02736 
<a name="l02737"></a>02737       (*f_hat111++) = (*g_hat111++) * ck01 * ck11 * ck21;
<a name="l02738"></a>02738       (*f_hat211++) = (*g_hat211++) * ck02 * ck11 * ck21;
<a name="l02739"></a>02739       (*f_hat121++) = (*g_hat121++) * ck01 * ck12 * ck21;
<a name="l02740"></a>02740       (*f_hat221++) = (*g_hat221++) * ck02 * ck12 * ck21;
<a name="l02741"></a>02741 
<a name="l02742"></a>02742       (*f_hat112++) = (*g_hat112++) * ck01 * ck11 * ck22;
<a name="l02743"></a>02743       (*f_hat212++) = (*g_hat212++) * ck02 * ck11 * ck22;
<a name="l02744"></a>02744       (*f_hat122++) = (*g_hat122++) * ck01 * ck12 * ck22;
<a name="l02745"></a>02745       (*f_hat222++) = (*g_hat222++) * ck02 * ck12 * ck22;
<a name="l02746"></a>02746     }
<a name="l02747"></a>02747       }
<a name="l02748"></a>02748   }
<a name="l02749"></a>02749     }
<a name="l02750"></a>02750   <span class="keywordflow">else</span>
<a name="l02751"></a>02751     <span class="keywordflow">for</span>(k0=0;k0&lt;N0/2;k0++)
<a name="l02752"></a>02752       {
<a name="l02753"></a>02753   ck01=1./(PHI_HUT(k0-N0/2,0));
<a name="l02754"></a>02754   ck02=1./(PHI_HUT(k0,0));
<a name="l02755"></a>02755   <span class="keywordflow">for</span>(k1=0;k1&lt;N1/2;k1++)
<a name="l02756"></a>02756     {
<a name="l02757"></a>02757       ck11=1./(PHI_HUT(k1-N1/2,1));
<a name="l02758"></a>02758       ck12=1./(PHI_HUT(k1,1));
<a name="l02759"></a>02759 
<a name="l02760"></a>02760       <span class="keywordflow">for</span>(k2=0;k2&lt;N2/2;k2++)
<a name="l02761"></a>02761         {
<a name="l02762"></a>02762     ck21=1./(PHI_HUT(k2-N2/2,2));
<a name="l02763"></a>02763     ck22=1./(PHI_HUT(k2,2));
<a name="l02764"></a>02764 
<a name="l02765"></a>02765     f_hat[(k0*N1+k1)*N2+k2]                  = g_hat[((n0-N0/2+k0)*n1+n1-N1/2+k1)*n2+n2-N2/2+k2] * ck01 * ck11 * ck21;
<a name="l02766"></a>02766     f_hat[((N0/2+k0)*N1+k1)*N2+k2]           = g_hat[(k0*n1+n1-N1/2+k1)*n2+n2-N2/2+k2]           * ck02 * ck11 * ck21;
<a name="l02767"></a>02767     f_hat[(k0*N1+N1/2+k1)*N2+k2]             = g_hat[((n0-N0/2+k0)*n1+k1)*n2+n2-N2/2+k2]         * ck01 * ck12 * ck21;
<a name="l02768"></a>02768     f_hat[((N0/2+k0)*N1+N1/2+k1)*N2+k2]      = g_hat[(k0*n1+k1)*n2+n2-N2/2+k2]                   * ck02 * ck12 * ck21;
<a name="l02769"></a>02769 
<a name="l02770"></a>02770     f_hat[(k0*N1+k1)*N2+N2/2+k2]             = g_hat[((n0-N0/2+k0)*n1+n1-N1/2+k1)*n2+k2]         * ck01 * ck11 * ck22;
<a name="l02771"></a>02771     f_hat[((N0/2+k0)*N1+k1)*N2+N2/2+k2]      = g_hat[(k0*n1+n1-N1/2+k1)*n2+k2]                   * ck02 * ck11 * ck22;
<a name="l02772"></a>02772     f_hat[(k0*N1+N1/2+k1)*N2+N2/2+k2]        = g_hat[((n0-N0/2+k0)*n1+k1)*n2+k2]                 * ck01 * ck12 * ck22;
<a name="l02773"></a>02773     f_hat[((N0/2+k0)*N1+N1/2+k1)*N2+N2/2+k2] = g_hat[(k0*n1+k1)*n2+k2]                           * ck02 * ck12 * ck22;
<a name="l02774"></a>02774         }
<a name="l02775"></a>02775     }
<a name="l02776"></a>02776       }
<a name="l02777"></a>02777 
<a name="l02778"></a>02778   TOC(0)
<a name="l02779"></a>02779 }
<a name="l02780"></a>02780 
<a name="l02783"></a>02783 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#g9f1e6bd9f7f956a8679e6b413c97b421" title="Computes a NFFT, see the definition.">nfft_trafo</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02784"></a><a class="code" href="group__nfft.html#g9f1e6bd9f7f956a8679e6b413c97b421">02784</a> {
<a name="l02785"></a>02785   <span class="keywordflow">switch</span>(ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>)
<a name="l02786"></a>02786     {
<a name="l02787"></a>02787     <span class="keywordflow">case</span> 1: nfft_trafo_1d(ths); <span class="keywordflow">break</span>;
<a name="l02788"></a>02788     <span class="keywordflow">case</span> 2: nfft_trafo_2d(ths); <span class="keywordflow">break</span>;
<a name="l02789"></a>02789     <span class="keywordflow">case</span> 3: nfft_trafo_3d(ths); <span class="keywordflow">break</span>;
<a name="l02790"></a>02790     <span class="keywordflow">default</span>:
<a name="l02791"></a>02791     <span class="comment">/* use ths-&gt;my_fftw_plan1 */</span>
<a name="l02792"></a>02792     ths-&gt;<a class="code" href="structnfft__plan.html#2dff6c2b829694a7d4cca5acc7c7d6d5" title="Zero-padded vector of Fourier coefficients, size is n_total fftw_complex.">g_hat</a>=ths-&gt;<a class="code" href="structnfft__plan.html#2190e7201c55214d153b4d91eaa7efda" title="Input of fftw.">g1</a>;
<a name="l02793"></a>02793     ths-&gt;<a class="code" href="structnfft__plan.html#844b51e453d6c80462eaad7844633539" title="Oversampled vector of samples, size is n_total double complex.">g</a>=ths-&gt;<a class="code" href="structnfft__plan.html#d96e0aa935ea3589e999c131c43d8a78" title="Output of fftw.">g2</a>;
<a name="l02794"></a>02794 
<a name="l02798"></a>02798     <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(0)
<a name="l02799"></a>02799     nfft_D_A(ths);
<a name="l02800"></a>02800     TOC(0)
<a name="l02801"></a>02801 
<a name="l02802"></a>02802     
<a name="l02806"></a>02806     TIC_FFTW(1)
<a name="l02807"></a>02807     fftw_execute(ths-&gt;<a class="code" href="structnfft__plan.html#84d87c06b22ddb3e725c61061cf4d46d" title="Forward FFTW plan.">my_fftw_plan1</a>);
<a name="l02808"></a>02808     TOC_FFTW(1)
<a name="l02809"></a>02809 
<a name="l02810"></a>02810     
<a name="l02813"></a>02813     <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(2)
<a name="l02814"></a>02814     nfft_B_A(ths);
<a name="l02815"></a>02815     TOC(2)
<a name="l02816"></a>02816     }
<a name="l02817"></a>02817 } <span class="comment">/* nfft_trafo */</span>
<a name="l02818"></a>02818 
<a name="l02819"></a>02819 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#g4b44c1dd52026dcb494dc735f0fa5b08" title="Computes an adjoint NFFT, see the definition.">nfft_adjoint</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02820"></a><a class="code" href="group__nfft.html#g4b44c1dd52026dcb494dc735f0fa5b08">02820</a> {
<a name="l02821"></a>02821   <span class="keywordflow">switch</span>(ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>)
<a name="l02822"></a>02822     {
<a name="l02823"></a>02823     <span class="keywordflow">case</span> 1: nfft_adjoint_1d(ths); <span class="keywordflow">break</span>;
<a name="l02824"></a>02824     <span class="keywordflow">case</span> 2: nfft_adjoint_2d(ths); <span class="keywordflow">break</span>;
<a name="l02825"></a>02825     <span class="keywordflow">case</span> 3: nfft_adjoint_3d(ths); <span class="keywordflow">break</span>;
<a name="l02826"></a>02826     <span class="keywordflow">default</span>:
<a name="l02827"></a>02827       <span class="comment">/* use ths-&gt;my_fftw_plan2 */</span>
<a name="l02828"></a>02828       ths-&gt;<a class="code" href="structnfft__plan.html#2dff6c2b829694a7d4cca5acc7c7d6d5" title="Zero-padded vector of Fourier coefficients, size is n_total fftw_complex.">g_hat</a>=ths-&gt;<a class="code" href="structnfft__plan.html#2190e7201c55214d153b4d91eaa7efda" title="Input of fftw.">g1</a>;
<a name="l02829"></a>02829       ths-&gt;<a class="code" href="structnfft__plan.html#844b51e453d6c80462eaad7844633539" title="Oversampled vector of samples, size is n_total double complex.">g</a>=ths-&gt;<a class="code" href="structnfft__plan.html#d96e0aa935ea3589e999c131c43d8a78" title="Output of fftw.">g2</a>;
<a name="l02830"></a>02830       
<a name="l02834"></a>02834       <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(2)
<a name="l02835"></a>02835       nfft_B_T(ths);
<a name="l02836"></a>02836       TOC(2)
<a name="l02837"></a>02837   
<a name="l02838"></a>02838       
<a name="l02842"></a>02842       TIC_FFTW(1)
<a name="l02843"></a>02843       fftw_execute(ths-&gt;<a class="code" href="structnfft__plan.html#228dee0f91c2f326407517c27bc5105e" title="Backward FFTW plan.">my_fftw_plan2</a>);
<a name="l02844"></a>02844       TOC_FFTW(1)
<a name="l02845"></a>02845   
<a name="l02846"></a>02846       
<a name="l02849"></a>02849       <a class="code" href="group__nfftutil.html#g05909fc22b7177d1bd50119f40fbb1ec" title="Timing, method works since the inaccurate timer is updated mostly in the measured...">TIC</a>(0)
<a name="l02850"></a>02850       nfft_D_T(ths);
<a name="l02851"></a>02851       TOC(0)
<a name="l02852"></a>02852     }
<a name="l02853"></a>02853 } <span class="comment">/* nfft_adjoint */</span>
<a name="l02854"></a>02854 
<a name="l02855"></a>02855 
<a name="l02858"></a>02858 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_precompute_phi_hut(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02859"></a>02859 {
<a name="l02860"></a>02860   <span class="keywordtype">int</span> ks[ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>];                       
<a name="l02861"></a>02861   <span class="keywordtype">int</span> t;                                
<a name="l02863"></a>02863   ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a> = (<span class="keywordtype">double</span>**) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
<a name="l02864"></a>02864 
<a name="l02865"></a>02865   <span class="keywordflow">for</span>(t=0; t&lt;ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>; t++)
<a name="l02866"></a>02866     {
<a name="l02867"></a>02867       ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[t]= (<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[t]*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l02868"></a>02868       <span class="keywordflow">for</span>(ks[t]=0; ks[t]&lt;ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[t]; ks[t]++)
<a name="l02869"></a>02869   ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[t][ks[t]]= 1.0/(PHI_HUT(ks[t]-ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[t]/2,t));
<a name="l02870"></a>02870     }
<a name="l02871"></a>02871 } <span class="comment">/* nfft_phi_hut */</span>
<a name="l02872"></a>02872 
<a name="l02878"></a>02878 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#g3f91a7a005cc31a8b05f33fea0507ddc" title="Superceded by nfft_precompute_one_psi.">nfft_precompute_lin_psi</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02879"></a><a class="code" href="group__nfft.html#g3f91a7a005cc31a8b05f33fea0507ddc">02879</a> {
<a name="l02880"></a>02880   <span class="keywordtype">int</span> t;                                
<a name="l02881"></a>02881   <span class="keywordtype">int</span> j;                                
<a name="l02882"></a>02882   <span class="keywordtype">double</span> step;                          
<a name="l02884"></a>02884   <span class="keywordflow">for</span> (t=0; t&lt;ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>; t++)
<a name="l02885"></a>02885     {
<a name="l02886"></a>02886       step=((double)(ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>+2))/(ths-&gt;<a class="code" href="structnfft__plan.html#0b3735bcdd415a86126e0c86d47941a4" title="Number of equispaced samples of the window function for PRE_LIN_PSI.">K</a>*ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[t]);
<a name="l02887"></a>02887       <span class="keywordflow">for</span>(j=0;j&lt;=ths-&gt;<a class="code" href="structnfft__plan.html#0b3735bcdd415a86126e0c86d47941a4" title="Number of equispaced samples of the window function for PRE_LIN_PSI.">K</a>;j++)
<a name="l02888"></a>02888   {
<a name="l02889"></a>02889     ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[(ths-&gt;<a class="code" href="structnfft__plan.html#0b3735bcdd415a86126e0c86d47941a4" title="Number of equispaced samples of the window function for PRE_LIN_PSI.">K</a>+1)*t + j] = PHI(j*step,t);
<a name="l02890"></a>02890   } <span class="comment">/* for(j) */</span>
<a name="l02891"></a>02891     } <span class="comment">/* for(t) */</span>
<a name="l02892"></a>02892 }
<a name="l02893"></a>02893 
<a name="l02894"></a>02894 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_precompute_fg_psi(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02895"></a>02895 {
<a name="l02896"></a>02896   <span class="keywordtype">int</span> t;                                
<a name="l02897"></a>02897   <span class="keywordtype">int</span> j;                                
<a name="l02898"></a>02898   <span class="keywordtype">int</span> u, o;                             
<a name="l02900"></a>02900   <span class="keywordflow">for</span> (t=0; t&lt;ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>; t++)
<a name="l02901"></a>02901     <span class="keywordflow">for</span>(j=0;j&lt;ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>;j++)
<a name="l02902"></a>02902       {
<a name="l02903"></a>02903   nfft_uo(ths,j,&amp;u,&amp;o,t);
<a name="l02904"></a>02904 
<a name="l02905"></a>02905         ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>+t)]=
<a name="l02906"></a>02906             (PHI((ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>[j*ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>+t]-((<span class="keywordtype">double</span>)u)/ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[t]),t));
<a name="l02907"></a>02907 
<a name="l02908"></a>02908         ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[2*(j*ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>+t)+1]=
<a name="l02909"></a>02909             exp(2.0*(ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[t]*ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>[j*ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>+t] - u) / ths-&gt;<a class="code" href="structnfft__plan.html#724949f4916b28f484eb447ee1a77f0a" title="Shape parameter of the window function.">b</a>[t]);
<a name="l02910"></a>02910       } <span class="comment">/* for(j) */</span>
<a name="l02911"></a>02911   <span class="comment">/* for(t) */</span>
<a name="l02912"></a>02912 } <span class="comment">/* nfft_precompute_fg_psi */</span>
<a name="l02913"></a>02913 
<a name="l02914"></a>02914 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#ge6a8367b03fd75b2af42dbbaccb78bf2" title="Superceded by nfft_precompute_one_psi.">nfft_precompute_psi</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02915"></a><a class="code" href="group__nfft.html#ge6a8367b03fd75b2af42dbbaccb78bf2">02915</a> {
<a name="l02916"></a>02916   <span class="keywordtype">int</span> t;                                
<a name="l02917"></a>02917   <span class="keywordtype">int</span> j;                                
<a name="l02918"></a>02918   <span class="keywordtype">int</span> l;                                
<a name="l02919"></a>02919   <span class="keywordtype">int</span> lj;                               
<a name="l02920"></a>02920   <span class="keywordtype">int</span> u, o;                             
<a name="l02922"></a>02922   <span class="keywordflow">for</span> (t=0; t&lt;ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>; t++)
<a name="l02923"></a>02923     <span class="keywordflow">for</span>(j=0;j&lt;ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>;j++)
<a name="l02924"></a>02924       {
<a name="l02925"></a>02925   nfft_uo(ths,j,&amp;u,&amp;o,t);
<a name="l02926"></a>02926 
<a name="l02927"></a>02927   <span class="keywordflow">for</span>(l=u, lj=0; l &lt;= o; l++, lj++)
<a name="l02928"></a>02928     ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[(j*ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>+t)*(2*ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>+2)+lj]=
<a name="l02929"></a>02929       (PHI((ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>[j*ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>+t]-((<span class="keywordtype">double</span>)l)/ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[t]),t));
<a name="l02930"></a>02930       } <span class="comment">/* for(j) */</span>
<a name="l02931"></a>02931   <span class="comment">/* for(t) */</span>
<a name="l02932"></a>02932 } <span class="comment">/* nfft_precompute_psi */</span>
<a name="l02933"></a>02933 
<a name="l02934"></a>02934 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#gee7a88956c66b2113014084d6dd04b3a" title="Superceded by nfft_precompute_one_psi.">nfft_precompute_full_psi</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02935"></a><a class="code" href="group__nfft.html#gee7a88956c66b2113014084d6dd04b3a">02935</a> {
<a name="l02936"></a>02936   <span class="keywordtype">int</span> t,t2;                             
<a name="l02937"></a>02937   <span class="keywordtype">int</span> j;                                
<a name="l02938"></a>02938   <span class="keywordtype">int</span> l_L;                              
<a name="l02939"></a>02939   <span class="keywordtype">int</span> l[ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>];                        
<a name="l02940"></a>02940   <span class="keywordtype">int</span> lj[ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>];                       
<a name="l02941"></a>02941   <span class="keywordtype">int</span> ll_plain[ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>+1];               
<a name="l02942"></a>02942   <span class="keywordtype">int</span> lprod;                            
<a name="l02943"></a>02943   <span class="keywordtype">int</span> u[ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>], o[ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>];             
<a name="l02945"></a>02945   <span class="keywordtype">double</span> phi_prod[ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>+1];
<a name="l02946"></a>02946 
<a name="l02947"></a>02947   <span class="keywordtype">int</span> ix,ix_old;
<a name="l02948"></a>02948 
<a name="l02949"></a>02949   phi_prod[0]=1;
<a name="l02950"></a>02950   ll_plain[0]=0;
<a name="l02951"></a>02951 
<a name="l02952"></a>02952   <span class="keywordflow">for</span>(t=0,lprod = 1; t&lt;ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>; t++)
<a name="l02953"></a>02953       lprod *= 2*ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>+2;
<a name="l02954"></a>02954 
<a name="l02955"></a>02955   <span class="keywordflow">for</span>(j=0,ix=0,ix_old=0; j&lt;ths-&gt;M_total; j++)
<a name="l02956"></a>02956     {
<a name="l02957"></a>02957       MACRO_init_uo_l_lj_t;
<a name="l02958"></a>02958 
<a name="l02959"></a>02959       <span class="keywordflow">for</span>(l_L=0; l_L&lt;lprod; l_L++, ix++)
<a name="l02960"></a>02960   {
<a name="l02961"></a>02961     MACRO_update_phi_prod_ll_plain(without_PRE_PSI);
<a name="l02962"></a>02962 
<a name="l02963"></a>02963     ths-&gt;<a class="code" href="structnfft__plan.html#877d6cbe17ec77a9e66bdbea3cfafe0a" title="Indices in source/target vector for PRE_FULL_PSI.">psi_index_g</a>[ix]=ll_plain[ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>];
<a name="l02964"></a>02964     ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>[ix]=phi_prod[ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>];
<a name="l02965"></a>02965 
<a name="l02966"></a>02966     MACRO_count_uo_l_lj_t;
<a name="l02967"></a>02967   } <span class="comment">/* for(l_L) */</span>
<a name="l02968"></a>02968 
<a name="l02969"></a>02969 
<a name="l02970"></a>02970       ths-&gt;<a class="code" href="structnfft__plan.html#2ed144cf7d6043a93c07b6f6ba7bbe2a" title="Indices in source/target vector for PRE_FULL_PSI.">psi_index_f</a>[j]=ix-ix_old;
<a name="l02971"></a>02971       ix_old=ix;
<a name="l02972"></a>02972     } <span class="comment">/* for(j) */</span>
<a name="l02973"></a>02973 }
<a name="l02974"></a>02974 
<a name="l02975"></a>02975 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#gfd7b278b6ed04d929212b4807dd195f0" title="Precomputation for a transform plan.">nfft_precompute_one_psi</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02976"></a><a class="code" href="group__nfft.html#gfd7b278b6ed04d929212b4807dd195f0">02976</a> {
<a name="l02977"></a>02977   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#gbb1ad048b695cb806baf010c5d1b2caf" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_LIN_PSI</a>)
<a name="l02978"></a>02978     <a class="code" href="group__nfft.html#g3f91a7a005cc31a8b05f33fea0507ddc" title="Superceded by nfft_precompute_one_psi.">nfft_precompute_lin_psi</a>(ths);
<a name="l02979"></a>02979   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g9c5a5ab61009a801082897ca40a1658c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FG_PSI</a>)
<a name="l02980"></a>02980     nfft_precompute_fg_psi(ths);
<a name="l02981"></a>02981   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g959463a5c7723ccef5057ddcb784b40c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_PSI</a>)
<a name="l02982"></a>02982     <a class="code" href="group__nfft.html#ge6a8367b03fd75b2af42dbbaccb78bf2" title="Superceded by nfft_precompute_one_psi.">nfft_precompute_psi</a>(ths);
<a name="l02983"></a>02983   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g7ad8a7e19519b16340dabec48899c6a4" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FULL_PSI</a>)
<a name="l02984"></a>02984     <a class="code" href="group__nfft.html#gee7a88956c66b2113014084d6dd04b3a" title="Superceded by nfft_precompute_one_psi.">nfft_precompute_full_psi</a>(ths);
<a name="l02985"></a>02985 }
<a name="l02986"></a>02986 
<a name="l02987"></a>02987 
<a name="l02988"></a>02988 <span class="keyword">static</span> <span class="keywordtype">void</span> nfft_init_help(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l02989"></a>02989 {
<a name="l02990"></a>02990   <span class="keywordtype">int</span> t;                                
<a name="l02991"></a>02991   <span class="keywordtype">int</span> lprod;                            
<a name="l02993"></a>02993   ths-&gt;<a class="code" href="structnfft__plan.html#d33daddf76670c8731c759bf74ad0d22" title="Total number of Fourier \ coefficients.">N_total</a>=<a class="code" href="group__nfftutil.html#g2752ca372ee2622f173a706e86e2b116" title="Computes integer .">nfft_prod_int</a>(ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>, ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>);
<a name="l02994"></a>02994   ths-&gt;<a class="code" href="structnfft__plan.html#d8a5fdac5bcf62d86479c800768fdeb7" title="Total size of FFTW.">n_total</a>=<a class="code" href="group__nfftutil.html#g2752ca372ee2622f173a706e86e2b116" title="Computes integer .">nfft_prod_int</a>(ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>, ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>);
<a name="l02995"></a>02995 
<a name="l02996"></a>02996   ths-&gt;<a class="code" href="structnfft__plan.html#09340f6465c23f3d94636f4f0da30f8a" title="Oversampling-factor.">sigma</a> = (<span class="keywordtype">double</span>*) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l02997"></a>02997   <span class="keywordflow">for</span>(t = 0;t &lt; ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>; t++)
<a name="l02998"></a>02998     ths-&gt;<a class="code" href="structnfft__plan.html#09340f6465c23f3d94636f4f0da30f8a" title="Oversampling-factor.">sigma</a>[t] = ((<span class="keywordtype">double</span>)ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[t])/ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[t];
<a name="l02999"></a>02999 
<a name="l03000"></a>03000   WINDOW_HELP_INIT;
<a name="l03001"></a>03001 
<a name="l03002"></a>03002   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g353185384f87de0dc4320a82652ef724" title="If this flag is set, (de)allocation of the node vector is done.">MALLOC_X</a>)
<a name="l03003"></a>03003     ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a> = (<span class="keywordtype">double</span>*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>*ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l03004"></a>03004 
<a name="l03005"></a>03005   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g02d52cb02b6cfdbc3e4d5fd4de1aef9e" title="If this flag is set, (de)allocation of the vector of Fourier coefficients is done...">MALLOC_F_HAT</a>)
<a name="l03006"></a>03006     ths-&gt;<a class="code" href="structnfft__plan.html#23409aec68871e9a56f11711e2891691" title="Vector of Fourier coefficients, \ size is N_total float_types.">f_hat</a> = (<span class="keywordtype">double</span> _Complex*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#d33daddf76670c8731c759bf74ad0d22" title="Total number of Fourier \ coefficients.">N_total</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> _Complex));
<a name="l03007"></a>03007 
<a name="l03008"></a>03008   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#ga7b5098f4136080bbe0dd989973e2a69" title="If this flag is set, (de)allocation of the vector of samples is done.">MALLOC_F</a>)
<a name="l03009"></a>03009     ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a> = (<span class="keywordtype">double</span> _Complex*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> _Complex));
<a name="l03010"></a>03010 
<a name="l03011"></a>03011   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; PRE_PHI_HUT)
<a name="l03012"></a>03012     nfft_precompute_phi_hut(ths);
<a name="l03013"></a>03013 
<a name="l03014"></a>03014   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#gbb1ad048b695cb806baf010c5d1b2caf" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_LIN_PSI</a>)
<a name="l03015"></a>03015   {
<a name="l03016"></a>03016       ths-&gt;<a class="code" href="structnfft__plan.html#0b3735bcdd415a86126e0c86d47941a4" title="Number of equispaced samples of the window function for PRE_LIN_PSI.">K</a>=(1U&lt;&lt; 10)*(ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>+2);
<a name="l03017"></a>03017       ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a> = (<span class="keywordtype">double</span>*) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>((ths-&gt;<a class="code" href="structnfft__plan.html#0b3735bcdd415a86126e0c86d47941a4" title="Number of equispaced samples of the window function for PRE_LIN_PSI.">K</a>+1)*ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>*<span class="keyword">sizeof</span>(double));
<a name="l03018"></a>03018   }
<a name="l03019"></a>03019 
<a name="l03020"></a>03020   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g9c5a5ab61009a801082897ca40a1658c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FG_PSI</a>)
<a name="l03021"></a>03021     ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a> = (<span class="keywordtype">double</span>*) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>*ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>*2*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l03022"></a>03022 
<a name="l03023"></a>03023   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g959463a5c7723ccef5057ddcb784b40c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_PSI</a>)
<a name="l03024"></a>03024     ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a> = (<span class="keywordtype">double</span>*) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>*ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>*
<a name="l03025"></a>03025              (2*ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>+2)*<span class="keyword">sizeof</span>(double));
<a name="l03026"></a>03026 
<a name="l03027"></a>03027   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g7ad8a7e19519b16340dabec48899c6a4" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FULL_PSI</a>)
<a name="l03028"></a>03028   {
<a name="l03029"></a>03029       <span class="keywordflow">for</span>(t=0,lprod = 1; t&lt;ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>; t++)
<a name="l03030"></a>03030     lprod *= 2*ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>+2;
<a name="l03031"></a>03031 
<a name="l03032"></a>03032       ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a> = (<span class="keywordtype">double</span>*) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>*lprod*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
<a name="l03033"></a>03033 
<a name="l03034"></a>03034       ths-&gt;<a class="code" href="structnfft__plan.html#2ed144cf7d6043a93c07b6f6ba7bbe2a" title="Indices in source/target vector for PRE_FULL_PSI.">psi_index_f</a> = (<span class="keywordtype">int</span>*) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l03035"></a>03035       ths-&gt;<a class="code" href="structnfft__plan.html#877d6cbe17ec77a9e66bdbea3cfafe0a" title="Indices in source/target vector for PRE_FULL_PSI.">psi_index_g</a> = (<span class="keywordtype">int</span>*) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>*lprod*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l03036"></a>03036   }
<a name="l03037"></a>03037 
<a name="l03038"></a>03038   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#gd3fe6867a3351441c6f44dd5a3746f5b" title="If this flag is set, fftw_init/fftw_finalize is called.">FFTW_INIT</a>)
<a name="l03039"></a>03039   {
<a name="l03040"></a>03040     ths-&gt;<a class="code" href="structnfft__plan.html#2190e7201c55214d153b4d91eaa7efda" title="Input of fftw.">g1</a>=(<span class="keywordtype">double</span> _Complex*)<a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#d8a5fdac5bcf62d86479c800768fdeb7" title="Total size of FFTW.">n_total</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> _Complex));
<a name="l03041"></a>03041 
<a name="l03042"></a>03042     <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g9193f768d5839892d0e303080c370eaf" title="If this flag is set, FFTW uses disjoint input/output vectors.">FFT_OUT_OF_PLACE</a>)
<a name="l03043"></a>03043       ths-&gt;<a class="code" href="structnfft__plan.html#d96e0aa935ea3589e999c131c43d8a78" title="Output of fftw.">g2</a> = (<span class="keywordtype">double</span> _Complex*) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#d8a5fdac5bcf62d86479c800768fdeb7" title="Total size of FFTW.">n_total</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> _Complex));
<a name="l03044"></a>03044     <span class="keywordflow">else</span>
<a name="l03045"></a>03045       ths-&gt;<a class="code" href="structnfft__plan.html#d96e0aa935ea3589e999c131c43d8a78" title="Output of fftw.">g2</a> = ths-&gt;<a class="code" href="structnfft__plan.html#2190e7201c55214d153b4d91eaa7efda" title="Input of fftw.">g1</a>;
<a name="l03046"></a>03046 
<a name="l03047"></a>03047     ths-&gt;<a class="code" href="structnfft__plan.html#84d87c06b22ddb3e725c61061cf4d46d" title="Forward FFTW plan.">my_fftw_plan1</a> = fftw_plan_dft(ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>, ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>, ths-&gt;<a class="code" href="structnfft__plan.html#2190e7201c55214d153b4d91eaa7efda" title="Input of fftw.">g1</a>, ths-&gt;<a class="code" href="structnfft__plan.html#d96e0aa935ea3589e999c131c43d8a78" title="Output of fftw.">g2</a>, FFTW_FORWARD, ths-&gt;<a class="code" href="structnfft__plan.html#530aea04dba32fb2a41287b4581b1805" title="Flags for the FFTW, default is FFTW_ESTIMATE| FFTW_DESTROY_INPUT.">fftw_flags</a>);
<a name="l03048"></a>03048     ths-&gt;<a class="code" href="structnfft__plan.html#228dee0f91c2f326407517c27bc5105e" title="Backward FFTW plan.">my_fftw_plan2</a> = fftw_plan_dft(ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>, ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>, ths-&gt;<a class="code" href="structnfft__plan.html#d96e0aa935ea3589e999c131c43d8a78" title="Output of fftw.">g2</a>, ths-&gt;<a class="code" href="structnfft__plan.html#2190e7201c55214d153b4d91eaa7efda" title="Input of fftw.">g1</a>,
<a name="l03049"></a>03049       FFTW_BACKWARD, ths-&gt;<a class="code" href="structnfft__plan.html#530aea04dba32fb2a41287b4581b1805" title="Flags for the FFTW, default is FFTW_ESTIMATE| FFTW_DESTROY_INPUT.">fftw_flags</a>);
<a name="l03050"></a>03050   }
<a name="l03051"></a>03051 
<a name="l03052"></a>03052   ths-&gt;<a class="code" href="structnfft__plan.html#9ebd66f2964cca6a02fc50d640df3557" title="Pointer to the own transform.">mv_trafo</a> = (void (*) (<span class="keywordtype">void</span>* ))<a class="code" href="group__nfft.html#g9f1e6bd9f7f956a8679e6b413c97b421" title="Computes a NFFT, see the definition.">nfft_trafo</a>;
<a name="l03053"></a>03053   ths-&gt;<a class="code" href="structnfft__plan.html#bbe724645c96ef34c3e98d821f6648a3" title="Pointer to the own adjoint.">mv_adjoint</a> = (void (*) (<span class="keywordtype">void</span>* ))<a class="code" href="group__nfft.html#g4b44c1dd52026dcb494dc735f0fa5b08" title="Computes an adjoint NFFT, see the definition.">nfft_adjoint</a>;
<a name="l03054"></a>03054 }
<a name="l03055"></a>03055 
<a name="l03056"></a>03056 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#g1dfeaf18f3735f035afa62ca768d99c4" title="Initialisation of a transform plan, simple.">nfft_init</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths, <span class="keywordtype">int</span> d, <span class="keywordtype">int</span> *N, <span class="keywordtype">int</span> M_total)
<a name="l03057"></a><a class="code" href="group__nfft.html#g1dfeaf18f3735f035afa62ca768d99c4">03057</a> {
<a name="l03058"></a>03058   <span class="keywordtype">int</span> t;                                
<a name="l03060"></a>03060   ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a> = d;
<a name="l03061"></a>03061 
<a name="l03062"></a>03062   ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>=(<span class="keywordtype">int</span>*) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(d*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l03063"></a>03063   <span class="keywordflow">for</span>(t = 0;t &lt; d; t++)
<a name="l03064"></a>03064     ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[t] = N[t];
<a name="l03065"></a>03065 
<a name="l03066"></a>03066   ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a> = M_total;
<a name="l03067"></a>03067 
<a name="l03068"></a>03068   ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a> = (<span class="keywordtype">int</span>*) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(d*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l03069"></a>03069   <span class="keywordflow">for</span>(t = 0;t &lt; d; t++)
<a name="l03070"></a>03070     ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[t] = 2*<a class="code" href="group__nfftutil.html#g1de4c3bcd3ccd83cca45b93169c7b7af" title="Computes  such that .">nfft_next_power_of_2</a>(ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[t]);
<a name="l03071"></a>03071 
<a name="l03072"></a>03072   WINDOW_HELP_ESTIMATE_m;
<a name="l03073"></a>03073 
<a name="l03074"></a>03074   ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> = PRE_PHI_HUT| <a class="code" href="group__nfft.html#g959463a5c7723ccef5057ddcb784b40c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_PSI</a>| <a class="code" href="group__nfft.html#g353185384f87de0dc4320a82652ef724" title="If this flag is set, (de)allocation of the node vector is done.">MALLOC_X</a>| <a class="code" href="group__nfft.html#g02d52cb02b6cfdbc3e4d5fd4de1aef9e" title="If this flag is set, (de)allocation of the vector of Fourier coefficients is done...">MALLOC_F_HAT</a>| <a class="code" href="group__nfft.html#ga7b5098f4136080bbe0dd989973e2a69" title="If this flag is set, (de)allocation of the vector of samples is done.">MALLOC_F</a>|
<a name="l03075"></a>03075                     <a class="code" href="group__nfft.html#gd3fe6867a3351441c6f44dd5a3746f5b" title="If this flag is set, fftw_init/fftw_finalize is called.">FFTW_INIT</a>| <a class="code" href="group__nfft.html#g9193f768d5839892d0e303080c370eaf" title="If this flag is set, FFTW uses disjoint input/output vectors.">FFT_OUT_OF_PLACE</a>;
<a name="l03076"></a>03076   ths-&gt;<a class="code" href="structnfft__plan.html#530aea04dba32fb2a41287b4581b1805" title="Flags for the FFTW, default is FFTW_ESTIMATE| FFTW_DESTROY_INPUT.">fftw_flags</a>= FFTW_ESTIMATE| FFTW_DESTROY_INPUT;
<a name="l03077"></a>03077 
<a name="l03078"></a>03078   nfft_init_help(ths);
<a name="l03079"></a>03079 }
<a name="l03080"></a>03080 
<a name="l03081"></a>03081 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#g406f05717c6299b918261c61aaa9de23" title="Initialisation of a transform plan, guru.">nfft_init_guru</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths, <span class="keywordtype">int</span> d, <span class="keywordtype">int</span> *N, <span class="keywordtype">int</span> M_total, <span class="keywordtype">int</span> *n,
<a name="l03082"></a><a class="code" href="group__nfft.html#g406f05717c6299b918261c61aaa9de23">03082</a>       <span class="keywordtype">int</span> m, <span class="keywordtype">unsigned</span> nfft_flags, <span class="keywordtype">unsigned</span> fftw_flags)
<a name="l03083"></a>03083 {
<a name="l03084"></a>03084   <span class="keywordtype">int</span> t;                                
<a name="l03086"></a>03086   ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a> =d;
<a name="l03087"></a>03087   ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>= (<span class="keywordtype">int</span>*) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l03088"></a>03088   <span class="keywordflow">for</span>(t=0; t&lt;d; t++)
<a name="l03089"></a>03089     ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[t]= N[t];
<a name="l03090"></a>03090   ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>= M_total;
<a name="l03091"></a>03091   ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>= (<span class="keywordtype">int</span>*) <a class="code" href="nfft3_8h.html#afe6167438c5de4d3d4c509f66a6694e" title="Include header for FFTW3 library for its complex type.">nfft_malloc</a>(ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l03092"></a>03092   <span class="keywordflow">for</span>(t=0; t&lt;d; t++)
<a name="l03093"></a>03093     ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>[t]= n[t];
<a name="l03094"></a>03094   ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>= m;
<a name="l03095"></a>03095   ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a>= nfft_flags;
<a name="l03096"></a>03096   ths-&gt;<a class="code" href="structnfft__plan.html#530aea04dba32fb2a41287b4581b1805" title="Flags for the FFTW, default is FFTW_ESTIMATE| FFTW_DESTROY_INPUT.">fftw_flags</a>= fftw_flags;
<a name="l03097"></a>03097 
<a name="l03098"></a>03098   nfft_init_help(ths);
<a name="l03099"></a>03099 }
<a name="l03100"></a>03100 
<a name="l03101"></a>03101 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#g01dbd2cfc9cc8577fc097e607e3c845f" title="Initialisation of a transform plan, wrapper d=1.">nfft_init_1d</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths, <span class="keywordtype">int</span> N1, <span class="keywordtype">int</span> M_total)
<a name="l03102"></a><a class="code" href="group__nfft.html#g01dbd2cfc9cc8577fc097e607e3c845f">03102</a> {
<a name="l03103"></a>03103   <span class="keywordtype">int</span> N[1];
<a name="l03104"></a>03104 
<a name="l03105"></a>03105   N[0]=N1;
<a name="l03106"></a>03106   <a class="code" href="group__nfft.html#g1dfeaf18f3735f035afa62ca768d99c4" title="Initialisation of a transform plan, simple.">nfft_init</a>(ths,1,N,M_total);
<a name="l03107"></a>03107 }
<a name="l03108"></a>03108 
<a name="l03109"></a>03109 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#g54ab08124f47fe412b2979abdc28cc16" title="Initialisation of a transform plan, wrapper d=2.">nfft_init_2d</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths, <span class="keywordtype">int</span> N1, <span class="keywordtype">int</span> N2, <span class="keywordtype">int</span> M_total)
<a name="l03110"></a><a class="code" href="group__nfft.html#g54ab08124f47fe412b2979abdc28cc16">03110</a> {
<a name="l03111"></a>03111   <span class="keywordtype">int</span> N[2];
<a name="l03112"></a>03112 
<a name="l03113"></a>03113   N[0]=N1;
<a name="l03114"></a>03114   N[1]=N2;
<a name="l03115"></a>03115   <a class="code" href="group__nfft.html#g1dfeaf18f3735f035afa62ca768d99c4" title="Initialisation of a transform plan, simple.">nfft_init</a>(ths,2,N,M_total);
<a name="l03116"></a>03116 }
<a name="l03117"></a>03117 
<a name="l03118"></a>03118 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#g67493342a23bdbb4301063f96e13fd88" title="Initialisation of a transform plan, wrapper d=3.">nfft_init_3d</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths, <span class="keywordtype">int</span> N1, <span class="keywordtype">int</span> N2, <span class="keywordtype">int</span> N3, <span class="keywordtype">int</span> M_total)
<a name="l03119"></a><a class="code" href="group__nfft.html#g67493342a23bdbb4301063f96e13fd88">03119</a> {
<a name="l03120"></a>03120   <span class="keywordtype">int</span> N[3];
<a name="l03121"></a>03121 
<a name="l03122"></a>03122   N[0]=N1;
<a name="l03123"></a>03123   N[1]=N2;
<a name="l03124"></a>03124   N[2]=N3;
<a name="l03125"></a>03125   <a class="code" href="group__nfft.html#g1dfeaf18f3735f035afa62ca768d99c4" title="Initialisation of a transform plan, simple.">nfft_init</a>(ths,3,N,M_total);
<a name="l03126"></a>03126 }
<a name="l03127"></a>03127 
<a name="l03128"></a>03128 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#g7af648ae0503976536b8db18200f99fe" title="Checks a transform plan for frequently used bad parameter.">nfft_check</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l03129"></a><a class="code" href="group__nfft.html#g7af648ae0503976536b8db18200f99fe">03129</a> {
<a name="l03130"></a>03130   <span class="keywordtype">int</span> j;
<a name="l03131"></a>03131 
<a name="l03132"></a>03132   <span class="keywordflow">for</span>(j=0;j&lt;ths-&gt;<a class="code" href="structnfft__plan.html#df33ce87c35b396c50d214d9bdeeefe6" title="Total number of samples.">M_total</a>*ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>;j++)
<a name="l03133"></a>03133     <span class="keywordflow">if</span>((ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>[j]&lt;-0.5) || (ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>[j]&gt;=0.5))
<a name="l03134"></a>03134       fprintf(stderr,<span class="stringliteral">"nfft_check: ths-&gt;x[%d]=%e out of range [-0.5,0.5)\n"</span>,
<a name="l03135"></a>03135         j,ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>[j]);
<a name="l03136"></a>03136 
<a name="l03137"></a>03137   <span class="keywordflow">for</span>(j=0;j&lt;ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>;j++)
<a name="l03138"></a>03138     {
<a name="l03139"></a>03139       <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#09340f6465c23f3d94636f4f0da30f8a" title="Oversampling-factor.">sigma</a>[j]&lt;=1)
<a name="l03140"></a>03140   fprintf(stderr,<span class="stringliteral">"nfft_check: oversampling factor too small\n"</span>);
<a name="l03141"></a>03141 
<a name="l03142"></a>03142       <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[j]&lt;=ths-&gt;<a class="code" href="structnfft__plan.html#dbac137859fb87be7be73a5443de8cef" title="Cut-off parameter of the window function, default value is 6 (KAISER_BESSEL), 9 (SINC_POWER)...">m</a>)
<a name="l03143"></a>03143   fprintf(stderr,
<a name="l03144"></a>03144     <span class="stringliteral">"nfft_check: polynomial degree N is smaller than cut-off m\n"</span>);
<a name="l03145"></a>03145 
<a name="l03146"></a>03146       <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>[j]%2==1)
<a name="l03147"></a>03147   fprintf(stderr,<span class="stringliteral">"nfft_check: polynomial degree N has to be even\n"</span>);
<a name="l03148"></a>03148     }
<a name="l03149"></a>03149 }
<a name="l03150"></a>03150 
<a name="l03151"></a>03151 <span class="keywordtype">void</span> <a class="code" href="group__nfft.html#g614f9f7af5b0d5491afa9495393c4dc3" title="Destroys a transform plan.">nfft_finalize</a>(<a class="code" href="structnfft__plan.html" title="Structure for a NFFT plan.">nfft_plan</a> *ths)
<a name="l03152"></a><a class="code" href="group__nfft.html#g614f9f7af5b0d5491afa9495393c4dc3">03152</a> {
<a name="l03153"></a>03153   <span class="keywordtype">int</span> t; <span class="comment">/* index over dimensions */</span>
<a name="l03154"></a>03154 
<a name="l03155"></a>03155   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#gd3fe6867a3351441c6f44dd5a3746f5b" title="If this flag is set, fftw_init/fftw_finalize is called.">FFTW_INIT</a>)
<a name="l03156"></a>03156   {
<a name="l03157"></a>03157     fftw_destroy_plan(ths-&gt;<a class="code" href="structnfft__plan.html#228dee0f91c2f326407517c27bc5105e" title="Backward FFTW plan.">my_fftw_plan2</a>);
<a name="l03158"></a>03158     fftw_destroy_plan(ths-&gt;<a class="code" href="structnfft__plan.html#84d87c06b22ddb3e725c61061cf4d46d" title="Forward FFTW plan.">my_fftw_plan1</a>);
<a name="l03159"></a>03159 
<a name="l03160"></a>03160     <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g9193f768d5839892d0e303080c370eaf" title="If this flag is set, FFTW uses disjoint input/output vectors.">FFT_OUT_OF_PLACE</a>)
<a name="l03161"></a>03161       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#d96e0aa935ea3589e999c131c43d8a78" title="Output of fftw.">g2</a>);
<a name="l03162"></a>03162 
<a name="l03163"></a>03163     <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#2190e7201c55214d153b4d91eaa7efda" title="Input of fftw.">g1</a>);
<a name="l03164"></a>03164   }
<a name="l03165"></a>03165 
<a name="l03166"></a>03166   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g7ad8a7e19519b16340dabec48899c6a4" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FULL_PSI</a>)
<a name="l03167"></a>03167     {
<a name="l03168"></a>03168       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#877d6cbe17ec77a9e66bdbea3cfafe0a" title="Indices in source/target vector for PRE_FULL_PSI.">psi_index_g</a>);
<a name="l03169"></a>03169       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#2ed144cf7d6043a93c07b6f6ba7bbe2a" title="Indices in source/target vector for PRE_FULL_PSI.">psi_index_f</a>);
<a name="l03170"></a>03170       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>);
<a name="l03171"></a>03171     }
<a name="l03172"></a>03172 
<a name="l03173"></a>03173   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g959463a5c7723ccef5057ddcb784b40c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_PSI</a>)
<a name="l03174"></a>03174     <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>);
<a name="l03175"></a>03175 
<a name="l03176"></a>03176   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g9c5a5ab61009a801082897ca40a1658c" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_FG_PSI</a>)
<a name="l03177"></a>03177     <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>);
<a name="l03178"></a>03178 
<a name="l03179"></a>03179   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#gbb1ad048b695cb806baf010c5d1b2caf" title="If this flag is set, the convolution step (the multiplication with the sparse matrix...">PRE_LIN_PSI</a>)
<a name="l03180"></a>03180     <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#0330a1c3ae461fa9156ba0ecbe17bb7c" title="Precomputed data for the sparse matrix , size depends on precomputation scheme.">psi</a>);
<a name="l03181"></a>03181 
<a name="l03182"></a>03182   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; PRE_PHI_HUT)
<a name="l03183"></a>03183     {
<a name="l03184"></a>03184       <span class="keywordflow">for</span>(t=0; t&lt;ths-&gt;<a class="code" href="structnfft__plan.html#e39d4867eac948d96abbe3fc930b39a8" title="Dimension, rank.">d</a>; t++)
<a name="l03185"></a>03185         <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>[t]);
<a name="l03186"></a>03186       <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#a5dd76324152be95967c0a4717e8e4ce" title="Precomputed data for the diagonal matrix , size is  doubles.">c_phi_inv</a>);
<a name="l03187"></a>03187     }
<a name="l03188"></a>03188 
<a name="l03189"></a>03189   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#ga7b5098f4136080bbe0dd989973e2a69" title="If this flag is set, (de)allocation of the vector of samples is done.">MALLOC_F</a>)
<a name="l03190"></a>03190     <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#fa27a166f809acf70ae27e5e6f28daa5" title="Vector of samples, \ size is M_total float types.">f</a>);
<a name="l03191"></a>03191 
<a name="l03192"></a>03192   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g02d52cb02b6cfdbc3e4d5fd4de1aef9e" title="If this flag is set, (de)allocation of the vector of Fourier coefficients is done...">MALLOC_F_HAT</a>)
<a name="l03193"></a>03193     <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#23409aec68871e9a56f11711e2891691" title="Vector of Fourier coefficients, \ size is N_total float_types.">f_hat</a>);
<a name="l03194"></a>03194 
<a name="l03195"></a>03195   <span class="keywordflow">if</span>(ths-&gt;<a class="code" href="structnfft__plan.html#2721da68a3a5b1846ecca8395d76bb1d" title="Flags for precomputation, (de)allocation, and FFTW usage, default setting is PRE_PHI_HUT|...">nfft_flags</a> &amp; <a class="code" href="group__nfft.html#g353185384f87de0dc4320a82652ef724" title="If this flag is set, (de)allocation of the node vector is done.">MALLOC_X</a>)
<a name="l03196"></a>03196   <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#7eb64fb5fedfba0ec75261e777e020c0" title="Nodes in time/spatial domain, size is  doubles.">x</a>);
<a name="l03197"></a>03197 
<a name="l03198"></a>03198   WINDOW_HELP_FINALIZE;
<a name="l03199"></a>03199 
<a name="l03200"></a>03200   <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#09340f6465c23f3d94636f4f0da30f8a" title="Oversampling-factor.">sigma</a>);
<a name="l03201"></a>03201   <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#a8db04bb03357b831a1958f9a802e0ae" title="FFTW length, equal to sigma*N, default is the power of 2 such that .">n</a>);
<a name="l03202"></a>03202   <a class="code" href="nfft3_8h.html#b8a0db03dda1317a8a3d922e0e4e8aaa">nfft_free</a>(ths-&gt;<a class="code" href="structnfft__plan.html#307fb9647dee8b4a6acbd1ab26f67fa9" title="Multi bandwidth.">N</a>);
<a name="l03203"></a>03203 }
</pre></div></div>
    <hr size="1"/>
    Generated on 23 Dec 2009 by Doxygen 1.5.6
  </body>
</html>
