<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
    <title>
      NFFT 3.0.2 API Reference - NFFT: nfsft.c Source File
    </title>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <table>
      <tr>
        <td valign="top">
          <img src="images/logo.png" alt="NFFT Logo">
        </td>
        <td align="left" valign="bottom" width="100%">
          <H1nc>3.0.2 API Reference</H1nc>
        </td>
      </tr>
    </table>  
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000003.html">kernel</a>&nbsp;/&nbsp;<a class="el" href="dir_000004.html">nfsft</a></div>
<h1>nfsft.c</h1><a href="nfsft_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00007 <span class="comment">/* Include standard C headers. */</span>
00008 <span class="preprocessor">#include &lt;math.h&gt;</span>
00009 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00010 <span class="preprocessor">#include &lt;string.h&gt;</span>
00011 <span class="preprocessor">#include &lt;string.h&gt;</span>
00012 
00013 <span class="comment">/* Include NFFT3 library header. */</span>
00014 <span class="preprocessor">#include "<a class="code" href="nfft3_8h.html">nfft3.h</a>"</span>
00015 
00016 <span class="comment">/* Include private associated Legendre functions header. */</span>
00017 <span class="preprocessor">#include "legendre.h"</span>
00018 
00019 <span class="comment">/* Include private API header. */</span>
00020 <span class="preprocessor">#include "<a class="code" href="api_8h.html">api.h</a>"</span>
00021 
00022 <span class="comment">/* Include NFFT3 utilities header. */</span>
00023 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00024 
<a name="l00034"></a><a class="code" href="group__nfsft.html#ga46">00034</a> <span class="preprocessor">#define NFSFT_DEFAULT_NFFT_CUTOFF 6</span>
00035 <span class="preprocessor"></span>
<a name="l00041"></a><a class="code" href="group__nfsft.html#ga47">00041</a> <span class="preprocessor">#define NFSFT_DEFAULT_THRESHOLD 1000</span>
00042 <span class="preprocessor"></span>
<a name="l00048"></a><a class="code" href="group__nfsft.html#ga48">00048</a> <span class="preprocessor">#define NFSFT_BREAK_EVEN 5</span>
00049 <span class="preprocessor"></span>
<a name="l00056"></a><a class="code" href="group__nfsft.html#ga0">00056</a> <span class="keyword">static</span> <span class="keyword">struct </span><a class="code" href="structnfsft__wisdom.html">nfsft_wisdom</a> <a class="code" href="group__nfsft.html#ga0">wisdom</a> = {<span class="keyword">false</span>,0U};
00057 
<a name="l00080"></a><a class="code" href="group__nfsft.html#ga23">00080</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__nfsft.html#ga23">c2e</a>(<a class="code" href="structnfsft__plan.html">nfsft_plan</a> *plan)
00081 {
00082   <span class="keywordtype">int</span> k;               
00083   <span class="keywordtype">int</span> n;               
00084   <span class="keywordtype">double</span> complex last; 
00085   <span class="keywordtype">double</span> complex act;  
00086   <span class="keywordtype">double</span> complex *xp;  
00087   <span class="keywordtype">double</span> complex *xm;  
00088   <span class="keywordtype">int</span> low;             
00089   <span class="keywordtype">int</span> up;              
00090   <span class="keywordtype">int</span> lowe;            
00091   <span class="keywordtype">int</span> upe;             
00093   <span class="comment">/* Set the first row to order to zero since it is unused. */</span>
00094   memset(plan-&gt;f_hat_intern,0U,(2*plan-&gt;N+2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00095 
00096   <span class="comment">/* Determine lower and upper bounds for loop processing even terms. */</span>
00097   lowe = -plan-&gt;N + (plan-&gt;N%2);
00098   upe = -lowe;
00099 
00100   <span class="comment">/* Process even terms. */</span>
00101   <span class="keywordflow">for</span> (n = lowe; n &lt;= upe; n += 2)
00102   {
00103     <span class="comment">/* Compute new coefficients \f$\left(c_k^n\right)_{k=-M,\ldots,M}\f$ from</span>
00104 <span class="comment">     * old coefficients $\left(b_k^n\right)_{k=0,\ldots,M}$. */</span>
00105     xm = &amp;(plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(-1,n,plan)]);
00106     xp = &amp;(plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(+1,n,plan)]);
00107     <span class="keywordflow">for</span>(k = 1; k &lt;= plan-&gt;N; k++)
00108     {
00109       *xp *= 0.5;
00110       *xm-- = *xp++;
00111     }
00112     <span class="comment">/* Set the first coefficient in the array corresponding to this order to</span>
00113 <span class="comment">     * zero since it is unused. */</span>
00114     *xm = 0.0;
00115   }
00116 
00117   <span class="comment">/* Determine lower and upper bounds for loop processing odd terms. */</span>
00118   low = -plan-&gt;N + (1-plan-&gt;N%2);
00119   up = -low;
00120 
00121   <span class="comment">/* Process odd terms incorporating the additional sine term</span>
00122 <span class="comment">   * \f$\sin \vartheta\f$. */</span>
00123   <span class="keywordflow">for</span> (n = low; n &lt;= up; n += 2)
00124   {
00125     <span class="comment">/* Compute new coefficients \f$\left(c_k^n\right)_{k=-M,\ldots,M}\f$ from</span>
00126 <span class="comment">     * old coefficients $\left(b_k^n\right)_{k=0,\ldots,M-1}$ incorporating</span>
00127 <span class="comment">     * the additional term \f$\sin \vartheta\f$. */</span>
00128     plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(0,n,plan)] *= 2.0;
00129     xp = &amp;(plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(-plan-&gt;N-1,n,plan)]);
00130     <span class="comment">/* Set the first coefficient in the array corresponding to this order to zero</span>
00131 <span class="comment">     * since it is unused. */</span>
00132     *xp++ = 0.0;
00133     xm = &amp;(plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(plan-&gt;N,n,plan)]);
00134     last = *xm;
00135     *xm = 0.5 * I * (0.5*xm[-1]);
00136     *xp++ = -(*xm--);
00137     <span class="keywordflow">for</span> (k = plan-&gt;N-1; k &gt; 0; k--)
00138     {
00139       act = *xm;
00140       *xm = 0.5 * I * (0.5*(xm[-1] - last));
00141       *xp++ = -(*xm--);
00142       last = act;
00143     }
00144     *xm = 0.0;
00145   }
00146 }
00147 
<a name="l00158"></a><a class="code" href="group__nfsft.html#ga24">00158</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group__nfsft.html#ga24">c2e_transposed</a>(<a class="code" href="structnfsft__plan.html">nfsft_plan</a> *plan)
00159 {
00160   <span class="keywordtype">int</span> k;               
00161   <span class="keywordtype">int</span> n;               
00162   <span class="keywordtype">double</span> complex last; 
00163   <span class="keywordtype">double</span> complex act;  
00164   <span class="keywordtype">double</span> complex *xp;  
00165   <span class="keywordtype">double</span> complex *xm;  
00166   <span class="keywordtype">int</span> low;             
00167   <span class="keywordtype">int</span> up;              
00168   <span class="keywordtype">int</span> lowe;            
00169   <span class="keywordtype">int</span> upe;             
00171   <span class="comment">/* Determine lower and upper bounds for loop processing even terms. */</span>
00172   lowe = -plan-&gt;N + (plan-&gt;N%2);
00173   upe = -lowe;
00174 
00175   <span class="comment">/* Process even terms. */</span>
00176   <span class="keywordflow">for</span> (n = lowe; n &lt;= upe; n += 2)
00177   {
00178     <span class="comment">/* Compute new coefficients \f$\left(b_k^n\right)_{k=0,\ldots,M}\f$ from</span>
00179 <span class="comment">     * old coefficients $\left(c_k^n\right)_{k=-M,\ldots,M}$. */</span>
00180     xm = &amp;(plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(-1,n,plan)]);
00181     xp = &amp;(plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(+1,n,plan)]);
00182     <span class="keywordflow">for</span>(k = 1; k &lt;= plan-&gt;N; k++)
00183     {
00184       *xp += *xm--;
00185       *xp++ *= 0.5;;
00186     }
00187   }
00188 
00189   <span class="comment">/* Determine lower and upper bounds for loop processing odd terms. */</span>
00190   low = -plan-&gt;N + (1-plan-&gt;N%2);
00191   up = -low;
00192 
00193   <span class="comment">/* Process odd terms. */</span>
00194   <span class="keywordflow">for</span> (n = low; n &lt;= up; n += 2)
00195   {
00196     <span class="comment">/* Compute new coefficients \f$\left(b_k^n\right)_{k=0,\ldots,M-1}\f$ from</span>
00197 <span class="comment">     * old coefficients $\left(c_k^n\right)_{k=0,\ldots,M-1}$. */</span>
00198     xm = &amp;(plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(-1,n,plan)]);
00199     xp = &amp;(plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(+1,n,plan)]);
00200     <span class="keywordflow">for</span>(k = 1; k &lt;= plan-&gt;N; k++)
00201     {
00202       *xp++ -= *xm--;
00203     }
00204 
00205     plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(0,n,plan)] =
00206       -0.25*I*plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(1,n,plan)];
00207     last = plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(1,n,plan)];
00208     plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(1,n,plan)] =
00209       -0.25*I*plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(2,n,plan)];
00210 
00211     xp = &amp;(plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(2,n,plan)]);
00212     <span class="keywordflow">for</span> (k = 2; k &lt; plan-&gt;N; k++)
00213     {
00214       act = *xp;
00215       *xp = -0.25 * I * (xp[1] - last);
00216       xp++;
00217       last = act;
00218     }
00219     *xp = 0.25 * I * last;
00220 
00221     plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(0,n,plan)] *= 2.0;
00222   }
00223 }
00224 
<a name="l00225"></a><a class="code" href="group__nfsft.html#ga1">00225</a> <span class="keywordtype">void</span> <a class="code" href="group__nfsft.html#ga1">nfsft_init</a>(<a class="code" href="structnfsft__plan.html">nfsft_plan</a> *plan, <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> M)
00226 {
00227   <span class="comment">/* Call nfsft_init_advanced with default flags. */</span>
00228   <a class="code" href="group__nfsft.html#ga2">nfsft_init_advanced</a>(plan, N, M, <a class="code" href="group__nfsft.html#ga28">NFSFT_MALLOC_X</a> | <a class="code" href="group__nfsft.html#ga30">NFSFT_MALLOC_F</a> |
00229     <a class="code" href="group__nfsft.html#ga29">NFSFT_MALLOC_F_HAT</a>);
00230 }
00231 
<a name="l00232"></a><a class="code" href="group__nfsft.html#ga2">00232</a> <span class="keywordtype">void</span> <a class="code" href="group__nfsft.html#ga2">nfsft_init_advanced</a>(<a class="code" href="structnfsft__plan.html">nfsft_plan</a>* plan, <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> M,
00233                          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
00234 {
00235   <span class="comment">/* Call nfsft_init_guru with the flags and default NFFT cut-off. */</span>
00236   <a class="code" href="group__nfsft.html#ga3">nfsft_init_guru</a>(plan, N, M, flags, <a class="code" href="group__nfft.html#ga16">PRE_PHI_HUT</a> | <a class="code" href="group__nfft.html#ga20">PRE_PSI</a> | <a class="code" href="group__nfft.html#ga26">FFTW_INIT</a> |
00237                          <a class="code" href="group__nfft.html#ga25">FFT_OUT_OF_PLACE</a>, <a class="code" href="group__nfsft.html#ga46">NFSFT_DEFAULT_NFFT_CUTOFF</a>);
00238 }
00239 
<a name="l00240"></a><a class="code" href="group__nfsft.html#ga3">00240</a> <span class="keywordtype">void</span> <a class="code" href="group__nfsft.html#ga3">nfsft_init_guru</a>(<a class="code" href="structnfsft__plan.html">nfsft_plan</a> *plan, <span class="keywordtype">int</span> N, <span class="keywordtype">int</span> M, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags,
00241   <span class="keywordtype">int</span> nfft_flags, <span class="keywordtype">int</span> nfft_cutoff)
00242 {
00243   <span class="keywordtype">int</span> *nfft_size; <span class="comment">/*&lt; NFFT size                                              */</span>
00244   <span class="keywordtype">int</span> *fftw_size; <span class="comment">/*&lt; FFTW size                                              */</span>
00245 
00246   <span class="comment">/* Save the flags in the plan. */</span>
00247   plan-&gt;<a class="code" href="structnfsft__wisdom.html#o1">flags</a> = flags;
00248 
00249   <span class="comment">/* Save the bandwidth N and the number of samples M in the plan. */</span>
00250   plan-&gt;N = N;
00251   plan-&gt;M_total = M;
00252 
00253   <span class="comment">/* Calculate the next greater power of two with respect to the bandwidth N</span>
00254 <span class="comment">   * and the corresponding exponent. */</span>
00255   <span class="comment">//next_power_of_2_exp(plan-&gt;N,&amp;plan-&gt;NPT,&amp;plan-&gt;t);</span>
00256 
00257   <span class="comment">/* Save length of array of Fourier coefficients. Owing to the data layout the</span>
00258 <span class="comment">   * length is (2N+2)(2N+2) */</span>
00259   plan-&gt;N_total = (2*plan-&gt;N+2)*(2*plan-&gt;N+2);
00260 
00261   <span class="comment">/* Allocate memory for auxilliary array of spherical Fourier coefficients,</span>
00262 <span class="comment">   * if neccesary. */</span>
00263   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga31">NFSFT_PRESERVE_F_HAT</a>)
00264   {
00265     plan-&gt;f_hat_intern = (<span class="keywordtype">double</span> complex*) calloc(plan-&gt;N_total,
00266               <span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00267   }
00268 
00269   <span class="comment">/* Allocate memory for spherical Fourier coefficients, if neccesary. */</span>
00270   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga29">NFSFT_MALLOC_F_HAT</a>)
00271   {
00272     plan-&gt;f_hat = (<span class="keywordtype">double</span> complex*) calloc(plan-&gt;N_total,
00273              <span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00274   }
00275 
00276   <span class="comment">/* Allocate memory for samples, if neccesary. */</span>
00277   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga30">NFSFT_MALLOC_F</a>)
00278   {
00279     plan-&gt;f = (<span class="keywordtype">double</span> complex*) calloc(plan-&gt;M_total,<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00280   }
00281 
00282   <span class="comment">/* Allocate memory for nodes, if neccesary. */</span>
00283   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga28">NFSFT_MALLOC_X</a>)
00284   {
00285     plan-&gt;x = (<span class="keywordtype">double</span>*) calloc(plan-&gt;M_total,2*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00286   }
00287 
00288   <span class="comment">/* Check if fast algorithm is activated. */</span>
00289   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga38">NFSFT_NO_FAST_ALGORITHM</a>)
00290   {
00291   }
00292   <span class="keywordflow">else</span>
00293   {
00294       nfft_size = (<span class="keywordtype">int</span>*)malloc(2*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00295       fftw_size = (<span class="keywordtype">int</span>*)malloc(2*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00296 
00298       nfft_size[0] = 2*plan-&gt;N+2;
00299       nfft_size[1] = 2*plan-&gt;N+2;
00300       fftw_size[0] = 4*plan-&gt;N;
00301       fftw_size[1] = 4*plan-&gt;N;
00302 
00304       <a class="code" href="group__nfft.html#ga9">nfft_init_guru</a>(&amp;plan-&gt;plan_nfft, 2, nfft_size, plan-&gt;M_total, fftw_size,
00305          nfft_cutoff, nfft_flags,
00306          FFTW_ESTIMATE | FFTW_DESTROY_INPUT);
00307 
00308       <span class="comment">/* Assign angle array. */</span>
00309       plan-&gt;plan_nfft.x = plan-&gt;x;
00310       <span class="comment">/* Assign result array. */</span>
00311       plan-&gt;plan_nfft.f = plan-&gt;f;
00312       <span class="comment">/* Assign Fourier coefficients array. */</span>
00313       plan-&gt;plan_nfft.f_hat = plan-&gt;f_hat;
00314 
00317       <span class="comment">/* Precompute. */</span>
00318       <span class="comment">//nfft_precompute_one_psi(&amp;plan-&gt;plan_nfft);</span>
00319 
00320       <span class="comment">/* Free auxilliary arrays. */</span>
00321       free(nfft_size);
00322       free(fftw_size);
00323   }
00324 }
00325 
<a name="l00326"></a><a class="code" href="group__nfsft.html#ga4">00326</a> <span class="keywordtype">void</span> <a class="code" href="group__nfsft.html#ga4">nfsft_precompute</a>(<span class="keywordtype">int</span> N, <span class="keywordtype">double</span> kappa, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nfsft_flags,
00327   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fpt_flags)
00328 {
00329   <span class="keywordtype">int</span> n; <span class="comment">/*&lt; The order n                                                     */</span>
00330 
00331   <span class="comment">/*  Check if already initialized. */</span>
00332   <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o0">initialized</a> == <span class="keyword">true</span>)
00333   {
00334     <span class="keywordflow">return</span>;
00335   }
00336 
00337   <span class="comment">/* Save the precomputation flags. */</span>
00338   <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o1">flags</a> = nfsft_flags;
00339 
00340   <span class="comment">/* Compute and save N_max = 2^{\ceil{log_2 N}} as next greater</span>
00341 <span class="comment">   * power of two with respect to N. */</span>
00342   <a class="code" href="group__nfftutil.html#ga5">nfft_next_power_of_2_exp</a>(N,&amp;<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>,&amp;<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o3">T_MAX</a>);
00343 
00344   <span class="comment">/* Check, if precomputation for direct algorithms needs to be performed. */</span>
00345   <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o1">flags</a> &amp; <a class="code" href="group__nfsft.html#ga37">NFSFT_NO_DIRECT_ALGORITHM</a>)
00346   {
00347     <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a> = NULL;
00348     <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o5">beta</a> = NULL;
00349     <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a> = NULL;
00350   }
00351   <span class="keywordflow">else</span>
00352   {
00353     <span class="comment">/* Allocate memory for three-term recursion coefficients. */</span>
00354     <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a> = (<span class="keywordtype">double</span>*) malloc((<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>+1)*(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>+2)*
00355       <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00356     <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o5">beta</a> = (<span class="keywordtype">double</span>*) malloc((<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>+1)*(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>+2)*
00357       <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00358     <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a> = (<span class="keywordtype">double</span>*) malloc((<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>+1)*(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>+2)*
00359       <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00361     <span class="comment">/* Compute three-term recurrence coefficients alpha_k^n, beta_k^n, and</span>
00362 <span class="comment">     * gamma_k^n. */</span>
00363     <a class="code" href="group__nfsft.html#ga18">alpha_al_all</a>(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a>,<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>);
00364     <a class="code" href="group__nfsft.html#ga19">beta_al_all</a>(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o5">beta</a>,<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>);
00365     <a class="code" href="group__nfsft.html#ga20">gamma_al_all</a>(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a>,<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>);
00366   }
00367 
00368   <span class="comment">/* Check, if precomputation for fast algorithms needs to be performed. */</span>
00369   <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o1">flags</a> &amp; <a class="code" href="group__nfsft.html#ga38">NFSFT_NO_FAST_ALGORITHM</a>)
00370   {
00371   }
00372   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a> &gt;= <a class="code" href="group__nfsft.html#ga48">NFSFT_BREAK_EVEN</a>)
00373   {
00374     <span class="comment">/* Precompute data for DPT/FPT. */</span>
00375 
00376     <span class="comment">/* Check, if recursion coefficients have already been calculated. */</span>
00377     <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a> != NULL)
00378     {
00379       <span class="comment">/* Use the recursion coefficients to precompute FPT data using persistent</span>
00380 <span class="comment">       * arrays. */</span>
00381       <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o8">set</a> = <a class="code" href="group__fpt.html#ga1">fpt_init</a>(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>, <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o3">T_MAX</a>,
00382         fpt_flags | <a class="code" href="group__fpt.html#ga13">FPT_AL_SYMMETRY</a> | <a class="code" href="group__fpt.html#ga11">FPT_PERSISTENT_DATA</a>);
00383       <span class="keywordflow">for</span> (n = 0; n &lt;= <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>; n++)
00384       {
00385         <span class="comment">/*fprintf(stderr,"%d\n",n);</span>
00386 <span class="comment">        fflush(stderr);*/</span>
00387         <span class="comment">/* Precompute data for FPT transformation for order n. */</span>
00388         <a class="code" href="group__fpt.html#ga2">fpt_precompute</a>(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o8">set</a>,n,&amp;<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a>[ROW(n)],&amp;<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o5">beta</a>[ROW(n)],
00389           &amp;<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a>[ROW(n)],n,kappa);
00390       }
00391     }
00392     <span class="keywordflow">else</span>
00393     {
00394     <span class="comment">/* Allocate memory for three-term recursion coefficients. */</span>
00395       <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a> = (<span class="keywordtype">double</span>*) malloc((<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>+2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00396       <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o5">beta</a> = (<span class="keywordtype">double</span>*) malloc((<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>+2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00397       <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a> = (<span class="keywordtype">double</span>*) malloc((<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>+2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00398       <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o8">set</a> = <a class="code" href="group__fpt.html#ga1">fpt_init</a>(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>, <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o3">T_MAX</a>,
00399         fpt_flags | <a class="code" href="group__fpt.html#ga13">FPT_AL_SYMMETRY</a>);
00400       <span class="keywordflow">for</span> (n = 0; n &lt;= <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>; n++)
00401       {
00402         <span class="comment">/*fprintf(stderr,"%d NO_DIRECT\n",n);</span>
00403 <span class="comment">        fflush(stderr);*/</span>
00404         <span class="comment">/* Compute three-term recurrence coefficients alpha_k^n, beta_k^n, and</span>
00405 <span class="comment">         * gamma_k^n. */</span>
00406         alpha_al_row(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a>,<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>,n);
00407         beta_al_row(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o5">beta</a>,<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>,n);
00408         gamma_al_row(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a>,<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>,n);
00409 
00410         <span class="comment">/* Precompute data for FPT transformation for order n. */</span>
00411         <a class="code" href="group__fpt.html#ga2">fpt_precompute</a>(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o8">set</a>,n,<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a>,<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o5">beta</a>,<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a>,n,
00412            kappa);
00413       }
00414       <span class="comment">/* Free auxilliary arrays. */</span>
00415       free(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a>);
00416       free(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o5">beta</a>);
00417       free(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a>);
00418       <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a> = NULL;
00419       <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o5">beta</a> = NULL;
00420       <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a> = NULL;
00421     }
00422   }
00423 
00424   <span class="comment">/* Wisdom has been initialised. */</span>
00425   <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o0">initialized</a> = <span class="keyword">true</span>;
00426 }
00427 
<a name="l00428"></a><a class="code" href="group__nfsft.html#ga5">00428</a> <span class="keywordtype">void</span> <a class="code" href="group__nfsft.html#ga5">nfsft_forget</a>()
00429 {
00430   <span class="comment">/* Check if wisdom has been initialised. */</span>
00431   <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o0">initialized</a> == <span class="keyword">false</span>)
00432   {
00433     <span class="comment">/* Nothing to do. */</span>
00434     <span class="keywordflow">return</span>;
00435   }
00436 
00437   <span class="comment">/* Check, if precomputation for direct algorithms has been performed. */</span>
00438   <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o1">flags</a> &amp; <a class="code" href="group__nfsft.html#ga37">NFSFT_NO_DIRECT_ALGORITHM</a>)
00439   {
00440   }
00441   <span class="keywordflow">else</span>
00442   {
00443     <span class="comment">/* Free arrays holding three-term recurrence coefficients. */</span>
00444     free(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a>);
00445     free(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o5">beta</a>);
00446     free(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a>);
00447     <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a> = NULL;
00448     <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o5">beta</a> = NULL;
00449     <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a> = NULL;
00450   }
00451 
00452   <span class="comment">/* Check, if precomputation for fast algorithms has been performed. */</span>
00453   <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o1">flags</a> &amp; <a class="code" href="group__nfsft.html#ga38">NFSFT_NO_FAST_ALGORITHM</a>)
00454   {
00455   }
00456   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a> &gt;= <a class="code" href="group__nfsft.html#ga48">NFSFT_BREAK_EVEN</a>)
00457   {
00458     <span class="comment">/* Free precomputed data for FPT transformation. */</span>
00459     <a class="code" href="group__fpt.html#ga7">fpt_finalize</a>(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o8">set</a>);
00460   }
00461 
00462   <span class="comment">/* Wisdom is now uninitialised. */</span>
00463   <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o0">initialized</a> = <span class="keyword">false</span>;
00464 }
00465 
00466 
<a name="l00467"></a><a class="code" href="group__nfsft.html#ga10">00467</a> <span class="keywordtype">void</span> <a class="code" href="group__nfsft.html#ga10">nfsft_finalize</a>(<a class="code" href="structnfsft__plan.html">nfsft_plan</a> *plan)
00468 {
00469   <span class="comment">/* Finalise the nfft plan. */</span>
00470   <a class="code" href="group__nfft.html#ga15">nfft_finalize</a>(&amp;plan-&gt;plan_nfft);
00471 
00472   <span class="comment">/* De-allocate memory for auxilliary array of spherical Fourier coefficients,</span>
00473 <span class="comment">   * if neccesary. */</span>
00474   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga31">NFSFT_PRESERVE_F_HAT</a>)
00475   {
00476     free(plan-&gt;f_hat_intern);
00477   }
00478 
00479   <span class="comment">/* De-allocate memory for spherical Fourier coefficients, if necessary. */</span>
00480   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga29">NFSFT_MALLOC_F_HAT</a>)
00481   {
00482     <span class="comment">//fprintf(stderr,"deallocating f_hat\n");</span>
00483     free(plan-&gt;f_hat);
00484   }
00485 
00486   <span class="comment">/* De-allocate memory for samples, if neccesary. */</span>
00487   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga30">NFSFT_MALLOC_F</a>)
00488   {
00489     <span class="comment">//fprintf(stderr,"deallocating f\n");</span>
00490     free(plan-&gt;f);
00491   }
00492 
00493   <span class="comment">/* De-allocate memory for nodes, if neccesary. */</span>
00494   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga28">NFSFT_MALLOC_X</a>)
00495   {
00496     <span class="comment">//fprintf(stderr,"deallocating x\n");</span>
00497     free(plan-&gt;x);
00498   }
00499 }
00500 
<a name="l00501"></a><a class="code" href="group__nfsft.html#ga6">00501</a> <span class="keywordtype">void</span> <a class="code" href="group__nfsft.html#ga6">ndsft_trafo</a>(<a class="code" href="structnfsft__plan.html">nfsft_plan</a> *plan)
00502 {
00503   <span class="keywordtype">int</span> m;               <span class="comment">/*&lt; The node index                                    */</span>
00504   <span class="keywordtype">int</span> k;               <span class="comment">/*&lt; The degree k                                      */</span>
00505   <span class="keywordtype">int</span> n;               <span class="comment">/*&lt; The order n                                       */</span>
00506   <span class="keywordtype">int</span> n_abs;           <span class="comment">/*&lt; The absolute value of the order n, ie n_abs = |n| */</span>
00507   <span class="keywordtype">double</span> *alpha;       <span class="comment">/*&lt; Pointer to current three-term recurrence</span>
00508 <span class="comment">         coefficient alpha_k^n for associated Legendre</span>
00509 <span class="comment">         functions P_k^n                                   */</span>
00510   <span class="keywordtype">double</span> *gamma;       <span class="comment">/*&lt; Pointer to current three-term recurrence</span>
00511 <span class="comment">         coefficient beta_k^n for associated Legendre</span>
00512 <span class="comment">         functions P_k^n                                   */</span>
00513   <span class="keywordtype">double</span> complex *a;   <span class="comment">/*&lt; Pointer to auxilliary array for Clenshaw algor.   */</span>
00514   <span class="keywordtype">double</span> complex it1;  <span class="comment">/*&lt; Auxilliary variable for Clenshaw algorithm        */</span>
00515   <span class="keywordtype">double</span> complex it2;  <span class="comment">/*&lt; Auxilliary variable for Clenshaw algorithm        */</span>
00516   <span class="keywordtype">double</span> complex temp; <span class="comment">/*&lt; Auxilliary variable for Clenshaw algorithm        */</span>
00517   <span class="keywordtype">double</span> complex f_m;  <span class="comment">/*&lt; The final function value f_m = f(x_m) for a</span>
00518 <span class="comment">         single node.                                      */</span>
00519   <span class="keywordtype">double</span> stheta;       <span class="comment">/*&lt; Current angle theta for Clenshaw algorithm        */</span>
00520   <span class="keywordtype">double</span> sphi;         <span class="comment">/*&lt; Current angle phi for Clenshaw algorithm          */</span>
00521 
00522   <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o1">flags</a> &amp; <a class="code" href="group__nfsft.html#ga37">NFSFT_NO_DIRECT_ALGORITHM</a>)
00523   {
00524     <span class="keywordflow">return</span>;
00525   }
00526 
00527   <span class="comment">/* Copy spherical Fourier coefficients, if necessary. */</span>
00528   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga31">NFSFT_PRESERVE_F_HAT</a>)
00529   {
00530     memcpy(plan-&gt;f_hat_intern,plan-&gt;f_hat,plan-&gt;N_total*
00531      <span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00532   }
00533   <span class="keywordflow">else</span>
00534   {
00535     plan-&gt;f_hat_intern = plan-&gt;f_hat;
00536   }
00537 
00538   <span class="comment">/* Check, if we compute with L^2-normalized spherical harmonics. If so,</span>
00539 <span class="comment">   * multiply spherical Fourier coefficients with corresponding normalization</span>
00540 <span class="comment">   * weight. */</span>
00541   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga25">NFSFT_NORMALIZED</a>)
00542   {
00543     <span class="comment">/* Traverse Fourier coefficients array. */</span>
00544     <span class="keywordflow">for</span> (k = 0; k &lt;= plan-&gt;N; k++)
00545     {
00546       <span class="keywordflow">for</span> (n = -k; n &lt;= k; n++)
00547       {
00548         <span class="comment">/* Multiply with normalization weight. */</span>
00549         plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(k,n,plan)] *=
00550           sqrt((2*k+1)/(4.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>));
00551       }
00552     }
00553   }
00554 
00555   <span class="comment">/* Distinguish by bandwidth M. */</span>
00556   <span class="keywordflow">if</span> (plan-&gt;N == 0)
00557   {
00558     <span class="comment">/* N = 0 */</span>
00559 
00560     <span class="comment">/* Constant function */</span>
00561     <span class="keywordflow">for</span> (m = 0; m &lt; plan-&gt;M_total; m++)
00562     {
00563       plan-&gt;f[m] = plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(0,0,plan)];
00564     }
00565   }
00566   <span class="keywordflow">else</span>
00567   {
00568     <span class="comment">/* N &gt; 0 */</span>
00569 
00570     <span class="comment">/* Evaluate</span>
00571 <span class="comment">     *   \sum_{k=0}^N \sum_{n=-k}^k a_k^n P_k^{|n|}(cos theta_m) e^{i n phi_m}</span>
00572 <span class="comment">     *   = \sum_{n=-N}^N \sum_{k=|n|}^N a_k^n P_k^{|n|}(cos theta_m)</span>
00573 <span class="comment">     *     e^{i n phi_m}.</span>
00574 <span class="comment">     */</span>
00575     <span class="keywordflow">for</span> (m = 0; m &lt; plan-&gt;M_total; m++)
00576     {
00577       <span class="comment">/* Scale angle theta from [0,1/2] to [0,pi] and apply cosine. */</span>
00578       stheta = cos(2.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>*plan-&gt;x[2*m+1]);
00579       <span class="comment">/* Scale angle phi from [-1/2,1/2] to [-pi,pi]. */</span>
00580       sphi = 2.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>*plan-&gt;x[2*m];
00581 
00582       <span class="comment">/* Initialize result for current node. */</span>
00583       f_m = 0.0;
00584 
00585       <span class="comment">/* For n = -N,...,N, evaluate</span>
00586 <span class="comment">       *   b_n := \sum_{k=|n|}^N a_k^n P_k^{|n|}(cos theta_m)</span>
00587 <span class="comment">       * using Clenshaw's algorithm.</span>
00588 <span class="comment">       */</span>
00589       <span class="keywordflow">for</span> (n = -plan-&gt;N; n &lt;= plan-&gt;N; n++)
00590       {
00591         <span class="comment">/* Get pointer to Fourier coefficients vector for current order n. */</span>
00592         a = &amp;(plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(0,n,plan)]);
00593 
00594         <span class="comment">/* Take absolute value of n. */</span>
00595         n_abs = abs(n);
00596 
00597         <span class="comment">/* Get pointers to three-term recurrence coefficients arrays. */</span>
00598         alpha = &amp;(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a>[ROW(n_abs)]);
00599         gamma = &amp;(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a>[ROW(n_abs)]);
00600 
00601         <span class="comment">/* Clenshaw's algorithm */</span>
00602         it2 = a[plan-&gt;N];
00603         it1 = a[plan-&gt;N-1];
00604         <span class="keywordflow">for</span> (k = plan-&gt;N; k &gt; n_abs + 1; k--)
00605         {
00606           temp = a[k-2] + it2 * gamma[k];
00607           it2 = it1 + it2 * alpha[k] * stheta;
00608           it1 = temp;
00609         }
00610 
00611         <span class="comment">/* Compute final step if neccesary. */</span>
00612         <span class="keywordflow">if</span> (n_abs &lt; plan-&gt;N)
00613         {
00614           it2 = it1 + it2 * <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a>[ROWK(n_abs)+1] * stheta;
00615         }
00616 
00617         <span class="comment">/* Compute final result by multiplying the fixed part</span>
00618 <span class="comment">         *   gamma_|n| (1-cos^2(theta))^{|n|/2}</span>
00619 <span class="comment">         * for order n and the exponential part</span>
00620 <span class="comment">         *   e^{i n phi}</span>
00621 <span class="comment">         * and add the result to f_m.</span>
00622 <span class="comment">         */</span>
00623         f_m += it2 * <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a>[ROW(n_abs)] *
00624           pow(1- stheta * stheta, 0.5*n_abs) * cexp(I*n*sphi);
00625       }
00626 
00627       <span class="comment">/* Write result f_m for current node to array f. */</span>
00628       plan-&gt;f[m] = f_m;
00629     }
00630   }
00631 }
00632 
<a name="l00633"></a><a class="code" href="group__nfsft.html#ga7">00633</a> <span class="keywordtype">void</span> <a class="code" href="group__nfsft.html#ga7">ndsft_adjoint</a>(<a class="code" href="structnfsft__plan.html">nfsft_plan</a> *plan)
00634 {
00635   <span class="keywordtype">int</span> m;               <span class="comment">/*&lt; The node index                                    */</span>
00636   <span class="keywordtype">int</span> k;               <span class="comment">/*&lt; The degree k                                      */</span>
00637   <span class="keywordtype">int</span> n;               <span class="comment">/*&lt; The order n                                       */</span>
00638   <span class="keywordtype">int</span> n_abs;           <span class="comment">/*&lt; The absolute value of the order n, ie n_abs = |n| */</span>
00639   <span class="keywordtype">double</span> *alpha;       <span class="comment">/*&lt; Pointer to current three-term recurrence</span>
00640 <span class="comment">         coefficient alpha_k^n for associated Legendre</span>
00641 <span class="comment">         functions P_k^n                                   */</span>
00642   <span class="keywordtype">double</span> *gamma;       <span class="comment">/*&lt; Pointer to current three-term recurrence</span>
00643 <span class="comment">         coefficient beta_k^n for associated Legendre</span>
00644 <span class="comment">         functions P_k^n                                   */</span>
00645   <span class="keywordtype">double</span> complex it1;  <span class="comment">/*&lt; Auxilliary variable for Clenshaw algorithm        */</span>
00646   <span class="keywordtype">double</span> complex it2;  <span class="comment">/*&lt; Auxilliary variable for Clenshaw algorithm        */</span>
00647   <span class="keywordtype">double</span> complex temp; <span class="comment">/*&lt; Auxilliary variable for Clenshaw algorithm        */</span>
00648   <span class="keywordtype">double</span> stheta;       <span class="comment">/*&lt; Current angle theta for Clenshaw algorithm        */</span>
00649   <span class="keywordtype">double</span> sphi;         <span class="comment">/*&lt; Current angle phi for Clenshaw algorithm          */</span>
00650 
00651   <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o1">flags</a> &amp; <a class="code" href="group__nfsft.html#ga37">NFSFT_NO_DIRECT_ALGORITHM</a>)
00652   {
00653     <span class="keywordflow">return</span>;
00654   }
00655 
00656   <span class="comment">/* Initialise spherical Fourier coefficients array with zeros. */</span>
00657   memset(plan-&gt;f_hat,0U,plan-&gt;N_total*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00658 
00659   <span class="comment">/* Distinguish by bandwidth N. */</span>
00660   <span class="keywordflow">if</span> (plan-&gt;N == 0)
00661   {
00662     <span class="comment">/* N == 0 */</span>
00663 
00664     <span class="comment">/* Constant function */</span>
00665     <span class="keywordflow">for</span> (m = 0; m &lt; plan-&gt;M_total; m++)
00666     {
00667       plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(0,0,plan)] += plan-&gt;f[m];
00668     }
00669   }
00670   <span class="keywordflow">else</span>
00671   {
00672     <span class="comment">/* N &gt; 0 */</span>
00673 
00674     <span class="comment">/* Traverse all nodes. */</span>
00675     <span class="keywordflow">for</span> (m = 0; m &lt; plan-&gt;M_total; m++)
00676     {
00677       <span class="comment">/* Scale angle theta from [0,1/2] to [0,pi] and apply cosine. */</span>
00678       stheta = cos(2.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>*plan-&gt;x[2*m+1]);
00679       <span class="comment">/* Scale angle phi from [-1/2,1/2] to [-pi,pi]. */</span>
00680       sphi = 2.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>*plan-&gt;x[2*m];
00681 
00682       <span class="comment">/* Traverse all orders n. */</span>
00683       <span class="keywordflow">for</span> (n = -plan-&gt;N; n &lt;= plan-&gt;N; n++)
00684       {
00685         <span class="comment">/* Take absolute value of n. */</span>
00686         n_abs = abs(n);
00687 
00688         <span class="comment">/* Get pointers to three-term recurrence coefficients arrays. */</span>
00689         alpha = &amp;(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a>[ROW(n_abs)]);
00690         gamma = &amp;(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a>[ROW(n_abs)]);
00691 
00692         <span class="comment">/* Transposed Clenshaw algorithm */</span>
00693 
00694         <span class="comment">/* Initial step */</span>
00695         it1 = plan-&gt;f[m] * <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o6">gamma</a>[ROW(n_abs)] *
00696           pow(1 - stheta * stheta, 0.5*n_abs) * cexp(-I*n*sphi);
00697         plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(n_abs,n,plan)] += it1;
00698 
00699         <span class="keywordflow">if</span> (n_abs &lt; plan-&gt;N)
00700         {
00701           it2 = it1 * <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o4">alpha</a>[ROWK(n_abs)+1] * stheta;
00702           plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(n_abs+1,n,plan)] += it2;
00703         }
00704 
00705         <span class="comment">/* Loop for transposed Clenshaw algorithm */</span>
00706         <span class="keywordflow">for</span> (k = n_abs+2; k &lt;= plan-&gt;N; k++)
00707         {
00708           temp = it2;
00709           it2 = alpha[k] * stheta * it2 + gamma[k] * it1;
00710           it1 = temp;
00711           plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(k,n,plan)] += it2;
00712         }
00713       }
00714     }
00715   }
00716 
00717   <span class="comment">/* Check, if we compute with L^2-normalized spherical harmonics. If so,</span>
00718 <span class="comment">   * multiply spherical Fourier coefficients with corresponding normalization</span>
00719 <span class="comment">   * weight. */</span>
00720   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga25">NFSFT_NORMALIZED</a>)
00721   {
00722     <span class="comment">/* Traverse Fourier coefficients array. */</span>
00723     <span class="keywordflow">for</span> (k = 0; k &lt;= plan-&gt;N; k++)
00724     {
00725       <span class="keywordflow">for</span> (n = -k; n &lt;= k; n++)
00726       {
00727         <span class="comment">/* Multiply with normalization weight. */</span>
00728         plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(k,n,plan)] *=
00729           sqrt((2*k+1)/(4.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>));
00730       }
00731     }
00732   }
00733 
00734   <span class="comment">/* Set unused coefficients to zero. */</span>
00735   <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga39">NFSFT_ZERO_F_HAT</a>)
00736   {
00737     <span class="keywordflow">for</span> (n = -plan-&gt;N; n &lt;= plan-&gt;N+1; n++)
00738     {
00739       memset(&amp;plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(-plan-&gt;N-1,n,plan)],0U,
00740         (plan-&gt;N+1+abs(n))*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00741     }
00742   }
00743 }
00744 
<a name="l00745"></a><a class="code" href="group__nfsft.html#ga8">00745</a> <span class="keywordtype">void</span> <a class="code" href="group__nfsft.html#ga8">nfsft_trafo</a>(<a class="code" href="structnfsft__plan.html">nfsft_plan</a> *plan)
00746 {
00747   <span class="keywordtype">int</span> k; <span class="comment">/*&lt; The degree k                                                    */</span>
00748   <span class="keywordtype">int</span> n; <span class="comment">/*&lt; The order n                                                     */</span>
00749 <span class="preprocessor">  #ifdef DEBUG</span>
00750 <span class="preprocessor"></span>    <span class="keywordtype">double</span> t, t_pre, t_nfft, t_fpt, t_c2e, t_norm;
00751     t_pre = 0.0;
00752     t_norm = 0.0;
00753     t_fpt = 0.0;
00754     t_c2e = 0.0;
00755     t_nfft = 0.0;
00756 <span class="preprocessor">  #endif</span>
00757 <span class="preprocessor"></span>
00758   <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o1">flags</a> &amp; <a class="code" href="group__nfsft.html#ga38">NFSFT_NO_FAST_ALGORITHM</a>)
00759   {
00760     <span class="keywordflow">return</span>;
00761   }
00762 
00763   <span class="comment">/* Check, if precomputation was done and that the bandwidth N is not too</span>
00764 <span class="comment">   * big.</span>
00765 <span class="comment">   */</span>
00766   <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o0">initialized</a> == 0 || plan-&gt;N &gt; <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>)
00767   {
00768     <span class="keywordflow">return</span>;
00769   }
00770 
00771   <span class="comment">/* Check, if slow transformation should be used due to small bandwidth. */</span>
00772   <span class="keywordflow">if</span> (plan-&gt;N &lt; <a class="code" href="group__nfsft.html#ga48">NFSFT_BREAK_EVEN</a>)
00773   {
00774     <span class="comment">/* Use NDSFT. */</span>
00775     <a class="code" href="group__nfsft.html#ga6">ndsft_trafo</a>(plan);
00776   }
00777 
00778   <span class="comment">/* Check for correct value of the bandwidth N. */</span>
00779   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (plan-&gt;N &lt;= <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>)
00780   {
00781     <span class="comment">/* Copy spherical Fourier coefficients, if necessary. */</span>
00782     <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga31">NFSFT_PRESERVE_F_HAT</a>)
00783     {
00784       memcpy(plan-&gt;f_hat_intern,plan-&gt;f_hat,plan-&gt;N_total*
00785        <span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00786     }
00787     <span class="keywordflow">else</span>
00788     {
00789       plan-&gt;f_hat_intern = plan-&gt;f_hat;
00790     }
00791 
00792     <span class="comment">/* Propagate pointer values to the internal NFFT plan to assure</span>
00793 <span class="comment">     * consistency. Pointers may have been modified externally.</span>
00794 <span class="comment">     */</span>
00795     plan-&gt;plan_nfft.x = plan-&gt;x;
00796     plan-&gt;plan_nfft.f = plan-&gt;f;
00797     plan-&gt;plan_nfft.f_hat = plan-&gt;f_hat_intern;
00798 
00799     <span class="comment">/* Check, if we compute with L^2-normalized spherical harmonics. If so,</span>
00800 <span class="comment">     * multiply spherical Fourier coefficients with corresponding normalization</span>
00801 <span class="comment">     * weight. */</span>
00802     <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga25">NFSFT_NORMALIZED</a>)
00803     {
00804       <span class="comment">/* Traverse Fourier coefficients array. */</span>
00805       <span class="keywordflow">for</span> (k = 0; k &lt;= plan-&gt;N; k++)
00806       {
00807         <span class="keywordflow">for</span> (n = -k; n &lt;= k; n++)
00808         {
00809           <span class="comment">/* Multiply with normalization weight. */</span>
00810           plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(k,n,plan)] *=
00811             sqrt((2*k+1)/(4.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>));
00812         }
00813       }
00814     }
00815 
00816     <span class="comment">/* Check, which polynomial transform algorithm should be used. */</span>
00817     <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga27">NFSFT_USE_DPT</a>)
00818     {
00819       <span class="comment">/* Use direct discrete polynomial transform DPT. */</span>
00820       <span class="keywordflow">for</span> (n = -plan-&gt;N; n &lt;= plan-&gt;N; n++)
00821       {
00822         <span class="comment">//fprintf(stderr,"nfsft_trafo: n = %d\n",n);</span>
00823         fflush(stderr);
00824         <a class="code" href="group__fpt.html#ga3">dpt_trafo</a>(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o8">set</a>,abs(n),
00825           &amp;plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(abs(n),n,plan)],
00826           &amp;plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(0,n,plan)],
00827           plan-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>,0U);
00828       }
00829     }
00830     <span class="keywordflow">else</span>
00831     {
00832       <span class="comment">/* Use fast polynomial transform FPT. */</span>
00833       <span class="keywordflow">for</span> (n = -plan-&gt;N; n &lt;= plan-&gt;N; n++)
00834       {
00835         <span class="comment">//fprintf(stderr,"nfsft_trafo: n = %d\n",n);</span>
00836         fflush(stderr);
00837         <a class="code" href="group__fpt.html#ga4">fpt_trafo</a>(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o8">set</a>,abs(n),
00838           &amp;plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(abs(n),n,plan)],
00839           &amp;plan-&gt;f_hat_intern[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(0,n,plan)],
00840           plan-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>,0U);
00841       }
00842     }
00843 
00844     <span class="comment">/* Convert Chebyshev coefficients to Fourier coefficients. */</span>
00845     <a class="code" href="group__nfsft.html#ga23">c2e</a>(plan);
00846 
00847     <span class="comment">/* Check, which nonequispaced discrete Fourier transform algorithm should</span>
00848 <span class="comment">     * be used.</span>
00849 <span class="comment">     */</span>
00850     <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga26">NFSFT_USE_NDFT</a>)
00851     {
00852       <span class="comment">/* Use NDFT. */</span>
00853       <a class="code" href="group__nfft.html#ga0">ndft_trafo</a>(&amp;plan-&gt;plan_nfft);
00854     }
00855     <span class="keywordflow">else</span>
00856     {
00857       <span class="comment">/* Use NFFT. */</span>
00858       <span class="comment">//fprintf(stderr,"nfsft_adjoint: nfft_trafo\n");</span>
00859       <a class="code" href="group__nfft.html#ga2">nfft_trafo</a>(&amp;plan-&gt;plan_nfft);
00860     }
00861   }
00862 }
00863 
<a name="l00864"></a><a class="code" href="group__nfsft.html#ga9">00864</a> <span class="keywordtype">void</span> <a class="code" href="group__nfsft.html#ga9">nfsft_adjoint</a>(<a class="code" href="structnfsft__plan.html">nfsft_plan</a> *plan)
00865 {
00866   <span class="keywordtype">int</span> k; <span class="comment">/*&lt; The degree k                                                    */</span>
00867   <span class="keywordtype">int</span> n; <span class="comment">/*&lt; The order n                                                     */</span>
00868 
00869   <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o1">flags</a> &amp; <a class="code" href="group__nfsft.html#ga38">NFSFT_NO_FAST_ALGORITHM</a>)
00870   {
00871     <span class="keywordflow">return</span>;
00872   }
00873 
00874   <span class="comment">/* Check, if precomputation was done and that the bandwidth N is not too</span>
00875 <span class="comment">   * big.</span>
00876 <span class="comment">   */</span>
00877   <span class="keywordflow">if</span> (<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o0">initialized</a> == 0 || plan-&gt;N &gt; <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>)
00878   {
00879     <span class="keywordflow">return</span>;
00880   }
00881 
00882   <span class="comment">/* Check, if slow transformation should be used due to small bandwidth. */</span>
00883   <span class="keywordflow">if</span> (plan-&gt;N &lt; <a class="code" href="group__nfsft.html#ga48">NFSFT_BREAK_EVEN</a>)
00884   {
00885     <span class="comment">/* Use adjoint NDSFT. */</span>
00886     <a class="code" href="group__nfsft.html#ga7">ndsft_adjoint</a>(plan);
00887   }
00888   <span class="comment">/* Check for correct value of the bandwidth N. */</span>
00889   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (plan-&gt;N &lt;= <a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o2">N_MAX</a>)
00890   {
00891     <span class="comment">//fprintf(stderr,"nfsft_adjoint: Starting\n");</span>
00892     <span class="comment">//fflush(stderr);</span>
00893     <span class="comment">/* Propagate pointer values to the internal NFFT plan to assure</span>
00894 <span class="comment">     * consistency. Pointers may have been modified externally.</span>
00895 <span class="comment">     */</span>
00896     plan-&gt;plan_nfft.x = plan-&gt;x;
00897     plan-&gt;plan_nfft.f = plan-&gt;f;
00898     plan-&gt;plan_nfft.f_hat = plan-&gt;f_hat;
00899 
00900     <span class="comment">/* Check, which adjoint nonequispaced discrete Fourier transform algorithm</span>
00901 <span class="comment">     * should be used.</span>
00902 <span class="comment">     */</span>
00903     <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga26">NFSFT_USE_NDFT</a>)
00904     {
00905       <span class="comment">//fprintf(stderr,"nfsft_adjoint: Executing ndft_adjoint\n");</span>
00906       <span class="comment">//fflush(stderr);</span>
00907       <span class="comment">/* Use adjoint NDFT. */</span>
00908       <a class="code" href="group__nfft.html#ga1">ndft_adjoint</a>(&amp;plan-&gt;plan_nfft);
00909     }
00910     <span class="keywordflow">else</span>
00911     {
00912       <span class="comment">//fprintf(stderr,"nfsft_adjoint: Executing nfft_adjoint\n");</span>
00913       <span class="comment">//fflush(stderr);</span>
00914       <span class="comment">//fprintf(stderr,"nfsft_adjoint: nfft_adjoint\n");</span>
00915       <span class="comment">/* Use adjoint NFFT. */</span>
00916       <a class="code" href="group__nfft.html#ga3">nfft_adjoint</a>(&amp;plan-&gt;plan_nfft);
00917     }
00918 
00919     <span class="comment">//fprintf(stderr,"nfsft_adjoint: Executing c2e_transposed\n");</span>
00920     <span class="comment">//fflush(stderr);</span>
00921     <span class="comment">/* Convert Fourier coefficients to Chebyshev coefficients. */</span>
00922     <a class="code" href="group__nfsft.html#ga24">c2e_transposed</a>(plan);
00923 
00924     <span class="comment">/* Check, which transposed polynomial transform algorithm should be used */</span>
00925     <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga27">NFSFT_USE_DPT</a>)
00926     {
00927       <span class="comment">/* Use transposed DPT. */</span>
00928       <span class="keywordflow">for</span> (n = -plan-&gt;N; n &lt;= plan-&gt;N; n++)
00929       {
00930         <span class="comment">//fprintf(stderr,"nfsft_adjoint: Executing dpt_transposed\n");</span>
00931         <span class="comment">//fflush(stderr);</span>
00932         <a class="code" href="group__fpt.html#ga5">dpt_transposed</a>(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o8">set</a>,abs(n),
00933           &amp;plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(abs(n),n,plan)],
00934           &amp;plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(0,n,plan)],
00935           plan-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>,0U);
00936       }
00937     }
00938     <span class="keywordflow">else</span>
00939     {
00940       <span class="comment">//fprintf(stderr,"nfsft_adjoint: fpt_transposed\n");</span>
00941       <span class="comment">/* Use transposed FPT. */</span>
00942       <span class="keywordflow">for</span> (n = -plan-&gt;N; n &lt;= plan-&gt;N; n++)
00943       {
00944         <span class="comment">//fprintf(stderr,"nfsft_adjoint: Executing fpt_transposed\n");</span>
00945         <span class="comment">//fflush(stderr);</span>
00946         <a class="code" href="group__fpt.html#ga6">fpt_transposed</a>(<a class="code" href="group__nfsft.html#ga0">wisdom</a>.<a class="code" href="structnfsft__wisdom.html#o8">set</a>,abs(n),
00947           &amp;plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(abs(n),n,plan)],
00948           &amp;plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(0,n,plan)],
00949           plan-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>,0U);
00950       }
00951     }
00952 
00953     <span class="comment">/* Check, if we compute with L^2-normalized spherical harmonics. If so,</span>
00954 <span class="comment">     * multiply spherical Fourier coefficients with corresponding normalization</span>
00955 <span class="comment">     * weight. */</span>
00956     <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga25">NFSFT_NORMALIZED</a>)
00957     {
00958       <span class="comment">//fprintf(stderr,"nfsft_adjoint: Normalizing\n");</span>
00959       <span class="comment">//fflush(stderr);</span>
00960       <span class="comment">/* Traverse Fourier coefficients array. */</span>
00961       <span class="keywordflow">for</span> (k = 0; k &lt;= plan-&gt;N; k++)
00962       {
00963         <span class="keywordflow">for</span> (n = -k; n &lt;= k; n++)
00964         {
00965           <span class="comment">/* Multiply with normalization weight. */</span>
00966           plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(k,n,plan)] *=
00967             sqrt((2*k+1)/(4.0*<a class="code" href="group__nfftutil.html#ga57">PI</a>));
00968         }
00969       }
00970     }
00971 
00972     <span class="comment">/* Set unused coefficients to zero. */</span>
00973     <span class="keywordflow">if</span> (plan-&gt;flags &amp; <a class="code" href="group__nfsft.html#ga39">NFSFT_ZERO_F_HAT</a>)
00974     {
00975       <span class="comment">//fprintf(stderr,"nfsft_adjoint: Setting to zero\n");</span>
00976       <span class="comment">//fflush(stderr);</span>
00977       <span class="keywordflow">for</span> (n = -plan-&gt;N; n &lt;= plan-&gt;N+1; n++)
00978       {
00979         memset(&amp;plan-&gt;f_hat[<a class="code" href="group__nfsft.html#ga40">NFSFT_INDEX</a>(-plan-&gt;N-1,n,plan)],0U,
00980           (plan-&gt;N+1+abs(n))*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00981       }
00982     }
00983     <span class="comment">//fprintf(stderr,"nfsft_adjoint: Finished\n");</span>
00984     <span class="comment">//fflush(stderr);</span>
00985   }
00986 }
00987 
00988 <span class="keywordtype">void</span> nfsft_precompute_x(<a class="code" href="structnfsft__plan.html">nfsft_plan</a> *plan)
00989 {
00990   <span class="comment">/* Pass angle array to NFFT plan. */</span>
00991   plan-&gt;plan_nfft.x = plan-&gt;x;
00992 
00993   <span class="comment">/* Precompute. */</span>
00994   <span class="keywordflow">if</span> (plan-&gt;plan_nfft.nfft_flags &amp; PRE_ONE_PSI)
00995     nfft_precompute_one_psi(&amp;plan-&gt;plan_nfft);
00996 }
00997 <span class="comment">/* \} */</span>
</pre></div>    <hr size="1"/>
    Generated on 22 Jan 2007 by Doxygen 1.4.1
  </body>
</html>
