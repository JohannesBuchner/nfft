<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
    <title>
      NFFT 3.0.2 API Reference - NFFT: fpt.c Source File
    </title>
    <link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <table>
      <tr>
        <td valign="top">
          <img src="images/logo.png" alt="NFFT Logo">
        </td>
        <td align="left" valign="bottom" width="100%">
          <H1nc>3.0.2 API Reference</H1nc>
        </td>
      </tr>
    </table>  
<!-- Generated by Doxygen 1.4.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a> | <a class="qindex" href="globals.html">Globals</a></div>
<div class="nav">
<a class="el" href="dir_000003.html">kernel</a>&nbsp;/&nbsp;<a class="el" href="dir_000019.html">fpt</a></div>
<h1>fpt.c</h1><a href="fpt_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00007 <span class="comment">/* Include standard C headers. */</span>
00008 <span class="preprocessor">#include &lt;math.h&gt;</span>
00009 <span class="preprocessor">#include &lt;string.h&gt;</span>
00010 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00011 <span class="preprocessor">#include &lt;stdbool.h&gt;</span>
00012 
00013 <span class="comment">/* Include FPT module header. */</span>
00014 <span class="preprocessor">#include "<a class="code" href="nfft3_8h.html">nfft3.h</a>"</span>
00015 
00016 <span class="comment">/* Include NFFT3 utilities header. */</span>
00017 <span class="preprocessor">#include "<a class="code" href="util_8h.html">util.h</a>"</span>
00018 
00019 <span class="comment">/* Some macros for index calculation. */</span>
00020 
<a name="l00022"></a><a class="code" href="fpt_8c.html#a0">00022</a> <span class="preprocessor">#define K_START_TILDE(x,y) (NFFT_MAX(NFFT_MIN(x,y-2),0))</span>
00023 <span class="preprocessor"></span>
<a name="l00024"></a><a class="code" href="fpt_8c.html#a1">00024</a> <span class="preprocessor">#define K_END_TILDE(x,y) NFFT_MIN(x,y-1)</span>
00025 <span class="preprocessor"></span>
<a name="l00029"></a><a class="code" href="fpt_8c.html#a2">00029</a> <span class="preprocessor">#define FIRST_L(x,y) ((int)floor((x)/(double)y))</span>
00030 <span class="preprocessor"></span>
<a name="l00034"></a><a class="code" href="fpt_8c.html#a3">00034</a> <span class="preprocessor">#define LAST_L(x,y) ((int)ceil(((x)+1)/(double)y)-1)</span>
00035 <span class="preprocessor"></span>
00036 <span class="preprocessor">#define N_TILDE(y) (y-1)</span>
00037 <span class="preprocessor"></span>
00038 <span class="preprocessor">#define IS_SYMMETRIC(x,y,z) (x &gt;= ((y-1.0)/z))</span>
00039 <span class="preprocessor"></span><span class="comment">//#define IS_SYMMETRIC(x,y,z) (x &gt;= ((y-1.0)/z))</span>
00040 
00041 <span class="preprocessor">#ifdef TEST_STAB</span>
00042 <span class="preprocessor"></span><span class="preprocessor">  #define NFFT_MAX(a,b) ((a&gt;b)?(a):(b))</span>
00043 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00044 <span class="preprocessor"></span>
00045 <span class="preprocessor">#define FPT_BREAK_EVEN 4</span>
00046 <span class="preprocessor"></span>
<a name="l00050"></a><a class="code" href="structfpt__step__.html">00050</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structfpt__step__.html">fpt_step_</a>
00051 {
<a name="l00052"></a><a class="code" href="structfpt__step__.html#o0">00052</a>   <span class="keywordtype">bool</span> <a class="code" href="structfpt__step__.html#o0">stable</a>;                            
<a name="l00055"></a><a class="code" href="structfpt__step__.html#o1">00055</a>   <span class="keywordtype">int</span> <a class="code" href="structfpt__step__.html#o1">N_stab</a>;                             
<a name="l00056"></a><a class="code" href="structfpt__step__.html#o2">00056</a>   <span class="keywordtype">int</span> <a class="code" href="structfpt__step__.html#o2">t_stab</a>;                             
<a name="l00057"></a><a class="code" href="structfpt__step__.html#o6">00057</a>   <span class="keywordtype">double</span> **a11,**a12,**a21,**<a class="code" href="structfpt__step__.html#o6">a22</a>;         
00058   <span class="keywordtype">double</span> *gamma;                          
00059 } <a class="code" href="structfpt__step__.html">fpt_step</a>;
00060 
<a name="l00064"></a><a class="code" href="structfpt__data__.html">00064</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structfpt__data__.html">fpt_data_</a>
00065 {
<a name="l00066"></a><a class="code" href="structfpt__data__.html#o0">00066</a>   <a class="code" href="structfpt__step__.html">fpt_step</a> **<a class="code" href="structfpt__data__.html#o0">steps</a>;                       
00067   <span class="keywordtype">int</span> k_start;
00068   <span class="keywordtype">double</span> *alphaN;
00069   <span class="keywordtype">double</span> *betaN;
00070   <span class="keywordtype">double</span> *gammaN;
00071   <span class="keywordtype">double</span> alpha_0;
00072   <span class="keywordtype">double</span> beta_0;
00073   <span class="keywordtype">double</span> gamma_m1;
00074   <span class="comment">/* Data for direct transform. */</span>
00075   <span class="keywordtype">double</span> *alpha;
00076   <span class="keywordtype">double</span> *beta;
00077   <span class="keywordtype">double</span> *gamma;
00078 } <a class="code" href="structfpt__data__.html">fpt_data</a>;
00079 
<a name="l00083"></a><a class="code" href="structfpt__set__s__.html">00083</a> <span class="keyword">typedef</span> <span class="keyword">struct </span><a class="code" href="structfpt__set__s__.html">fpt_set_s_</a>
00084 {
<a name="l00085"></a><a class="code" href="structfpt__set__s__.html#o0">00085</a>   <span class="keywordtype">int</span> <a class="code" href="structfpt__set__s__.html#o0">flags</a>;                              
<a name="l00086"></a><a class="code" href="structfpt__set__s__.html#o1">00086</a>   <span class="keywordtype">int</span> <a class="code" href="structfpt__set__s__.html#o1">M</a>;                                  
<a name="l00087"></a><a class="code" href="structfpt__set__s__.html#o2">00087</a>   <span class="keywordtype">int</span> <a class="code" href="structfpt__set__s__.html#o2">N</a>;                                  
<a name="l00089"></a><a class="code" href="structfpt__set__s__.html#o3">00089</a>   <span class="keywordtype">int</span> <a class="code" href="structfpt__set__s__.html#o3">t</a>;                                  
<a name="l00090"></a><a class="code" href="structfpt__set__s__.html#o4">00090</a>   <a class="code" href="structfpt__data__.html">fpt_data</a> *<a class="code" href="structfpt__set__s__.html#o4">dpt</a>;                          
<a name="l00091"></a><a class="code" href="structfpt__set__s__.html#o5">00091</a>   <span class="keywordtype">double</span> **<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>;                        
<a name="l00094"></a><a class="code" href="structfpt__set__s__.html#o6">00094</a>   <span class="keywordtype">double</span> *<a class="code" href="structfpt__set__s__.html#o6">xc</a>;                             
00095   <span class="keywordtype">double</span> complex *temp;                          
00096   <span class="keywordtype">double</span> complex *work;                          
00097   <span class="keywordtype">double</span> complex *result;                        
00098   <span class="keywordtype">double</span> complex *vec3;
00099   <span class="keywordtype">double</span> complex *vec4;
00100   <span class="keywordtype">double</span> complex *z;
<a name="l00101"></a><a class="code" href="structfpt__set__s__.html#o13">00101</a>   fftw_plan *<a class="code" href="structfpt__set__s__.html#o13">plans_dct3</a>;                  
<a name="l00103"></a><a class="code" href="structfpt__set__s__.html#o14">00103</a>   fftw_plan *<a class="code" href="structfpt__set__s__.html#o14">plans_dct2</a>;                  
<a name="l00105"></a><a class="code" href="structfpt__set__s__.html#o15">00105</a>   fftw_r2r_kind *<a class="code" href="structfpt__set__s__.html#o15">kinds</a>;                   
<a name="l00107"></a><a class="code" href="structfpt__set__s__.html#o16">00107</a>   fftw_r2r_kind *<a class="code" href="structfpt__set__s__.html#o16">kindsr</a>;                  
<a name="l00110"></a><a class="code" href="structfpt__set__s__.html#o17">00110</a>   <span class="keywordtype">int</span> *<a class="code" href="structfpt__set__s__.html#o17">lengths</a>; 
00112   <span class="comment">/* Data for slow transforms. */</span>
00113   <span class="keywordtype">double</span> *xc_slow;
00114 } <a class="code" href="structfpt__set__s__.html">fpt_set_s</a>;
00115 
00116 <span class="keyword">inline</span> <span class="keywordtype">void</span> abuvxpwy(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> complex* u, <span class="keywordtype">double</span> complex* x, <span class="keywordtype">double</span>* v,
00117   <span class="keywordtype">double</span> complex* y, <span class="keywordtype">double</span>* w, <span class="keywordtype">int</span> n)
00118 {
00119   <span class="keywordtype">int</span> l;
00120   <span class="keywordtype">double</span> complex *u_ptr, *x_ptr, *y_ptr;
00121   <span class="keywordtype">double</span> *v_ptr, *w_ptr;
00122 
00123   u_ptr = u;
00124   x_ptr = x;
00125   v_ptr = v;
00126   y_ptr = y;
00127   w_ptr = w;
00128 
00129   <span class="keywordflow">for</span> (l = 0; l &lt; n; l++)
00130   {
00131     *u++ = a * (b * (*v++) * (*x++) + (*w++) * (*y++));
00132   }
00133 }
00134 
00135 <span class="preprocessor">#define ABUVXPWY_SYMMETRIC(NAME,S1,S2) \</span>
00136 <span class="preprocessor">inline void NAME(double a, double b, double complex* u, double complex* x, double* v, \</span>
00137 <span class="preprocessor">  double complex* y, double* w, int n) \</span>
00138 <span class="preprocessor">{ \</span>
00139 <span class="preprocessor">  int l; \</span>
00140 <span class="preprocessor">  double complex *u_ptr, *x_ptr, *y_ptr; \</span>
00141 <span class="preprocessor">  double *v_ptr, *w_ptr; \</span>
00142 <span class="preprocessor">  \</span>
00143 <span class="preprocessor">  u_ptr = u; \</span>
00144 <span class="preprocessor">  x_ptr = x; \</span>
00145 <span class="preprocessor">  v_ptr = v; \</span>
00146 <span class="preprocessor">  y_ptr = y; \</span>
00147 <span class="preprocessor">  w_ptr = w; \</span>
00148 <span class="preprocessor">  \</span>
00149 <span class="preprocessor">  for (l = 0; l &lt; n/2; l++) \</span>
00150 <span class="preprocessor">  { \</span>
00151 <span class="preprocessor">    *u_ptr++ = a * (b * (*v_ptr++) * (*x_ptr++) + (*w_ptr++) * (*y_ptr++)); \</span>
00152 <span class="preprocessor">  } \</span>
00153 <span class="preprocessor">  v_ptr--; \</span>
00154 <span class="preprocessor">  w_ptr--; \</span>
00155 <span class="preprocessor">  for (l = 0; l &lt; n/2; l++) \</span>
00156 <span class="preprocessor">  { \</span>
00157 <span class="preprocessor">    *u_ptr++ = a * (b * S1 * (*v_ptr--) * (*x_ptr++) + S2 * (*w_ptr--) * (*y_ptr++)); \</span>
00158 <span class="preprocessor">  } \</span>
00159 <span class="preprocessor">}</span>
00160 <span class="preprocessor"></span>
00161 ABUVXPWY_SYMMETRIC(abuvxpwy_symmetric1,1.0,-1.0)
00162 ABUVXPWY_SYMMETRIC(abuvxpwy_symmetric2,-1.0,1.0)
00163 
00164 #define ABUVXPWY_SYMMETRIC_1(NAME,S1) \
00165 inline <span class="keywordtype">void</span> NAME(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> complex* u, <span class="keywordtype">double</span> complex* x, <span class="keywordtype">double</span>* v, \
00166   <span class="keywordtype">double</span> complex* y, <span class="keywordtype">double</span>* w, <span class="keywordtype">int</span> n) \
00167 { \
00168   <span class="keywordtype">int</span> l; \
00169   <span class="keywordtype">double</span> complex *u_ptr, *x_ptr, *y_ptr; \
00170   <span class="keywordtype">double</span> *v_ptr, *w_ptr; \
00171   \
00172   u_ptr = u; \
00173   x_ptr = x; \
00174   v_ptr = v; \
00175   y_ptr = y; \
00176   w_ptr = w; \
00177   \
00178   <span class="keywordflow">for</span> (l = 0; l &lt; n/2; l++) \
00179   { \
00180     *u_ptr++ = a * (b * (*v_ptr++) * (*x_ptr++) + (*w_ptr++) * (*y_ptr++)); \
00181   } \
00182   v_ptr--; \
00183   <span class="comment">/*w_ptr--;*/</span> \
00184   <span class="keywordflow">for</span> (l = 0; l &lt; n/2; l++) \
00185   { \
00186     *u_ptr++ = a * (b * S1 * (*v_ptr--) * (*x_ptr++) + (*w_ptr++) * (*y_ptr++)); \
00187   } \
00188 }
00189 
00190 ABUVXPWY_SYMMETRIC_1(abuvxpwy_symmetric1_1,1.0)
00191 ABUVXPWY_SYMMETRIC_1(abuvxpwy_symmetric1_2,-1.0)
00192 
00193 #define ABUVXPWY_SYMMETRIC_2(NAME,S1) \
00194 inline <span class="keywordtype">void</span> NAME(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> b, <span class="keywordtype">double</span> complex* u, <span class="keywordtype">double</span> complex* x, <span class="keywordtype">double</span>* v, \
00195   <span class="keywordtype">double</span> complex* y, <span class="keywordtype">double</span>* w, <span class="keywordtype">int</span> n) \
00196 { \
00197   <span class="keywordtype">int</span> l; \
00198   <span class="keywordtype">double</span> complex *u_ptr, *x_ptr, *y_ptr; \
00199   <span class="keywordtype">double</span> *v_ptr, *w_ptr; \
00200   \
00201   u_ptr = u; \
00202   x_ptr = x; \
00203   v_ptr = v; \
00204   y_ptr = y; \
00205   w_ptr = w; \
00206   \
00207   <span class="keywordflow">for</span> (l = 0; l &lt; n/2; l++) \
00208   { \
00209     *u_ptr++ = a * (b * (*v_ptr++) * (*x_ptr++) + (*w_ptr++) * (*y_ptr++)); \
00210   } \
00211   <span class="comment">/*v_ptr--;*/</span> \
00212   w_ptr--; \
00213   <span class="keywordflow">for</span> (l = 0; l &lt; n/2; l++) \
00214   { \
00215     *u_ptr++ = a * (b * (*v_ptr++) * (*x_ptr++) + S1 * (*w_ptr--) * (*y_ptr++)); \
00216   } \
00217 }
00218 
00219 ABUVXPWY_SYMMETRIC_2(abuvxpwy_symmetric2_1,1.0)
00220 ABUVXPWY_SYMMETRIC_2(abuvxpwy_symmetric2_2,-1.0)
00221 
00222 inline <span class="keywordtype">void</span> auvxpwy(<span class="keywordtype">double</span> a, <span class="keywordtype">double</span> complex* u, <span class="keywordtype">double</span> complex* x, <span class="keywordtype">double</span>* v, <span class="keywordtype">double</span> complex* y,
00223   <span class="keywordtype">double</span>* w, <span class="keywordtype">int</span> n)
00224 {
00225   <span class="keywordtype">int</span> l;
00226   <span class="keywordtype">double</span> complex *u_ptr, *x_ptr, *y_ptr;
00227   <span class="keywordtype">double</span> *v_ptr, *w_ptr;
00228 
00229   u_ptr = u;
00230   x_ptr = x;
00231   v_ptr = v;
00232   y_ptr = y;
00233   w_ptr = w;
00234 
00235   <span class="keywordflow">for</span> (l = 0; l &lt; n; l++)
00236   {
00237     <span class="comment">/*fprintf(stderr,"u = %le, v = %le, x = %le, w = %le, y = %le\n",*u_ptr,*v_ptr,*x_ptr,*w_ptr,*y_ptr);*/</span>
00238     *u_ptr++ = a * ((*v_ptr++) * (*x_ptr++) + (*w_ptr++) * (*y_ptr++));
00239   }
00240   <span class="comment">/*fprintf(stderr,"\n");*/</span>
00241 }
00242 
00243 <span class="preprocessor">#define AUVXPWY_SYMMETRIC(NAME,S1,S2) \</span>
00244 <span class="preprocessor">inline void NAME(double a, double complex* u, double complex* x, double* v, double complex* y, \</span>
00245 <span class="preprocessor">  double* w, int n) \</span>
00246 <span class="preprocessor">{ \</span>
00247 <span class="preprocessor">  int l; \</span>
00248 <span class="preprocessor">  double complex *u_ptr, *x_ptr, *y_ptr; \</span>
00249 <span class="preprocessor">  double *v_ptr, *w_ptr; \</span>
00250 <span class="preprocessor">\</span>
00251 <span class="preprocessor">  u_ptr = u; \</span>
00252 <span class="preprocessor">  x_ptr = x; \</span>
00253 <span class="preprocessor">  v_ptr = v; \</span>
00254 <span class="preprocessor">  y_ptr = y; \</span>
00255 <span class="preprocessor">  w_ptr = w; \</span>
00256 <span class="preprocessor">\</span>
00257 <span class="preprocessor">  </span><span class="comment">/*for (l = 0; l &lt; n; l++)*/</span> \
00258   <span class="comment">/*{*/</span> \
00259     <span class="comment">/*fprintf(stderr,"u = %le, v = %le, x = %le, w = %le, y = %le\n",*/</span> \
00260     <span class="comment">/*  u_ptr[l],v_ptr[l],x_ptr[l],w_ptr[l],y_ptr[l]);*/</span> \
00261   <span class="comment">/*}*/</span> \
00262   \
00263   \
00264   for (l = 0; l &lt; n/2; l++) \
00265   { \
00266     <span class="comment">/*fprintf(stderr,"u = %le, v = %le, x = %le, w = %le, y = %le\n",*u,*v,*x,*w,*y);*/</span> \
00267     *u_ptr++ = a * ((*v_ptr++) * (*x_ptr++) + (*w_ptr++) * (*y_ptr++)); \
00268   } \
00269   v_ptr--; \
00270   w_ptr--; \
00271   for (l = 0; l &lt; n/2; l++) \
00272   { \
00273     <span class="comment">/* fprintf(stderr,"u = %le, v = %le, x = %le, w = %le, y = %le\n",*u,*v,*x,*w,*y);*/</span> \
00274     *u_ptr++ = a * (S1 * (*v_ptr--) * (*x_ptr++) + S2 * (*w_ptr--) * (*y_ptr++)); \
00275   } \
00276   <span class="comment">/*fprintf(stderr,"\n");*/</span> \
00277 }
00278 
00279 AUVXPWY_SYMMETRIC(auvxpwy_symmetric,1.0,-1.0)
00280 
00281 #define FPT_DO_STEP(NAME,M1_FUNCTION,M2_FUNCTION) \
00282 <span class="keyword">inline</span> <span class="keywordtype">void</span> NAME(<span class="keywordtype">double</span> complex  *a, <span class="keywordtype">double</span> complex *b, <span class="keywordtype">double</span> *a11, <span class="keywordtype">double</span> *a12, \
00283   <span class="keywordtype">double</span> *a21, <span class="keywordtype">double</span> *a22, <span class="keywordtype">double</span> gamma, <span class="keywordtype">int</span> tau, <a class="code" href="structfpt__set__s__.html">fpt_set</a> set) \
00284 { \ \
00286   <span class="keywordtype">int</span> length = 1&lt;&lt;(tau+1); \ \
00288   <span class="keywordtype">double</span> norm = 1.0/(length&lt;&lt;1); \
00289   \
00290   <span class="comment">/* Compensate for factors introduced by a raw DCT-III. */</span> \
00291   a[0] *= 2.0; \
00292   b[0] *= 2.0; \
00293   \
00294   <span class="comment">/* Compute function values from Chebyshev-coefficients using a DCT-III. */</span> \
00295   fftw_execute_r2r(set-&gt;plans_dct3[tau-1],(<span class="keywordtype">double</span>*)a,(<span class="keywordtype">double</span>*)a); \
00296   fftw_execute_r2r(set-&gt;plans_dct3[tau-1],(<span class="keywordtype">double</span>*)b,(<span class="keywordtype">double</span>*)b); \
00297   \
00298   <span class="comment">/*for (k = 0; k &lt; length; k++)*/</span> \
00299   <span class="comment">/*{*/</span> \
00300     <span class="comment">/*fprintf(stderr,"fpt_do_step: a11 = %le, a12 = %le, a21 = %le, a22 = %le\n",*/</span> \
00301     <span class="comment">/*  a11[k],a12[k],a21[k],a22[k]);*/</span> \
00302   <span class="comment">/*}*/</span> \
00303   \
00304   <span class="comment">/* Check, if gamma is zero. */</span> \
00305   <span class="keywordflow">if</span> (gamma == 0.0) \
00306   { \
00307     <span class="comment">/*fprintf(stderr,"gamma == 0!\n");*/</span> \
00308     <span class="comment">/* Perform multiplication only for second row. */</span> \
00309     M2_FUNCTION(norm,b,b,a22,a,a21,length); \
00310   } \
00311   <span class="keywordflow">else</span> \
00312   { \
00313     <span class="comment">/*fprintf(stderr,"gamma != 0!\n");*/</span> \
00314     <span class="comment">/* Perform multiplication for both rows. */</span> \
00315     M2_FUNCTION(norm,set-&gt;z,b,a22,a,a21,length); \
00316     M1_FUNCTION(norm*gamma,a,a,a11,b,a12,length); \
00317     memcpy(b,set-&gt;z,length*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex)); \
00318     <span class="comment">/* Compute Chebyshev-coefficients using a DCT-II. */</span> \
00319     fftw_execute_r2r(set-&gt;plans_dct2[tau-1],(<span class="keywordtype">double</span>*)a,(<span class="keywordtype">double</span>*)a); \
00320     <span class="comment">/* Compensate for factors introduced by a raw DCT-II. */</span> \
00321     a[0] *= 0.5; \
00322   } \
00323   \
00324   <span class="comment">/* Compute Chebyshev-coefficients using a DCT-II. */</span> \
00325   fftw_execute_r2r(set-&gt;plans_dct2[tau-1],(<span class="keywordtype">double</span>*)b,(<span class="keywordtype">double</span>*)b); \
00326   <span class="comment">/* Compensate for factors introduced by a raw DCT-II. */</span> \
00327   b[0] *= 0.5; \
00328 }
00329 
00330 FPT_DO_STEP(fpt_do_step,auvxpwy,auvxpwy)
<a name="l00331"></a><a class="code" href="fpt_8c.html#a26">00331</a> FPT_DO_STEP(fpt_do_step_symmetric,auvxpwy_symmetric,auvxpwy_symmetric)
<a name="l00332"></a><a class="code" href="fpt_8c.html#a27">00332</a> FPT_DO_STEP(fpt_do_step_symmetric_u,auvxpwy_symmetric,auvxpwy)
<a name="l00333"></a><a class="code" href="fpt_8c.html#a28">00333</a> FPT_DO_STEP(fpt_do_step_symmetric_l,auvxpwy,auvxpwy_symmetric)
00334 
<a name="l00335"></a><a class="code" href="fpt_8c.html#a12">00335</a> #define FPT_DO_STEP_TRANSPOSED(NAME,M1_FUNCTION,M2_FUNCTION) \
00336 inline <span class="keywordtype">void</span> NAME(<span class="keywordtype">double</span> complex  *a, <span class="keywordtype">double</span> complex *b, <span class="keywordtype">double</span> *a11, \
00337   <span class="keywordtype">double</span> *a12, <span class="keywordtype">double</span> *a21, <span class="keywordtype">double</span> *a22, <span class="keywordtype">double</span> gamma, <span class="keywordtype">int</span> tau, <a class="code" href="structfpt__set__s__.html">fpt_set</a> set) \
00338 { \ \
00340   <span class="keywordtype">int</span> length = 1&lt;&lt;(tau+1); \ \
00342   <span class="keywordtype">double</span> norm = 1.0/(length&lt;&lt;1); \
00343   \
00344   <span class="comment">/* Compute function values from Chebyshev-coefficients using a DCT-III. */</span> \
00345   fftw_execute_r2r(set-&gt;plans_dct3[tau-1],(<span class="keywordtype">double</span>*)a,(<span class="keywordtype">double</span>*)a); \
00346   fftw_execute_r2r(set-&gt;plans_dct3[tau-1],(<span class="keywordtype">double</span>*)b,(<span class="keywordtype">double</span>*)b); \
00347   \
00348   <span class="comment">/* Perform matrix multiplication. */</span> \
00349   M1_FUNCTION(norm,gamma,set-&gt;z,a,a11,b,a21,length); \
00350   M2_FUNCTION(norm,gamma,b,a,a12,b,a22,length); \
00351   memcpy(a,set-&gt;z,length*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex)); \
00352   \
00353   <span class="comment">/* Compute Chebyshev-coefficients using a DCT-II. */</span> \
00354   fftw_execute_r2r(set-&gt;plans_dct2[tau-1],(<span class="keywordtype">double</span>*)a,(<span class="keywordtype">double</span>*)a); \
00355   fftw_execute_r2r(set-&gt;plans_dct2[tau-1],(<span class="keywordtype">double</span>*)b,(<span class="keywordtype">double</span>*)b); \
00356 }
00357 
00358 <a class="code" href="fpt_8c.html#a12">FPT_DO_STEP_TRANSPOSED</a>(fpt_do_step_transposed,abuvxpwy,abuvxpwy)
<a name="l00359"></a><a class="code" href="fpt_8c.html#a30">00359</a> FPT_DO_STEP_TRANSPOSED(fpt_do_step_transposed_symmetric,abuvxpwy_symmetric1,abuvxpwy_symmetric2)
<a name="l00360"></a><a class="code" href="fpt_8c.html#a31">00360</a> FPT_DO_STEP_TRANSPOSED(fpt_do_step_transposed_symmetric_u,abuvxpwy_symmetric1_1,abuvxpwy_symmetric1_2)
<a name="l00361"></a><a class="code" href="fpt_8c.html#a32">00361</a> FPT_DO_STEP_TRANSPOSED(fpt_do_step_transposed_symmetric_l,abuvxpwy_symmetric2_2,abuvxpwy_symmetric2_1)
00362 
<a name="l00363"></a><a class="code" href="fpt_8c.html#a33">00363</a> <span class="keywordtype">void</span> eval_clenshaw(const <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> k, const <span class="keywordtype">double</span> *alpha,
00364   const <span class="keywordtype">double</span> *beta, const <span class="keywordtype">double</span> *gamma)
00365 {
00366   <span class="comment">/* Evaluate the associated Legendre polynomial P_{k,nleg} (l,x) for the vector</span>
00367 <span class="comment">   * of knots  x[0], ..., x[size-1] by the Clenshaw algorithm</span>
00368 <span class="comment">   */</span>
00369   <span class="keywordtype">int</span> i,j;
00370   <span class="keywordtype">double</span> a,b,x_val_act,a_old;
00371   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_act;
00372   <span class="keywordtype">double</span> *y_act;
00373   <span class="keyword">const</span> <span class="keywordtype">double</span> *alpha_act, *beta_act, *gamma_act;
00374 
00375   <span class="comment">/* Traverse all nodes. */</span>
00376   x_act = x;
00377   y_act = y;
00378   <span class="keywordflow">for</span> (i = 0; i &lt; size; i++)
00379   {
00380     a = 1.0;
00381     b = 0.0;
00382     x_val_act = *x_act;
00383 
00384     <span class="keywordflow">if</span> (k == 0)
00385     {
00386       *y_act = 1.0;
00387     }
00388     <span class="keywordflow">else</span>
00389     {
00390       alpha_act = &amp;(alpha[k]);
00391       beta_act = &amp;(beta[k]);
00392       gamma_act = &amp;(gamma[k]);
00393       <span class="keywordflow">for</span> (j = k; j &gt; 1; j--)
00394       {
00395         a_old = a;
00396         a = b + a_old*((*alpha_act)*x_val_act+(*beta_act));
00397          b = a_old*(*gamma_act);
00398         alpha_act--;
00399         beta_act--;
00400         gamma_act--;
00401       }
00402       *y_act = (a*((*alpha_act)*x_val_act+(*beta_act))+b);
00403     }
00404     x_act++;
00405     y_act++;
00406   }
00407 }
00408 
00409 <span class="keywordtype">int</span> eval_clenshaw_thresh(<span class="keyword">const</span> <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> *y, <span class="keywordtype">int</span> size, <span class="keywordtype">int</span> k,
00410   <span class="keyword">const</span> <span class="keywordtype">double</span> *alpha, <span class="keyword">const</span> <span class="keywordtype">double</span> *beta, <span class="keyword">const</span> <span class="keywordtype">double</span> *gamma, <span class="keyword">const</span>
00411   <span class="keywordtype">double</span> threshold)
00412 {
00413   <span class="comment">/* Evaluate the associated Legendre polynomial P_{k,nleg} (l,x) for the vector</span>
00414 <span class="comment">   * of knots  x[0], ..., x[size-1] by the Clenshaw algorithm</span>
00415 <span class="comment">   */</span>
00416   <span class="keywordtype">int</span> i,j;
00417   <span class="keywordtype">double</span> a,b,x_val_act,a_old;
00418   <span class="keyword">const</span> <span class="keywordtype">double</span> *x_act;
00419   <span class="keywordtype">double</span> *y_act;
00420   <span class="keyword">const</span> <span class="keywordtype">double</span> *alpha_act, *beta_act, *gamma_act;
00421 
00422   <span class="comment">/* Traverse all nodes. */</span>
00423   x_act = x;
00424   y_act = y;
00425   <span class="keywordflow">for</span> (i = 0; i &lt; size; i++)
00426   {
00427     a = 1.0;
00428     b = 0.0;
00429     x_val_act = *x_act;
00430 
00431     <span class="keywordflow">if</span> (k == 0)
00432     {
00433      *y_act = 1.0;
00434     }
00435     <span class="keywordflow">else</span>
00436     {
00437       alpha_act = &amp;(alpha[k]);
00438       beta_act = &amp;(beta[k]);
00439       gamma_act = &amp;(gamma[k]);
00440       <span class="keywordflow">for</span> (j = k; j &gt; 1; j--)
00441       {
00442         a_old = a;
00443         a = b + a_old*((*alpha_act)*x_val_act+(*beta_act));
00444          b = a_old*(*gamma_act);
00445         alpha_act--;
00446         beta_act--;
00447         gamma_act--;
00448       }
00449       *y_act = (a*((*alpha_act)*x_val_act+(*beta_act))+b);
00450       <span class="keywordflow">if</span> (fabs(*y_act) &gt; threshold)
00451       {
00452         <span class="keywordflow">return</span> 1;
00453       }
00454     }
00455     x_act++;
00456     y_act++;
00457   }
00458   <span class="keywordflow">return</span> 0;
00459 }
00460 
<a name="l00479"></a><a class="code" href="fpt_8c.html#a35">00479</a> <span class="keywordtype">void</span> <a class="code" href="fpt_8c.html#a35">eval_sum_clenshaw</a>(<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> M, <span class="keywordtype">double</span> complex* a, <span class="keywordtype">double</span> *x, <span class="keywordtype">double</span> complex *y,
00480   <span class="keywordtype">double</span> complex *temp, <span class="keywordtype">double</span> *alpha, <span class="keywordtype">double</span> *beta, <span class="keywordtype">double</span> *gamma, <span class="keywordtype">double</span> lambda)
00481 {
00482   <span class="keywordtype">int</span> j,k;
00483   <span class="keywordtype">double</span> complex* it1 = temp;
00484   <span class="keywordtype">double</span> complex* it2 = y;
00485   <span class="keywordtype">double</span> complex aux;
00486 
00487   <span class="comment">/* Clenshaw's algorithm */</span>
00488   <span class="keywordflow">for</span> (j = 0; j &lt;= M; j++)
00489   {
00490     it2[j] = a[N];
00491   }
00492 
00493   <span class="keywordflow">if</span> (N &gt; 0)
00494   {
00495     <span class="keywordflow">for</span> (j = 0; j &lt;= M; j++)
00496     {
00497       it1[j] = a[N-1];
00498     }
00499 
00500     <span class="comment">//fprintf(stdout,"N = %d\n",N);</span>
00501     <span class="keywordflow">for</span> (k = N; k &gt; 1; k--)
00502     {
00503 
00504       <span class="keywordflow">for</span> (j = 0; j &lt;= M; j++)
00505       {
00506         aux = a[k-2] + it2[j] * gamma[k-1];
00507         it2[j] = it1[j] + it2[j] * (alpha[k-1] * x[j] + beta[k-1]);
00508         it1[j] = aux;
00509       }
00510     }
00511 
00512 
00513     <span class="comment">/* Compute final step. */</span>
00514     <span class="keywordflow">for</span> (j = 0; j &lt;= M; j++)
00515     {
00516       it2[j] = it1[j] + it2[j] * (alpha[0] * x[j] + beta[0]);
00517     }
00518   }
00519 
00520   <span class="comment">/* Compute final result by multiplying with the constant lambda */</span>
00521   <span class="keywordflow">for</span> (j = 0; j &lt;= M; j++)
00522   {
00523     y[j] = lambda * it2[j];
00524   }
00525 }
00526 
<a name="l00545"></a><a class="code" href="fpt_8c.html#a36">00545</a> <span class="keywordtype">void</span> <a class="code" href="fpt_8c.html#a36">eval_sum_clenshaw_transposed</a>(<span class="keywordtype">int</span> N, <span class="keywordtype">int</span> M, <span class="keywordtype">double</span> complex* a, <span class="keywordtype">double</span> *x,
00546   <span class="keywordtype">double</span> complex *y, <span class="keywordtype">double</span> complex *temp, <span class="keywordtype">double</span> *alpha, <span class="keywordtype">double</span> *beta, <span class="keywordtype">double</span> *gamma,
00547   <span class="keywordtype">double</span> lambda)
00548 {
00549   <span class="keywordtype">int</span> j,k;
00550   <span class="keywordtype">double</span> complex* it1 = temp;
00551   <span class="keywordtype">double</span> complex* it2 = y;
00552   <span class="keywordtype">double</span> complex aux;
00553 
00554   <span class="comment">/* Compute final result by multiplying with the constant lambda */</span>
00555   a[0] = 0.0;
00556   <span class="keywordflow">for</span> (j = 0; j &lt;= M; j++)
00557   {
00558     it2[j] = lambda * y[j];
00559     a[0] += it2[j];
00560   }
00561 
00562   <span class="keywordflow">if</span> (N &gt; 0)
00563   {
00564     <span class="comment">/* Compute final step. */</span>
00565     a[1] = 0.0;
00566     <span class="keywordflow">for</span> (j = 0; j &lt;= M; j++)
00567     {
00568       it1[j] = it2[j];
00569       it2[j] = it2[j] * (alpha[0] * x[j] + beta[0]);
00570       a[1] += it2[j];
00571     }
00572 
00573     <span class="keywordflow">for</span> (k = 2; k &lt;= N; k++)
00574     {
00575       a[k] = 0.0;
00576       <span class="keywordflow">for</span> (j = 0; j &lt;= M; j++)
00577       {
00578         aux = it1[j];
00579         it1[j] = it2[j];
00580         it2[j] = it2[j]*(alpha[k-1] * x[j] + beta[k-1]) + gamma[k-1] * aux;
00581         a[k] += it2[j];
00582       }
00583     }
00584   }
00585 }
00586 
00587 
<a name="l00588"></a><a class="code" href="group__fpt.html#ga1">00588</a> <a class="code" href="structfpt__set__s__.html">fpt_set</a> <a class="code" href="group__fpt.html#ga1">fpt_init</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> M, <span class="keyword">const</span> <span class="keywordtype">int</span> t, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
00589 {
00591   <span class="keywordtype">int</span> plength;
00593   <span class="keywordtype">int</span> tau;
00595   <span class="keywordtype">int</span> m;
00596   <span class="keywordtype">int</span> k;
00597 
00598   <span class="comment">/* Allocate memory for new DPT set. */</span>
00599   <a class="code" href="structfpt__set__s__.html">fpt_set_s</a> *set = (<a class="code" href="structfpt__set__s__.html">fpt_set_s</a>*)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structfpt__set__s__.html">fpt_set_s</a>));
00600 
00601   <span class="comment">/* Save parameters in structure. */</span>
00602   set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> = flags;
00603 
00604   <span class="comment">//fprintf(stderr,"\nfpt_init: flags = %d \t %d\n",set-&gt;flags,flags);</span>
00605 
00606   set-&gt;<a class="code" href="structfpt__set__s__.html#o1">M</a> = M;
00607   set-&gt;<a class="code" href="structfpt__set__s__.html#o3">t</a> = t;
00608   set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a> = 1&lt;&lt;t;
00609 
00610   <span class="comment">/* Allocate memory for L transforms. */</span>
00611   set-&gt;<a class="code" href="structfpt__set__s__.html#o4">dpt</a> = (<a class="code" href="structfpt__data__.html">fpt_data</a>*) malloc((M+1)*<span class="keyword">sizeof</span>(<a class="code" href="structfpt__data__.html">fpt_data</a>));
00612 
00613   <span class="comment">/* Initialize with NULL pointer. */</span>
00614   <span class="keywordflow">for</span> (m = 0; m &lt;= set-&gt;M; m++)
00615   {
00616     set-&gt;<a class="code" href="structfpt__set__s__.html#o4">dpt</a>[m].<a class="code" href="structfpt__data__.html#o0">steps</a> = (<a class="code" href="structfpt__step__.html">fpt_step</a>**) NULL;
00617   }
00618 
00619   <span class="comment">/* Create arrays with Chebyshev nodes. */</span>
00620 
00621   <span class="comment">/* Initialize array with Chebyshev coefficients for the polynomial x. This</span>
00622 <span class="comment">   * would be trivially an array containing a 1 as second entry with all other</span>
00623 <span class="comment">   * coefficients set to zero. In order to compensate for the multiplicative</span>
00624 <span class="comment">   * factor 2 introduced by the DCT-III, we set this coefficient to 0.5 here. */</span>
00625 
00626   <span class="comment">/* Allocate memory for array of pointers to node arrays. */</span>
00627   set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a> = (<span class="keywordtype">double</span>**) malloc((set-&gt;<a class="code" href="structfpt__set__s__.html#o3">t</a><span class="comment">/*-1*/</span>)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
00628   <span class="comment">/* For each polynomial length starting with 4, compute the Chebyshev nodes</span>
00629 <span class="comment">   * using a DCT-III. */</span>
00630   plength = 4;
00631   <span class="keywordflow">for</span> (tau = 1; tau &lt; <span class="comment">/*t*/</span>t+1; tau++)
00632   {
00633     <span class="comment">/* Allocate memory for current array. */</span>
00634     set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tau-1] = (<span class="keywordtype">double</span>*) malloc(plength*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00635     <span class="keywordflow">for</span> (k = 0; k &lt; plength; k++)
00636     {
00637       set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tau-1][k] = cos(((k+0.5)*<a class="code" href="group__nfftutil.html#ga57">PI</a>)/plength);
00638     }
00639     plength = plength &lt;&lt; 1;
00640   }
00641 
00643   set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a> = (<span class="keywordtype">double</span> complex*) malloc((2*set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00644   set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a> = (<span class="keywordtype">double</span> complex*) malloc((2*set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00645 
00646   <span class="comment">/* Check if fast transform is activated. */</span>
00647   <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga8">FPT_NO_FAST_ALGORITHM</a>)
00648   {
00649   }
00650   <span class="keywordflow">else</span>
00651   {
00653     set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a> = (<span class="keywordtype">double</span> complex*) malloc(set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00654     set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a> = (<span class="keywordtype">double</span> complex*) malloc(set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00655     set-&gt;<a class="code" href="structfpt__set__s__.html#o12">z</a> = (<span class="keywordtype">double</span> complex*) malloc(set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00656 
00658     set-&gt;<a class="code" href="structfpt__set__s__.html#o13">plans_dct3</a> = (fftw_plan*) fftw_malloc(<span class="keyword">sizeof</span>(fftw_plan)*(set-&gt;<a class="code" href="structfpt__set__s__.html#o3">t</a><span class="comment">/*-1*/</span>));
00659     set-&gt;<a class="code" href="structfpt__set__s__.html#o14">plans_dct2</a> = (fftw_plan*) fftw_malloc(<span class="keyword">sizeof</span>(fftw_plan)*(set-&gt;<a class="code" href="structfpt__set__s__.html#o3">t</a><span class="comment">/*-1*/</span>));
00660     set-&gt;<a class="code" href="structfpt__set__s__.html#o15">kinds</a>      = (fftw_r2r_kind*) malloc(2*<span class="keyword">sizeof</span>(fftw_r2r_kind));
00661     set-&gt;<a class="code" href="structfpt__set__s__.html#o15">kinds</a>[0]   = FFTW_REDFT01;
00662     set-&gt;<a class="code" href="structfpt__set__s__.html#o15">kinds</a>[1]   = FFTW_REDFT01;
00663     set-&gt;<a class="code" href="structfpt__set__s__.html#o16">kindsr</a>     = (fftw_r2r_kind*) malloc(2*<span class="keyword">sizeof</span>(fftw_r2r_kind));
00664     set-&gt;<a class="code" href="structfpt__set__s__.html#o16">kindsr</a>[0]  = FFTW_REDFT10;
00665     set-&gt;<a class="code" href="structfpt__set__s__.html#o16">kindsr</a>[1]  = FFTW_REDFT10;
00666     set-&gt;<a class="code" href="structfpt__set__s__.html#o17">lengths</a>    = (<span class="keywordtype">int</span>*) malloc((set-&gt;<a class="code" href="structfpt__set__s__.html#o3">t</a><span class="comment">/*-1*/</span>)*<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
00667     <span class="keywordflow">for</span> (tau = 0, plength = 4; tau &lt; set-&gt;t<span class="comment">/*-1*/</span>; tau++, plength&lt;&lt;=1)
00668     {
00669       set-&gt;<a class="code" href="structfpt__set__s__.html#o17">lengths</a>[tau] = plength;
00670       set-&gt;<a class="code" href="structfpt__set__s__.html#o13">plans_dct3</a>[tau] =
00671         fftw_plan_many_r2r(1, &amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o17">lengths</a>[tau], 2, (<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>, NULL,
00672                            2, 1, (<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>, NULL, 2, 1, set-&gt;<a class="code" href="structfpt__set__s__.html#o15">kinds</a>,
00673                            0);
00674       set-&gt;<a class="code" href="structfpt__set__s__.html#o14">plans_dct2</a>[tau] =
00675         fftw_plan_many_r2r(1, &amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o17">lengths</a>[tau], 2, (<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>, NULL,
00676                            2, 1, (<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>, NULL, 2, 1,set-&gt;<a class="code" href="structfpt__set__s__.html#o16">kindsr</a>,
00677                            0);
00678     }
00679     free(set-&gt;<a class="code" href="structfpt__set__s__.html#o17">lengths</a>);
00680     free(set-&gt;<a class="code" href="structfpt__set__s__.html#o15">kinds</a>);
00681     free(set-&gt;<a class="code" href="structfpt__set__s__.html#o16">kindsr</a>);
00682     set-&gt;<a class="code" href="structfpt__set__s__.html#o17">lengths</a> = NULL;
00683     set-&gt;<a class="code" href="structfpt__set__s__.html#o15">kinds</a> = NULL;
00684     set-&gt;<a class="code" href="structfpt__set__s__.html#o16">kindsr</a> = NULL;
00685   }
00686 
00687   <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga9">FPT_NO_DIRECT_ALGORITHM</a>)
00688   {
00689   }
00690   <span class="keywordflow">else</span>
00691   {
00692     set-&gt;<a class="code" href="structfpt__set__s__.html#o18">xc_slow</a> = (<span class="keywordtype">double</span>*) malloc((set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00693     set-&gt;<a class="code" href="structfpt__set__s__.html#o7">temp</a> = (<span class="keywordtype">double</span> complex*) calloc((set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>+1),<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00694   }
00695 
00696   <span class="comment">/* Return the newly created DPT set. */</span>
00697   <span class="keywordflow">return</span> set;
00698 }
00699 
<a name="l00700"></a><a class="code" href="group__fpt.html#ga2">00700</a> <span class="keywordtype">void</span> <a class="code" href="group__fpt.html#ga2">fpt_precompute</a>(<a class="code" href="structfpt__set__s__.html">fpt_set</a> set, <span class="keyword">const</span> <span class="keywordtype">int</span> m, <span class="keyword">const</span> <span class="keywordtype">double</span> *alpha,
00701                     <span class="keyword">const</span> <span class="keywordtype">double</span> *beta, <span class="keyword">const</span> <span class="keywordtype">double</span> *gamma, <span class="keywordtype">int</span> k_start,
00702                     <span class="keyword">const</span> <span class="keywordtype">double</span> threshold)
00703 {
00704 
00705   <span class="keywordtype">int</span> tau;          
00706   <span class="keywordtype">int</span> l;            
00707   <span class="keywordtype">int</span> plength;      
00709   <span class="keywordtype">int</span> degree;       
00711   <span class="keywordtype">int</span> firstl;       
00712   <span class="keywordtype">int</span> lastl;        
00713   <span class="keywordtype">int</span> plength_stab; 
00715   <span class="keywordtype">int</span> degree_stab;  
00717   <span class="keywordtype">double</span> *a11;      
00719   <span class="keywordtype">double</span> *a12;      
00721   <span class="keywordtype">double</span> *a21;      
00723   <span class="keywordtype">double</span> *a22;      
00725   <span class="keyword">const</span> <span class="keywordtype">double</span> *calpha;
00726   <span class="keyword">const</span> <span class="keywordtype">double</span> *cbeta;
00727   <span class="keyword">const</span> <span class="keywordtype">double</span> *cgamma;
00728   <span class="keywordtype">int</span> needstab = 0; 
00729   <span class="keywordtype">int</span> k_start_tilde;
00730   <span class="keywordtype">int</span> N_tilde;
00731   <span class="keywordtype">int</span> clength;
00732   <span class="keywordtype">int</span> clength_1;
00733   <span class="keywordtype">int</span> clength_2;
00734   <span class="keywordtype">int</span> t_stab, N_stab;
00735   <span class="keywordtype">int</span> ell;
00736 
00737   <span class="comment">//fprintf(stderr,"fpt_precompute: Precomputing for m = %d\n",m);</span>
00738   <span class="comment">//fprintf(stderr,"fpt_precompute: k_start = %d\n",k_start);</span>
00739 
00740   <a class="code" href="structfpt__data__.html">fpt_data</a> *data;
00741 
00742   <span class="comment">/* Allocate memory for DPT transform data. */</span>
00743   <span class="comment">//set-&gt;dpt[m] = (fpt_data*) malloc(sizeof(fpt_data));</span>
00744 
00745   <span class="comment">/* Get pointer to DPT data. */</span>
00746   data = &amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o4">dpt</a>[m]);
00747 
00748   <span class="comment">/* Check, if already precomputed. */</span>
00749   <span class="keywordflow">if</span> (data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a> != NULL)
00750   {
00751     <span class="keywordflow">return</span>;
00752   }
00753 
00754   <span class="comment">/* Save k_start. */</span>
00755   data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a> = k_start;
00756 
00757   <span class="comment">/* Check if fast transform is activated. */</span>
00758   <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga8">FPT_NO_FAST_ALGORITHM</a>)
00759   {
00760   }
00761   <span class="keywordflow">else</span>
00762   {
00763     <span class="comment">/* Save recursion coefficients. */</span>
00764     data-&gt;<a class="code" href="structfpt__data__.html#o2">alphaN</a> = (<span class="keywordtype">double</span>*) malloc((set-&gt;<a class="code" href="structfpt__set__s__.html#o3">t</a>-1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00765     data-&gt;<a class="code" href="structfpt__data__.html#o3">betaN</a> = (<span class="keywordtype">double</span>*) malloc((set-&gt;<a class="code" href="structfpt__set__s__.html#o3">t</a>-1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00766     data-&gt;<a class="code" href="structfpt__data__.html#o4">gammaN</a> = (<span class="keywordtype">double</span>*) malloc((set-&gt;<a class="code" href="structfpt__set__s__.html#o3">t</a>-1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
00767 
00768     <span class="keywordflow">for</span> (tau = 2; tau &lt;= set-&gt;t; tau++)
00769     {
00770 
00771       data-&gt;<a class="code" href="structfpt__data__.html#o2">alphaN</a>[tau-2] = alpha[1&lt;&lt;tau];
00772       data-&gt;<a class="code" href="structfpt__data__.html#o3">betaN</a>[tau-2] = beta[1&lt;&lt;tau];
00773       data-&gt;<a class="code" href="structfpt__data__.html#o4">gammaN</a>[tau-2] = gamma[1&lt;&lt;tau];
00774     }
00775 
00776     data-&gt;<a class="code" href="structfpt__data__.html#o5">alpha_0</a> = alpha[1];
00777     data-&gt;<a class="code" href="structfpt__data__.html#o6">beta_0</a> = beta[1];
00778     data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a> = gamma[0];
00779 
00780     k_start_tilde = <a class="code" href="fpt_8c.html#a0">K_START_TILDE</a>(data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>,<a class="code" href="group__nfftutil.html#ga4">nfft_next_power_of_2</a>(data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>)
00781       <span class="comment">/*set-&gt;N*/</span>);
00782     N_tilde = N_TILDE(set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>);
00783 
00784     <span class="comment">/* Allocate memory for the cascade with t = log_2(N) many levels. */</span>
00785     data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a> = (<a class="code" href="structfpt__step__.html">fpt_step</a>**) malloc(<span class="keyword">sizeof</span>(<a class="code" href="structfpt__step__.html">fpt_step</a>*)*set-&gt;<a class="code" href="structfpt__set__s__.html#o3">t</a>);
00786 
00787     <span class="comment">/* For tau = 1,...t compute the matrices U_{n,tau,l}. */</span>
00788     plength = 4;
00789     <span class="keywordflow">for</span> (tau = 1; tau &lt; set-&gt;t; tau++)
00790     {
00791       <span class="comment">/* Compute auxilliary values. */</span>
00792       degree = plength&gt;&gt;1;
00793       <span class="comment">/* Compute first l. */</span>
00794       firstl = <a class="code" href="fpt_8c.html#a2">FIRST_L</a>(k_start_tilde,plength);
00795       <span class="comment">/* Compute last l. */</span>
00796       lastl = <a class="code" href="fpt_8c.html#a3">LAST_L</a>(N_tilde,plength);
00797 
00798       <span class="comment">/* Allocate memory for current level. This level will contain 2^{t-tau-1}</span>
00799 <span class="comment">       * many matrices. */</span>
00800       data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau] = (<a class="code" href="structfpt__step__.html">fpt_step</a>*) fftw_malloc(<span class="keyword">sizeof</span>(<a class="code" href="structfpt__step__.html">fpt_step</a>)
00801                          * (lastl+1));
00802 
00803       <span class="comment">/* For l = 0,...2^{t-tau-1}-1 compute the matrices U_{n,tau,l}. */</span>
00804       <span class="keywordflow">for</span> (l = firstl; l &lt;= lastl; l++)
00805       {
00806         <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga13">FPT_AL_SYMMETRY</a> &amp;&amp; IS_SYMMETRIC(l,m,plength))
00807         {
00808           <span class="comment">//fprintf(stderr,"fpt_precompute(%d): symmetric step\n",m);</span>
00809           <span class="comment">//fflush(stderr);</span>
00810           clength = plength/2;
00811         }
00812         <span class="keywordflow">else</span>
00813         {
00814           clength = plength;
00815         }
00816 
00817         <span class="comment">/* Allocate memory for the components of U_{n,tau,l}. */</span>
00818         a11 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*clength);
00819         a12 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*clength);
00820         a21 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*clength);
00821         a22 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*clength);
00822 
00823         <span class="comment">/* Evaluate the associated polynomials at the 2^{tau+1} Chebyshev</span>
00824 <span class="comment">         * nodes. */</span>
00825 
00826         <span class="comment">/* Get the pointers to the three-term recurrence coeffcients. */</span>
00827         calpha = &amp;(alpha[plength*l+1+1]);
00828         cbeta = &amp;(beta[plength*l+1+1]);
00829         cgamma = &amp;(gamma[plength*l+1+1]);
00830 
00831         <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga10">FPT_NO_STABILIZATION</a>)
00832         {
00833           <span class="comment">/* Evaluate P_{2^{tau}-2}^n(\cdot,2^{tau+1}l+2). */</span>
00834           <a class="code" href="fpt_8c.html#a33">eval_clenshaw</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tau-1], a11, clength, degree-2, calpha, cbeta,
00835             cgamma);
00836           <a class="code" href="fpt_8c.html#a33">eval_clenshaw</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tau-1], a12, clength, degree-1, calpha, cbeta,
00837             cgamma);
00838           calpha--;
00839           cbeta--;
00840           cgamma--;
00841           <a class="code" href="fpt_8c.html#a33">eval_clenshaw</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tau-1], a21, clength, degree-1, calpha, cbeta,
00842             cgamma);
00843           <a class="code" href="fpt_8c.html#a33">eval_clenshaw</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tau-1], a22, clength, degree, calpha, cbeta,
00844             cgamma);
00845           needstab = 0;
00846         }
00847         <span class="keywordflow">else</span>
00848         {
00849           needstab = eval_clenshaw_thresh(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tau-1], a11, clength, degree-2,
00850             calpha, cbeta, cgamma, threshold);
00851           <span class="keywordflow">if</span> (needstab == 0)
00852           {
00853             <span class="comment">/* Evaluate P_{2^{tau}-1}^n(\cdot,2^{tau+1}l+2). */</span>
00854             needstab = eval_clenshaw_thresh(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tau-1], a12, clength, degree-1,
00855               calpha, cbeta, cgamma, threshold);
00856             <span class="keywordflow">if</span> (needstab == 0)
00857             {
00858               calpha--;
00859               cbeta--;
00860               cgamma--;
00861               <span class="comment">/* Evaluate P_{2^{tau}-1}^n(\cdot,2^{tau+1}l+1). */</span>
00862               needstab = eval_clenshaw_thresh(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tau-1], a21, clength,
00863                 degree-1, calpha, cbeta, cgamma, threshold);
00864               <span class="keywordflow">if</span> (needstab == 0)
00865               {
00866                 <span class="comment">/* Evaluate P_{2^{tau}}^n(\cdot,2^{tau+1}l+1). */</span>
00867                 needstab = eval_clenshaw_thresh(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tau-1], a22, clength,
00868                   degree, calpha, cbeta, cgamma, threshold);
00869               }
00870             }
00871           }
00872         }
00873 
00874         <span class="comment">/* Check if stabilization needed. */</span>
00875         <span class="keywordflow">if</span> (needstab == 0)
00876         {
00877           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o3">a11</a> = (<span class="keywordtype">double</span>**) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
00878           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o4">a12</a> = (<span class="keywordtype">double</span>**) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
00879           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o5">a21</a> = (<span class="keywordtype">double</span>**) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
00880           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o6">a22</a> = (<span class="keywordtype">double</span>**) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
00881           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o7">gamma</a> = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00882           <span class="comment">/* No stabilization needed. */</span>
00883           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o3">a11</a>[0] = a11;
00884           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o4">a12</a>[0] = a12;
00885           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o5">a21</a>[0] = a21;
00886           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o6">a22</a>[0] = a22;
00887           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o7">gamma</a>[0] = gamma[plength*l+1+1];
00888           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o0">stable</a> = <span class="keyword">true</span>;
00889         }
00890         <span class="keywordflow">else</span>
00891         {
00892           <span class="comment">/* Stabilize. */</span>
00893           <span class="comment">//fprintf(stderr,"fpt_precompute: Stabilizing for tau = %d, l = %d\n",tau,l);</span>
00894           degree_stab = degree*(2*l+1);
00895           <a class="code" href="group__nfftutil.html#ga5">nfft_next_power_of_2_exp</a>((l+1)*(1&lt;&lt;(tau+1)),&amp;N_stab,&amp;t_stab);
00896           <span class="comment">/*fprintf(stderr,"(l+1)*(1&lt;&lt;(tau+2)) = %d, N_stab = %d, t_stab = %d\n",</span>
00897 <span class="comment">            (l+1)*(1&lt;&lt;(tau+2)),N_stab,t_stab);*/</span>
00898 
00899           <span class="comment">/* Old arrays are to small. */</span>
00900           fftw_free(a11);
00901           fftw_free(a12);
00902           fftw_free(a21);
00903           fftw_free(a22);
00904 
00905           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o3">a11</a> = (<span class="keywordtype">double</span>**) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
00906           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o4">a12</a> = (<span class="keywordtype">double</span>**) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
00907           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o5">a21</a> = (<span class="keywordtype">double</span>**) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
00908           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o6">a22</a> = (<span class="keywordtype">double</span>**) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>*));
00909           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o7">gamma</a> = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00910 
00911           plength_stab = N_stab;
00912 
00913           <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga13">FPT_AL_SYMMETRY</a>)
00914           {
00915             <span class="keywordflow">if</span> (m &lt;= 1)
00916             {
00917               clength_1 = plength_stab/2;
00918               clength_2 = plength_stab/2;
00919             }
00920             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m%2 == 0)
00921             {
00922               clength_1 = plength_stab/2;
00923               clength_2 = plength_stab;
00924             }
00925             <span class="keywordflow">else</span>
00926             {
00927               clength_1 = plength_stab;
00928               clength_2 = plength_stab/2;
00929             }
00930           }
00931           <span class="keywordflow">else</span>
00932           {
00933             clength_1 = plength_stab;
00934             clength_2 = plength_stab;
00935           }
00936 
00937 
00938           <span class="comment">/* Allocate memory for arrays. */</span>
00939           a11 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*clength_1);
00940           a12 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*clength_1);
00941           a21 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*clength_2);
00942           a22 = (<span class="keywordtype">double</span>*) fftw_malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)*clength_2);
00943 
00944           <span class="comment">/* Get the pointers to the three-term recurrence coeffcients. */</span>
00945           calpha = &amp;(alpha[2]);
00946           cbeta = &amp;(beta[2]);
00947           cgamma = &amp;(gamma[2]);
00948           <span class="comment">/* Evaluate P_{2^{tau}(2l+1)-2}^n(\cdot,2). */</span>
00949           <a class="code" href="fpt_8c.html#a33">eval_clenshaw</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[t_stab-2], a11, clength_1, degree_stab-2,
00950             calpha, cbeta, cgamma);
00951           <span class="comment">/* Evaluate P_{2^{tau}(2l+1)-1}^n(\cdot,2). */</span>
00952           <a class="code" href="fpt_8c.html#a33">eval_clenshaw</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[t_stab-2], a12, clength_1, degree_stab-1,
00953             calpha, cbeta, cgamma);
00954           calpha--;
00955           cbeta--;
00956           cgamma--;
00957           <span class="comment">/* Evaluate P_{2^{tau}(2l+1)-1}^n(\cdot,1). */</span>
00958           <a class="code" href="fpt_8c.html#a33">eval_clenshaw</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[t_stab-2], a21, clength_2, degree_stab-1,
00959             calpha, cbeta, cgamma);
00960           <span class="comment">/* Evaluate P_{2^{tau}(2l+1)}^n(\cdot,1). */</span>
00961           <a class="code" href="fpt_8c.html#a33">eval_clenshaw</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[t_stab-2], a22, clength_2, degree_stab+0,
00962             calpha, cbeta, cgamma);
00963 
00964           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o3">a11</a>[0] = a11;
00965           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o4">a12</a>[0] = a12;
00966           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o5">a21</a>[0] = a21;
00967           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o6">a22</a>[0] = a22;
00968           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o7">gamma</a>[0] =  gamma[1+1];
00969           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o0">stable</a> = <span class="keyword">false</span>;
00970           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o2">t_stab</a> = t_stab;
00971           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o1">N_stab</a> = N_stab;
00972         }
00973       }
00975       plength = plength &lt;&lt; 1;
00976     }
00977   }
00978 
00979   <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga9">FPT_NO_DIRECT_ALGORITHM</a>)
00980   {
00981   }
00982   <span class="keywordflow">else</span>
00983   {
00984     <span class="comment">/* Check, if recurrence coefficients must be copied. */</span>
00985     <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga11">FPT_PERSISTENT_DATA</a>)
00986     {
00987       data-&gt;<a class="code" href="structfpt__data__.html#o8">alpha</a> = (<span class="keywordtype">double</span>*) alpha;
00988       data-&gt;<a class="code" href="structfpt__data__.html#o9">beta</a> = (<span class="keywordtype">double</span>*) beta;
00989       data-&gt;<a class="code" href="structfpt__data__.html#o10">gamma</a> = (<span class="keywordtype">double</span>*) gamma;
00990     }
00991     <span class="keywordflow">else</span>
00992     {
00993       data-&gt;<a class="code" href="structfpt__data__.html#o8">alpha</a> = (<span class="keywordtype">double</span>*) malloc((set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00994       data-&gt;<a class="code" href="structfpt__data__.html#o9">beta</a> = (<span class="keywordtype">double</span>*) malloc((set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00995       data-&gt;<a class="code" href="structfpt__data__.html#o10">gamma</a> = (<span class="keywordtype">double</span>*) malloc((set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00996       memcpy(data-&gt;<a class="code" href="structfpt__data__.html#o8">alpha</a>,alpha,(set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00997       memcpy(data-&gt;<a class="code" href="structfpt__data__.html#o9">beta</a>,beta,(set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00998       memcpy(data-&gt;<a class="code" href="structfpt__data__.html#o10">gamma</a>,gamma,(set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>));
00999     }
01000   }
01001 }
01002 
<a name="l01003"></a><a class="code" href="group__fpt.html#ga3">01003</a> <span class="keywordtype">void</span> <a class="code" href="group__fpt.html#ga3">dpt_trafo</a>(<a class="code" href="structfpt__set__s__.html">fpt_set</a> set, <span class="keyword">const</span> <span class="keywordtype">int</span> m, <span class="keyword">const</span> <span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> complex *y,
01004   <span class="keyword">const</span> <span class="keywordtype">int</span> k_end, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
01005 {
01006   <span class="keywordtype">int</span> j;
01007   <a class="code" href="structfpt__data__.html">fpt_data</a> *data = &amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o4">dpt</a>[m]);
01008   <span class="keywordtype">int</span> Nk;
01009   <span class="keywordtype">int</span> tk;
01010   <span class="keywordtype">double</span> norm;
01011 
01012   <a class="code" href="group__nfftutil.html#ga5">nfft_next_power_of_2_exp</a>(k_end+1,&amp;Nk,&amp;tk);
01013   norm = 2.0/(Nk&lt;&lt;1);
01014 
01015   <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga9">FPT_NO_DIRECT_ALGORITHM</a>)
01016   {
01017     <span class="keywordflow">return</span>;
01018   }
01019 
01020   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__fpt.html#ga12">FPT_FUNCTION_VALUES</a>)
01021   {
01022     <span class="comment">/* Fill array with Chebyshev nodes. */</span>
01023     <span class="keywordflow">for</span> (j = 0; j &lt;= k_end; j++)
01024     {
01025       set-&gt;<a class="code" href="structfpt__set__s__.html#o18">xc_slow</a>[j] = cos((<a class="code" href="group__nfftutil.html#ga57">PI</a>*(j+0.5))/(k_end+1));
01026     }
01027 
01028     memset(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>,0U,data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01029     memcpy(&amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>],x,(k_end-data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01030 
01031     <a class="code" href="fpt_8c.html#a35">eval_sum_clenshaw</a>(k_end, k_end, set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o18">xc_slow</a>,
01032       y, set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>, &amp;data-&gt;<a class="code" href="structfpt__data__.html#o8">alpha</a>[1], &amp;data-&gt;<a class="code" href="structfpt__data__.html#o9">beta</a>[1], &amp;data-&gt;<a class="code" href="structfpt__data__.html#o10">gamma</a>[1],
01033       data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a>);
01034   }
01035   <span class="keywordflow">else</span>
01036   {
01037     memset(set-&gt;<a class="code" href="structfpt__set__s__.html#o7">temp</a>,0U,data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01038     memcpy(&amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o7">temp</a>[data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>],x,(k_end-data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01039 
01040     <a class="code" href="fpt_8c.html#a35">eval_sum_clenshaw</a>(k_end, Nk-1, set-&gt;<a class="code" href="structfpt__set__s__.html#o7">temp</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tk-2],
01041       set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>, &amp;data-&gt;<a class="code" href="structfpt__data__.html#o8">alpha</a>[1], &amp;data-&gt;<a class="code" href="structfpt__data__.html#o9">beta</a>[1], &amp;data-&gt;<a class="code" href="structfpt__data__.html#o10">gamma</a>[1],
01042       data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a>);
01043 
01044     fftw_execute_r2r(set-&gt;<a class="code" href="structfpt__set__s__.html#o14">plans_dct2</a>[tk-2],(<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>,
01045       (<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>);
01046 
01047     set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[0] *= 0.5;
01048     <span class="keywordflow">for</span> (j = 0; j &lt; Nk; j++)
01049     {
01050       set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[j] *= norm;
01051     }
01052 
01053     memcpy(y,set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>,(k_end+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01054   }
01055 }
01056 
<a name="l01057"></a><a class="code" href="group__fpt.html#ga4">01057</a> <span class="keywordtype">void</span> <a class="code" href="group__fpt.html#ga4">fpt_trafo</a>(<a class="code" href="structfpt__set__s__.html">fpt_set</a> set, <span class="keyword">const</span> <span class="keywordtype">int</span> m, <span class="keyword">const</span> <span class="keywordtype">double</span> complex *x, <span class="keywordtype">double</span> complex *y,
01058   <span class="keyword">const</span> <span class="keywordtype">int</span> k_end, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
01059 {
01060   <span class="comment">/* Get transformation data. */</span>
01061   <a class="code" href="structfpt__data__.html">fpt_data</a> *data = &amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o4">dpt</a>[m]);
01063   <span class="keywordtype">int</span> Nk;
01065   <span class="keywordtype">int</span> tk;
01067   <span class="keywordtype">int</span> k_start_tilde;
01069   <span class="keywordtype">int</span> k_end_tilde;
01070 
01072   <span class="keywordtype">int</span> tau;
01074   <span class="keywordtype">int</span> firstl;
01076   <span class="keywordtype">int</span> lastl;
01078   <span class="keywordtype">int</span> l;
01080   <span class="keywordtype">int</span> plength;
01082   <span class="keywordtype">int</span> plength_stab;
01083   <span class="keywordtype">int</span> t_stab;
01085   <a class="code" href="structfpt__step__.html">fpt_step</a> *step;
01087   fftw_plan plan;
01088   <span class="keywordtype">int</span> length = k_end+1;
01089   fftw_r2r_kind kinds[2] = {FFTW_REDFT01,FFTW_REDFT01};
01090 
01092   <span class="keywordtype">int</span> k;
01093 
01094   <span class="keywordtype">double</span> complex *work_ptr;
01095   <span class="keyword">const</span> <span class="keywordtype">double</span> complex *x_ptr;
01096 
01097   <span class="comment">/* Check, if slow transformation should be used due to small bandwidth. */</span>
01098   <span class="keywordflow">if</span> (k_end &lt; FPT_BREAK_EVEN)
01099   {
01100     <span class="comment">/* Use NDSFT. */</span>
01101     <a class="code" href="group__fpt.html#ga3">dpt_trafo</a>(set, m, x, y, k_end, flags);
01102   }
01103 
01104   <a class="code" href="group__nfftutil.html#ga5">nfft_next_power_of_2_exp</a>(k_end,&amp;Nk,&amp;tk);
01105   k_start_tilde = <a class="code" href="fpt_8c.html#a0">K_START_TILDE</a>(data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>,Nk);
01106   k_end_tilde = <a class="code" href="fpt_8c.html#a1">K_END_TILDE</a>(k_end,Nk);
01107 
01108   <span class="comment">/* Check if fast transform is activated. */</span>
01109   <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga8">FPT_NO_FAST_ALGORITHM</a>)
01110   {
01111     <span class="keywordflow">return</span>;
01112   }
01113 
01114   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__fpt.html#ga12">FPT_FUNCTION_VALUES</a>)
01115   {
01116     plan = fftw_plan_many_r2r(1, &amp;length, 2, (<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>, NULL, 2, 1,
01117       (<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>, NULL, 2, 1, kinds, 0U);
01118   }
01119 
01120   <span class="comment">/* Initialize working arrays. */</span>
01121   memset(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>,0U,2*Nk*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01122 
01123   <span class="comment">/* The first step. */</span>
01124 
01125   <span class="comment">/* Set the first 2*data-&gt;k_start coefficients to zero. */</span>
01126   memset(set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>,0U,2*data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01127 
01128   work_ptr = &amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[2*data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>];
01129   x_ptr = x;
01130 
01131   <span class="keywordflow">for</span> (k = 0; k &lt; k_end_tilde-data-&gt;k_start+1; k++)
01132   {
01133     *work_ptr++ = *x_ptr++;
01134     *work_ptr++ = 0;
01135   }
01136 
01137   <span class="comment">/* Set the last 2*(set-&gt;N-1-k_end_tilde) coefficients to zero. */</span>
01138   memset(&amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[2*(k_end_tilde+1)],0U,2*(Nk-1-k_end_tilde)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01139 
01140   <span class="comment">/* If k_end == Nk, use three-term recurrence to map last coefficient x_{Nk} to</span>
01141 <span class="comment">   * x_{Nk-1} and x_{Nk-2}. */</span>
01142   <span class="keywordflow">if</span> (k_end == Nk)
01143   {
01144     set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[2*(Nk-2)]   += data-&gt;<a class="code" href="structfpt__data__.html#o4">gammaN</a>[tk-2]*x[Nk-data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>];
01145     set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[2*(Nk-1)]   += data-&gt;<a class="code" href="structfpt__data__.html#o3">betaN</a>[tk-2]*x[Nk-data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>];
01146     set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[2*(Nk-1)+1]  = data-&gt;<a class="code" href="structfpt__data__.html#o2">alphaN</a>[tk-2]*x[Nk-data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>];
01147   }
01148 
01149   <span class="comment">/*--------*/</span>
01150   <span class="comment">/*for (k = 0; k &lt; 2*Nk; k++)</span>
01151 <span class="comment">  {</span>
01152 <span class="comment">    fprintf(stderr,"work[%2d] = %le + I*%le\tresult[%2d] = %le + I*%le\n",</span>
01153 <span class="comment">      k,creal(set-&gt;work[k]),cimag(set-&gt;work[k]),k,creal(set-&gt;result[k]),</span>
01154 <span class="comment">      cimag(set-&gt;result[k]));</span>
01155 <span class="comment">  }*/</span>
01156   <span class="comment">/*--------*/</span>
01157 
01158   <span class="comment">/* Compute the remaining steps. */</span>
01159   plength = 4;
01160   <span class="keywordflow">for</span> (tau = 1; tau &lt; tk; tau++)
01161   {
01162     <span class="comment">/* Compute first l. */</span>
01163     firstl = <a class="code" href="fpt_8c.html#a2">FIRST_L</a>(k_start_tilde,plength);
01164     <span class="comment">/* Compute last l. */</span>
01165     lastl = <a class="code" href="fpt_8c.html#a3">LAST_L</a>(k_end_tilde,plength);
01166 
01167     <span class="comment">/* Compute the multiplication steps. */</span>
01168     <span class="keywordflow">for</span> (l = firstl; l &lt;= lastl; l++)
01169     {
01170       <span class="comment">/* Copy vectors to multiply into working arrays zero-padded to twice the length. */</span>
01171       memcpy(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>,&amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[(plength/2)*(4*l+2)]),(plength/2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01172       memcpy(set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>,&amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[(plength/2)*(4*l+3)]),(plength/2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01173       memset(&amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>[plength/2],0U,(plength/2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01174       memset(&amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>[plength/2],0U,(plength/2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01175 
01176       <span class="comment">/* Copy coefficients into first half. */</span>
01177       memcpy(&amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[(plength/2)*(4*l+2)]),&amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[(plength/2)*(4*l+1)]),(plength/2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01178       memset(&amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[(plength/2)*(4*l+1)]),0U,(plength/2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01179       memset(&amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[(plength/2)*(4*l+3)]),0U,(plength/2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01180 
01181       <span class="comment">/* Get matrix U_{n,tau,l} */</span>
01182       step = &amp;(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l]);
01183 
01184       <span class="comment">/* Check if step is stable. */</span>
01185       <span class="keywordflow">if</span> (step-&gt;<a class="code" href="structfpt__step__.html#o0">stable</a>)
01186       {
01187         <span class="comment">/* Check, if we should do a symmetrizised step. */</span>
01188         <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga13">FPT_AL_SYMMETRY</a> &amp;&amp; IS_SYMMETRIC(l,m,plength))
01189         {
01190           <span class="comment">/*for (k = 0; k &lt; plength; k++)</span>
01191 <span class="comment">          {</span>
01192 <span class="comment">            fprintf(stderr,"fpt_trafo: a11 = %le, a12 = %le, a21 = %le, a22 = %le\n",</span>
01193 <span class="comment">              step-&gt;a11[0][k],step-&gt;a12[0][k],step-&gt;a21[0][k],step-&gt;a22[0][k]);</span>
01194 <span class="comment">          }*/</span>
01195           <span class="comment">/* Multiply third and fourth polynomial with matrix U. */</span>
01196           <span class="comment">//fprintf(stderr,"\nhallo\n");</span>
01197           <a class="code" href="fpt_8c.html#a26">fpt_do_step_symmetric</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>, step-&gt;<a class="code" href="structfpt__step__.html#o3">a11</a>[0],
01198             step-&gt;<a class="code" href="structfpt__step__.html#o4">a12</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o5">a21</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o6">a22</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0], tau, set);
01199         }
01200         <span class="keywordflow">else</span>
01201         {
01202           <span class="comment">/* Multiply third and fourth polynomial with matrix U. */</span>
01203           fpt_do_step(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>, step-&gt;<a class="code" href="structfpt__step__.html#o3">a11</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o4">a12</a>[0],
01204             step-&gt;<a class="code" href="structfpt__step__.html#o5">a21</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o6">a22</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0], tau, set);
01205         }
01206 
01207         <span class="keywordflow">if</span> (step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0] != 0.0)
01208         {
01209           <span class="keywordflow">for</span> (k = 0; k &lt; plength; k++)
01210           {
01211             set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[plength*2*l+k] += set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>[k];
01212           }
01213         }
01214         <span class="keywordflow">for</span> (k = 0; k &lt; plength; k++)
01215         {
01216           set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[plength*(2*l+1)+k] += set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>[k];
01217         }
01218       }
01219       <span class="keywordflow">else</span>
01220       {
01221         <span class="comment">/* Stabilize. */</span>
01222 
01223         <span class="comment">/* The lengh of the polynomials */</span>
01224         plength_stab = step-&gt;<a class="code" href="structfpt__step__.html#o1">N_stab</a>;
01225         t_stab = step-&gt;<a class="code" href="structfpt__step__.html#o2">t_stab</a>;
01226 
01227         <span class="comment">/*---------*/</span>
01228         <span class="comment">/*fprintf(stderr,"\nfpt_trafo: stabilizing at tau = %d, l = %d.\n",tau,l);</span>
01229 <span class="comment">        fprintf(stderr,"\nfpt_trafo: plength_stab = %d.\n",plength_stab);</span>
01230 <span class="comment">        fprintf(stderr,"\nfpt_trafo: tk = %d.\n",tk);</span>
01231 <span class="comment">        fprintf(stderr,"\nfpt_trafo: index = %d.\n",tk-tau-1);*/</span>
01232         <span class="comment">/*---------*/</span>
01233 
01234         <span class="comment">/* Set rest of vectors explicitely to zero */</span>
01235         <span class="comment">/*fprintf(stderr,"fpt_trafo: stabilizing: plength = %d, plength_stab = %d\n",</span>
01236 <span class="comment">          plength, plength_stab);*/</span>
01237         memset(&amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>[plength/2],0U,(plength_stab-plength/2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01238         memset(&amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>[plength/2],0U,(plength_stab-plength/2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01239 
01240         <span class="comment">/* Multiply third and fourth polynomial with matrix U. */</span>
01241         <span class="comment">/* Check for symmetry. */</span>
01242         <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga13">FPT_AL_SYMMETRY</a>)
01243         {
01244           <span class="keywordflow">if</span> (m &lt;= 1)
01245           {
01246             <a class="code" href="fpt_8c.html#a26">fpt_do_step_symmetric</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>, step-&gt;<a class="code" href="structfpt__step__.html#o3">a11</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o4">a12</a>[0],
01247               step-&gt;<a class="code" href="structfpt__step__.html#o5">a21</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o6">a22</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0], t_stab-1, set);
01248           }
01249           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m%2 == 0)
01250           {
01251             <a class="code" href="fpt_8c.html#a27">fpt_do_step_symmetric_u</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>, step-&gt;<a class="code" href="structfpt__step__.html#o3">a11</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o4">a12</a>[0],
01252               step-&gt;<a class="code" href="structfpt__step__.html#o5">a21</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o6">a22</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0], t_stab-1, set);
01253           }
01254           <span class="keywordflow">else</span>
01255           {
01256             <a class="code" href="fpt_8c.html#a28">fpt_do_step_symmetric_l</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>, step-&gt;<a class="code" href="structfpt__step__.html#o3">a11</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o4">a12</a>[0],
01257               step-&gt;<a class="code" href="structfpt__step__.html#o5">a21</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o6">a22</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0], t_stab-1, set);
01258           }
01259         }
01260         <span class="keywordflow">else</span>
01261         {
01262             fpt_do_step(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>, step-&gt;<a class="code" href="structfpt__step__.html#o3">a11</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o4">a12</a>[0],
01263               step-&gt;<a class="code" href="structfpt__step__.html#o5">a21</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o6">a22</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0], t_stab-1, set);
01264         }
01265 
01266         <span class="keywordflow">if</span> (step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0] != 0.0)
01267         {
01268           <span class="keywordflow">for</span> (k = 0; k &lt; plength_stab; k++)
01269           {
01270             set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[k] += set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>[k];
01271           }
01272         }
01273 
01274         <span class="keywordflow">for</span> (k = 0; k &lt; plength_stab; k++)
01275         {
01276           set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk+k] += set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>[k];
01277         }
01278       }
01279     }
01280     <span class="comment">/* Double length of polynomials. */</span>
01281     plength = plength&lt;&lt;1;
01282 
01283     <span class="comment">/*--------*/</span>
01284     <span class="comment">/*for (k = 0; k &lt; 2*Nk; k++)</span>
01285 <span class="comment">    {</span>
01286 <span class="comment">      fprintf(stderr,"work[%2d] = %le + I*%le\tresult[%2d] = %le + I*%le\n",</span>
01287 <span class="comment">        k,creal(set-&gt;work[k]),cimag(set-&gt;work[k]),k,creal(set-&gt;result[k]),</span>
01288 <span class="comment">        cimag(set-&gt;result[k]));</span>
01289 <span class="comment">    }*/</span>
01290     <span class="comment">/*--------*/</span>
01291   }
01292 
01293   <span class="comment">/* Add the resulting cascade coeffcients to the coeffcients accumulated from</span>
01294 <span class="comment">   * the stabilization steps. */</span>
01295   <span class="keywordflow">for</span> (k = 0; k &lt; 2*Nk; k++)
01296   {
01297     set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[k] += set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[k];
01298   }
01299 
01300   <span class="comment">/* The last step. Compute the Chebyshev coeffcients c_k^n from the</span>
01301 <span class="comment">   * polynomials in front of P_0^n and P_1^n. */</span>
01302   y[0] = data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a>*(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[0] + data-&gt;<a class="code" href="structfpt__data__.html#o6">beta_0</a>*set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk] +
01303     data-&gt;<a class="code" href="structfpt__data__.html#o5">alpha_0</a>*set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk+1]*0.5);
01304   y[1] = data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a>*(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[1] + data-&gt;<a class="code" href="structfpt__data__.html#o6">beta_0</a>*set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk+1]+
01305     data-&gt;<a class="code" href="structfpt__data__.html#o5">alpha_0</a>*(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk]+set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk+2]*0.5));
01306   y[k_end-1] = data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a>*(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[k_end-1] +
01307     data-&gt;<a class="code" href="structfpt__data__.html#o6">beta_0</a>*set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk+k_end-1] +
01308     data-&gt;<a class="code" href="structfpt__data__.html#o5">alpha_0</a>*set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk+k_end-2]*0.5);
01309   y[k_end] = data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a>*(0.5*data-&gt;<a class="code" href="structfpt__data__.html#o5">alpha_0</a>*set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk+k_end-1]);
01310   <span class="keywordflow">for</span> (k = 2; k &lt;= k_end-2; k++)
01311   {
01312     y[k] = data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a>*(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[k] + data-&gt;<a class="code" href="structfpt__data__.html#o6">beta_0</a>*set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk+k] +
01313       data-&gt;<a class="code" href="structfpt__data__.html#o5">alpha_0</a>*0.5*(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk+k-1]+set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk+k+1]));
01314   }
01315 
01316   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__fpt.html#ga12">FPT_FUNCTION_VALUES</a>)
01317   {
01318     y[0] *= 2.0;
01319     fftw_execute_r2r(plan,(<span class="keywordtype">double</span>*)y,(<span class="keywordtype">double</span>*)y);
01320     fftw_destroy_plan(plan);
01321     <span class="keywordflow">for</span> (k = 0; k &lt;= k_end; k++)
01322     {
01323       y[k] *= 0.5;
01324     }
01325   }
01326 }
01327 
<a name="l01328"></a><a class="code" href="group__fpt.html#ga5">01328</a> <span class="keywordtype">void</span> <a class="code" href="group__fpt.html#ga5">dpt_transposed</a>(<a class="code" href="structfpt__set__s__.html">fpt_set</a> set, <span class="keyword">const</span> <span class="keywordtype">int</span> m, <span class="keywordtype">double</span> complex *x,
01329   <span class="keywordtype">double</span> complex *y, <span class="keyword">const</span> <span class="keywordtype">int</span> k_end, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
01330 {
01331   <span class="keywordtype">int</span> j;
01332   <a class="code" href="structfpt__data__.html">fpt_data</a> *data = &amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o4">dpt</a>[m]);
01333   <span class="keywordtype">int</span> Nk;
01334   <span class="keywordtype">int</span> tk;
01335   <span class="keywordtype">double</span> norm;
01336 
01337   <a class="code" href="group__nfftutil.html#ga5">nfft_next_power_of_2_exp</a>(k_end+1,&amp;Nk,&amp;tk);
01338   norm = 2.0/(Nk&lt;&lt;1);
01339 
01340   <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga9">FPT_NO_DIRECT_ALGORITHM</a>)
01341   {
01342     <span class="keywordflow">return</span>;
01343   }
01344 
01345   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__fpt.html#ga12">FPT_FUNCTION_VALUES</a>)
01346   {
01347     <span class="keywordflow">for</span> (j = 0; j &lt;= k_end; j++)
01348     {
01349       set-&gt;<a class="code" href="structfpt__set__s__.html#o18">xc_slow</a>[j] = cos((<a class="code" href="group__nfftutil.html#ga57">PI</a>*(j+0.5))/(k_end+1));
01350     }
01351 
01352     <a class="code" href="fpt_8c.html#a36">eval_sum_clenshaw_transposed</a>(k_end, k_end, set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o18">xc_slow</a>,
01353       y, set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>, &amp;data-&gt;<a class="code" href="structfpt__data__.html#o8">alpha</a>[1], &amp;data-&gt;<a class="code" href="structfpt__data__.html#o9">beta</a>[1], &amp;data-&gt;<a class="code" href="structfpt__data__.html#o10">gamma</a>[1],
01354       data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a>);
01355 
01356     memcpy(x,&amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>],(k_end-data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>+1)*
01357       <span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01358   }
01359   <span class="keywordflow">else</span>
01360   {
01361     memcpy(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>,y,(k_end+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01362     memset(&amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[k_end+1],0U,(Nk-k_end-1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01363 
01364     <span class="keywordflow">for</span> (j = 0; j &lt; Nk; j++)
01365     {
01366       set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[j] *= norm;
01367     }
01368 
01369     fftw_execute_r2r(set-&gt;<a class="code" href="structfpt__set__s__.html#o13">plans_dct3</a>[tk-2],(<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>,
01370       (<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>);
01371 
01372     <a class="code" href="fpt_8c.html#a36">eval_sum_clenshaw_transposed</a>(k_end, Nk-1, set-&gt;<a class="code" href="structfpt__set__s__.html#o7">temp</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tk-2],
01373       set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>, &amp;data-&gt;<a class="code" href="structfpt__data__.html#o8">alpha</a>[1], &amp;data-&gt;<a class="code" href="structfpt__data__.html#o9">beta</a>[1], &amp;data-&gt;<a class="code" href="structfpt__data__.html#o10">gamma</a>[1],
01374       data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a>);
01375 
01376     memcpy(x,&amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o7">temp</a>[data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>],(k_end-data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01377   }
01378 }
01379 
<a name="l01380"></a><a class="code" href="group__fpt.html#ga6">01380</a> <span class="keywordtype">void</span> <a class="code" href="group__fpt.html#ga6">fpt_transposed</a>(<a class="code" href="structfpt__set__s__.html">fpt_set</a> set, <span class="keyword">const</span> <span class="keywordtype">int</span> m, <span class="keywordtype">double</span> complex *x,
01381   <span class="keyword">const</span> <span class="keywordtype">double</span> complex *y, <span class="keyword">const</span> <span class="keywordtype">int</span> k_end, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> flags)
01382 {
01383   <span class="comment">/* Get transformation data. */</span>
01384   <a class="code" href="structfpt__data__.html">fpt_data</a> *data = &amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o4">dpt</a>[m]);
01386   <span class="keywordtype">int</span> Nk;
01388   <span class="keywordtype">int</span> tk;
01390   <span class="keywordtype">int</span> k_start_tilde;
01392   <span class="keywordtype">int</span> k_end_tilde;
01393 
01395   <span class="keywordtype">int</span> tau;
01397   <span class="keywordtype">int</span> firstl;
01399   <span class="keywordtype">int</span> lastl;
01401   <span class="keywordtype">int</span> l;
01403   <span class="keywordtype">int</span> plength;
01405   <span class="keywordtype">int</span> plength_stab;
01407   <a class="code" href="structfpt__step__.html">fpt_step</a> *step;
01409   fftw_plan plan;
01410   <span class="keywordtype">int</span> length = k_end+1;
01411   fftw_r2r_kind kinds[2] = {FFTW_REDFT10,FFTW_REDFT10};
01413   <span class="keywordtype">int</span> k;
01414   <span class="keywordtype">int</span> t_stab;
01415 
01416   <span class="comment">/* Check, if slow transformation should be used due to small bandwidth. */</span>
01417   <span class="keywordflow">if</span> (k_end &lt; FPT_BREAK_EVEN)
01418   {
01419     <span class="comment">/* Use NDSFT. */</span>
01420     <a class="code" href="group__fpt.html#ga5">dpt_transposed</a>(set, m, x, y, k_end, flags);
01421   }
01422 
01423   <a class="code" href="group__nfftutil.html#ga5">nfft_next_power_of_2_exp</a>(k_end,&amp;Nk,&amp;tk);
01424   k_start_tilde = <a class="code" href="fpt_8c.html#a0">K_START_TILDE</a>(data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>,Nk);
01425   k_end_tilde = <a class="code" href="fpt_8c.html#a1">K_END_TILDE</a>(k_end,Nk);
01426 
01427   <span class="comment">/* Check if fast transform is activated. */</span>
01428   <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga8">FPT_NO_FAST_ALGORITHM</a>)
01429   {
01430     <span class="keywordflow">return</span>;
01431   }
01432 
01433   <span class="keywordflow">if</span> (flags &amp; <a class="code" href="group__fpt.html#ga12">FPT_FUNCTION_VALUES</a>)
01434   {
01435     plan = fftw_plan_many_r2r(1, &amp;length, 2, (<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>, NULL, 2, 1,
01436       (<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>, NULL, 2, 1, kinds, 0U);
01437     fftw_execute_r2r(plan,(<span class="keywordtype">double</span>*)y,(<span class="keywordtype">double</span>*)set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>);
01438     fftw_destroy_plan(plan);
01439     <span class="keywordflow">for</span> (k = 0; k &lt;= k_end; k++)
01440     {
01441       set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[k] *= 0.5;
01442     }
01443   }
01444   <span class="keywordflow">else</span>
01445   {
01446     memcpy(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>,y,(k_end+1)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01447   }
01448 
01449   <span class="comment">/* Initialize working arrays. */</span>
01450   memset(set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>,0U,2*Nk*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01451 
01452   <span class="comment">/* The last step is now the first step. */</span>
01453   <span class="keywordflow">for</span> (k = 0; k &lt;= k_end; k++)
01454   {
01455     set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[k] = data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a>*set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[k];
01456   }
01457   <span class="comment">//memset(&amp;set-&gt;work[k_end+1],0U,(Nk+1-k_end)*sizeof(double complex));</span>
01458 
01459   set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[Nk] = data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a>*(data-&gt;<a class="code" href="structfpt__data__.html#o6">beta_0</a>*set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[0] +
01460     data-&gt;<a class="code" href="structfpt__data__.html#o5">alpha_0</a>*set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[1]);
01461   <span class="keywordflow">for</span> (k = 1; k &lt; k_end; k++)
01462   {
01463     set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[Nk+k] = data-&gt;<a class="code" href="structfpt__data__.html#o7">gamma_m1</a>*(data-&gt;<a class="code" href="structfpt__data__.html#o6">beta_0</a>*set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[k] +
01464       data-&gt;<a class="code" href="structfpt__data__.html#o5">alpha_0</a>*0.5*(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[k-1]+set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[k+1]));
01465   }
01466   <span class="keywordflow">if</span> (k_end&lt;Nk)
01467   {
01468     memset(&amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[k_end],0U,(Nk-k_end)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01469   }
01470 
01472   memcpy(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>,set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>,2*Nk*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01473 
01474   <span class="comment">/* Compute the remaining steps. */</span>
01475   plength = Nk;
01476   <span class="keywordflow">for</span> (tau = tk-1; tau &gt;= 1; tau--)
01477   {
01478     <span class="comment">/* Compute first l. */</span>
01479     firstl = <a class="code" href="fpt_8c.html#a2">FIRST_L</a>(k_start_tilde,plength);
01480     <span class="comment">/* Compute last l. */</span>
01481     lastl = <a class="code" href="fpt_8c.html#a3">LAST_L</a>(k_end_tilde,plength);
01482 
01483     <span class="comment">/* Compute the multiplication steps. */</span>
01484     <span class="keywordflow">for</span> (l = firstl; l &lt;= lastl; l++)
01485     {
01486       <span class="comment">/* Initialize second half of coefficient arrays with zeros. */</span>
01487       memcpy(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>,&amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[(plength/2)*(4*l+0)]),plength*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01488       memcpy(set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>,&amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[(plength/2)*(4*l+2)]),plength*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01489 
01490       memcpy(&amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[(plength/2)*(4*l+1)],&amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[(plength/2)*(4*l+2)]),
01491         (plength/2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01492 
01493       <span class="comment">/* Get matrix U_{n,tau,l} */</span>
01494       step = &amp;(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l]);
01495 
01496       <span class="comment">/* Check if step is stable. */</span>
01497       <span class="keywordflow">if</span> (step-&gt;<a class="code" href="structfpt__step__.html#o0">stable</a>)
01498       {
01499         <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga13">FPT_AL_SYMMETRY</a> &amp;&amp; IS_SYMMETRIC(l,m,plength))
01500         {
01501           <span class="comment">/* Multiply third and fourth polynomial with matrix U. */</span>
01502           <a class="code" href="fpt_8c.html#a30">fpt_do_step_transposed_symmetric</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>, step-&gt;<a class="code" href="structfpt__step__.html#o3">a11</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o4">a12</a>[0],
01503             step-&gt;<a class="code" href="structfpt__step__.html#o5">a21</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o6">a22</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0], tau, set);
01504         }
01505         <span class="keywordflow">else</span>
01506         {
01507           <span class="comment">/* Multiply third and fourth polynomial with matrix U. */</span>
01508           fpt_do_step_transposed(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>, step-&gt;<a class="code" href="structfpt__step__.html#o3">a11</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o4">a12</a>[0],
01509             step-&gt;<a class="code" href="structfpt__step__.html#o5">a21</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o6">a22</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0], tau, set);
01510         }
01511         memcpy(&amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>[plength/2]), set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>,(plength/2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01512 
01513         <span class="keywordflow">for</span> (k = 0; k &lt; plength; k++)
01514         {
01515           set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[plength*(4*l+2)/2+k] = set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>[k];
01516         }
01517       }
01518       <span class="keywordflow">else</span>
01519       {
01520         <span class="comment">/* Stabilize. */</span>
01521         plength_stab = step-&gt;<a class="code" href="structfpt__step__.html#o1">N_stab</a>;
01522         t_stab = step-&gt;<a class="code" href="structfpt__step__.html#o2">t_stab</a>;
01523 
01524         memcpy(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>,set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>,plength_stab*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01525         memcpy(set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>,&amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>[Nk]),plength_stab*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01526 
01527         <span class="comment">/* Multiply third and fourth polynomial with matrix U. */</span>
01528         <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga13">FPT_AL_SYMMETRY</a>)
01529         {
01530           <span class="keywordflow">if</span> (m &lt;= 1)
01531           {
01532             <a class="code" href="fpt_8c.html#a30">fpt_do_step_transposed_symmetric</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>, step-&gt;<a class="code" href="structfpt__step__.html#o3">a11</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o4">a12</a>[0],
01533               step-&gt;<a class="code" href="structfpt__step__.html#o5">a21</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o6">a22</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0], t_stab-1, set);
01534           }
01535           <span class="keywordflow">else</span> <span class="keywordflow">if</span> (m%2 == 0)
01536           {
01537             <a class="code" href="fpt_8c.html#a31">fpt_do_step_transposed_symmetric_u</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>, step-&gt;<a class="code" href="structfpt__step__.html#o3">a11</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o4">a12</a>[0],
01538               step-&gt;<a class="code" href="structfpt__step__.html#o5">a21</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o6">a22</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0], t_stab-1, set);
01539           }
01540           <span class="keywordflow">else</span>
01541           {
01542             <a class="code" href="fpt_8c.html#a32">fpt_do_step_transposed_symmetric_l</a>(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>, step-&gt;<a class="code" href="structfpt__step__.html#o3">a11</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o4">a12</a>[0],
01543               step-&gt;<a class="code" href="structfpt__step__.html#o5">a21</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o6">a22</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0], t_stab-1, set);
01544           }
01545         }
01546         <span class="keywordflow">else</span>
01547         {
01548             fpt_do_step_transposed(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>, set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>, step-&gt;<a class="code" href="structfpt__step__.html#o3">a11</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o4">a12</a>[0],
01549               step-&gt;<a class="code" href="structfpt__step__.html#o5">a21</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o6">a22</a>[0], step-&gt;<a class="code" href="structfpt__step__.html#o7">gamma</a>[0], t_stab-1, set);
01550         }
01551 
01552         memcpy(&amp;(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>[plength/2]),set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>,(plength/2)*<span class="keyword">sizeof</span>(<span class="keywordtype">double</span> complex));
01553 
01554         <span class="keywordflow">for</span> (k = 0; k &lt; plength; k++)
01555         {
01556           set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[(plength/2)*(4*l+2)+k] = set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>[k];
01557         }
01558        }
01559     }
01560     <span class="comment">/* Half the length of polynomial arrays. */</span>
01561     plength = plength&gt;&gt;1;
01562   }
01563 
01564   <span class="comment">/* First step */</span>
01565   <span class="keywordflow">for</span> (k = 0; k &lt;= k_end_tilde-data-&gt;k_start; k++)
01566   {
01567     x[k] = set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[2*(data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>+k)];
01568   }
01569   <span class="keywordflow">if</span> (k_end == Nk)
01570   {
01571     x[Nk-data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>] =
01572         data-&gt;<a class="code" href="structfpt__data__.html#o4">gammaN</a>[tk-2]*set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[2*(Nk-2)]
01573       + data-&gt;<a class="code" href="structfpt__data__.html#o3">betaN</a>[tk-2] *set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[2*(Nk-1)]
01574       + data-&gt;<a class="code" href="structfpt__data__.html#o2">alphaN</a>[tk-2]*set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>[2*(Nk-1)+1];
01575   }
01576 }
01577 
<a name="l01578"></a><a class="code" href="group__fpt.html#ga7">01578</a> <span class="keywordtype">void</span> <a class="code" href="group__fpt.html#ga7">fpt_finalize</a>(<a class="code" href="structfpt__set__s__.html">fpt_set</a> set)
01579 {
01580   <span class="keywordtype">int</span> tau;
01581   <span class="keywordtype">int</span> l;
01582   <span class="keywordtype">int</span> m;
01583   <a class="code" href="structfpt__data__.html">fpt_data</a> *data;
01584   <span class="keywordtype">int</span> k_start_tilde;
01585   <span class="keywordtype">int</span> N_tilde;
01586   <span class="keywordtype">int</span> firstl, lastl;
01587   <span class="keywordtype">int</span> plength;
01588 
01589   <span class="comment">/* TODO Clean up DPT transform data structures. */</span>
01590   <span class="keywordflow">for</span> (m = 0; m &lt;= set-&gt;M; m++)
01591   {
01592     <span class="comment">/* Check if precomputed. */</span>
01593     data = &amp;set-&gt;<a class="code" href="structfpt__set__s__.html#o4">dpt</a>[m];
01594     <span class="keywordflow">if</span> (data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a> != (<a class="code" href="structfpt__step__.html">fpt_step</a>**)NULL)
01595     {
01596       free(data-&gt;<a class="code" href="structfpt__data__.html#o2">alphaN</a>);
01597       free(data-&gt;<a class="code" href="structfpt__data__.html#o3">betaN</a>);
01598       free(data-&gt;<a class="code" href="structfpt__data__.html#o4">gammaN</a>);
01599       data-&gt;<a class="code" href="structfpt__data__.html#o2">alphaN</a> = NULL;
01600       data-&gt;<a class="code" href="structfpt__data__.html#o3">betaN</a> = NULL;
01601       data-&gt;<a class="code" href="structfpt__data__.html#o4">gammaN</a> = NULL;
01602 
01603       <span class="comment">/* Free precomputed data. */</span>
01604       k_start_tilde = <a class="code" href="fpt_8c.html#a0">K_START_TILDE</a>(data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>,<a class="code" href="group__nfftutil.html#ga4">nfft_next_power_of_2</a>(data-&gt;<a class="code" href="structfpt__data__.html#o1">k_start</a>)
01605         <span class="comment">/*set-&gt;N*/</span>);
01606       N_tilde = N_TILDE(set-&gt;<a class="code" href="structfpt__set__s__.html#o2">N</a>);
01607       plength = 4;
01608       <span class="keywordflow">for</span> (tau = 1; tau &lt; set-&gt;t; tau++)
01609       {
01610         <span class="comment">/* Compute first l. */</span>
01611         firstl = <a class="code" href="fpt_8c.html#a2">FIRST_L</a>(k_start_tilde,plength);
01612         <span class="comment">/* Compute last l. */</span>
01613         lastl = <a class="code" href="fpt_8c.html#a3">LAST_L</a>(N_tilde,plength);
01614 
01615         <span class="comment">/* For l = 0,...2^{t-tau-1}-1 compute the matrices U_{n,tau,l}. */</span>
01616         <span class="keywordflow">for</span> (l = firstl; l &lt;= lastl; l++)
01617         {
01618           <span class="comment">/* Free components. */</span>
01619           free(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o3">a11</a>[0]);
01620           free(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o4">a12</a>[0]);
01621           free(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o5">a21</a>[0]);
01622           free(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o6">a22</a>[0]);
01623           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o3">a11</a>[0] = NULL;
01624           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o4">a12</a>[0] = NULL;
01625           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o5">a21</a>[0] = NULL;
01626           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o6">a22</a>[0] = NULL;
01627           <span class="comment">/* Free components. */</span>
01628           free(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o3">a11</a>);
01629           free(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o4">a12</a>);
01630           free(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o5">a21</a>);
01631           free(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o6">a22</a>);
01632           free(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o7">gamma</a>);
01633           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o3">a11</a> = NULL;
01634           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o4">a12</a> = NULL;
01635           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o5">a21</a> = NULL;
01636           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o6">a22</a> = NULL;
01637           data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau][l].<a class="code" href="structfpt__step__.html#o7">gamma</a> = NULL;
01638         }
01639         <span class="comment">/* Free pointers for current level. */</span>
01640         free(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau]);
01641         data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>[tau] = NULL;
01642         <span class="comment">/* Double length of polynomials. */</span>
01643         plength = plength&lt;&lt;1;
01644       }
01645       <span class="comment">/* Free steps. */</span>
01646       free(data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a>);
01647       data-&gt;<a class="code" href="structfpt__data__.html#o0">steps</a> = NULL;
01648     }
01649 
01650     <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga9">FPT_NO_DIRECT_ALGORITHM</a>)
01651     {
01652     }
01653     <span class="keywordflow">else</span>
01654     {
01655       <span class="comment">/* Check, if recurrence coefficients must be copied. */</span>
01656       <span class="comment">//fprintf(stderr,"\nfpt_finalize: %d\n",set-&gt;flags &amp; FPT_PERSISTENT_DATA);</span>
01657       <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga11">FPT_PERSISTENT_DATA</a>)
01658       {
01659       }
01660       <span class="keywordflow">else</span>
01661       {
01662         free(data-&gt;<a class="code" href="structfpt__data__.html#o8">alpha</a>);
01663         free(data-&gt;<a class="code" href="structfpt__data__.html#o9">beta</a>);
01664         free(data-&gt;<a class="code" href="structfpt__data__.html#o10">gamma</a>);
01665       }
01666       data-&gt;<a class="code" href="structfpt__data__.html#o8">alpha</a> = NULL;
01667       data-&gt;<a class="code" href="structfpt__data__.html#o9">beta</a> = NULL;
01668       data-&gt;<a class="code" href="structfpt__data__.html#o10">gamma</a> = NULL;
01669     }
01670   }
01671 
01672   <span class="comment">/* Delete array of DPT transform data. */</span>
01673   free(set-&gt;<a class="code" href="structfpt__set__s__.html#o4">dpt</a>);
01674   set-&gt;<a class="code" href="structfpt__set__s__.html#o4">dpt</a> = NULL;
01675 
01676   <span class="keywordflow">for</span> (tau = 1; tau &lt; /*set-&gt;t*/set-&gt;<a class="code" href="structfpt__set__s__.html#o3">t</a>+1; tau++)
01677   {
01678     free(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tau-1]);
01679     set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>[tau-1] = NULL;
01680   }
01681   free(set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a>);
01682   set-&gt;<a class="code" href="structfpt__set__s__.html#o5">xcvecs</a> = NULL;
01683 
01684   <span class="comment">/* Free auxilliary arrays. */</span>
01685   free(set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a>);
01686   free(set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a>);
01687 
01688   <span class="comment">/* Check if fast transform is activated. */</span>
01689   <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga8">FPT_NO_FAST_ALGORITHM</a>)
01690   {
01691   }
01692   <span class="keywordflow">else</span>
01693   {
01694     <span class="comment">/* Free auxilliary arrays. */</span>
01695     free(set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a>);
01696     free(set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a>);
01697     free(set-&gt;<a class="code" href="structfpt__set__s__.html#o12">z</a>);
01698     set-&gt;<a class="code" href="structfpt__set__s__.html#o8">work</a> = NULL;
01699     set-&gt;<a class="code" href="structfpt__set__s__.html#o9">result</a> = NULL;
01700     set-&gt;<a class="code" href="structfpt__set__s__.html#o10">vec3</a> = NULL;
01701     set-&gt;<a class="code" href="structfpt__set__s__.html#o11">vec4</a> = NULL;
01702     set-&gt;<a class="code" href="structfpt__set__s__.html#o12">z</a> = NULL;
01703 
01704     <span class="comment">/* Free FFTW plans. */</span>
01705     <span class="keywordflow">for</span>(tau = 0; tau &lt; set-&gt;<a class="code" href="structfpt__set__s__.html#o3">t</a><span class="comment">/*-1*/</span>; tau++)
01706     {
01707       fftw_destroy_plan(set-&gt;<a class="code" href="structfpt__set__s__.html#o13">plans_dct3</a>[tau]);
01708       fftw_destroy_plan(set-&gt;<a class="code" href="structfpt__set__s__.html#o14">plans_dct2</a>[tau]);
01709       set-&gt;<a class="code" href="structfpt__set__s__.html#o13">plans_dct3</a>[tau] = NULL;
01710       set-&gt;<a class="code" href="structfpt__set__s__.html#o14">plans_dct2</a>[tau] = NULL;
01711     }
01712 
01713     free(set-&gt;<a class="code" href="structfpt__set__s__.html#o13">plans_dct3</a>);
01714     free(set-&gt;<a class="code" href="structfpt__set__s__.html#o14">plans_dct2</a>);
01715     set-&gt;<a class="code" href="structfpt__set__s__.html#o13">plans_dct3</a> = NULL;
01716     set-&gt;<a class="code" href="structfpt__set__s__.html#o14">plans_dct2</a> = NULL;
01717   }
01718 
01719   <span class="comment">//fprintf(stderr,"fpt_finalize: flags = %d\n",set-&gt;flags);</span>
01720 
01721   <span class="keywordflow">if</span> (set-&gt;<a class="code" href="structfpt__set__s__.html#o0">flags</a> &amp; <a class="code" href="group__fpt.html#ga9">FPT_NO_DIRECT_ALGORITHM</a>)
01722   {
01723   }
01724   <span class="keywordflow">else</span>
01725   {
01726     <span class="comment">/* Delete arrays of Chebyshev nodes. */</span>
01727     free(set-&gt;<a class="code" href="structfpt__set__s__.html#o18">xc_slow</a>);
01728     set-&gt;<a class="code" href="structfpt__set__s__.html#o18">xc_slow</a> = NULL;
01729     free(set-&gt;<a class="code" href="structfpt__set__s__.html#o7">temp</a>);
01730     set-&gt;<a class="code" href="structfpt__set__s__.html#o7">temp</a> = NULL;
01731   }
01732 
01733   <span class="comment">/* Free DPT set structure. */</span>
01734   free(set);
01735 }
</pre></div>    <hr size="1"/>
    Generated on 22 Jan 2007 by Doxygen 1.4.1
  </body>
</html>
